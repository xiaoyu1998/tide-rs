/**

Generated by the following Solidity interface...
```solidity
interface Keys {
    function ACCOUNT_POSITION_LIST() external view returns (bytes32);
    function DEBT_SAFETY_FACTOR() external view returns (bytes32);
    function DEFAULT_INTEREST_RATE_STRATEGY() external view returns (bytes32);
    function DEFAULT_POOL_CONFIGURATION() external view returns (bytes32);
    function LIQUIDATION_FEE() external view returns (bytes32);
    function MARGIN_LEVELL_THRESHOLD() external view returns (bytes32);
    function MAX_BORROW_RATE() external view returns (bytes32);
    function MAX_DEPOSIT_RATE() external view returns (bytes32);
    function POOL() external view returns (bytes32);
    function POOL_LIST() external view returns (bytes32);
    function POSITION() external view returns (bytes32);
    function POSITION_LIST() external view returns (bytes32);
    function REENTRANCY_GUARD_STATUS() external view returns (bytes32);
    function SHORT_LIQUIDITY_THRESHOLD() external view returns (bytes32);
    function TOKEN_BASE() external view returns (bytes32);
    function TRADABLE_DEBT_MULTIPIER_FACTOR() external view returns (bytes32);
    function TREASURY() external view returns (bytes32);
    function WNT() external view returns (bytes32);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "ACCOUNT_POSITION_LIST",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEBT_SAFETY_FACTOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_INTEREST_RATE_STRATEGY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_POOL_CONFIGURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LIQUIDATION_FEE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MARGIN_LEVELL_THRESHOLD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MAX_BORROW_RATE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MAX_DEPOSIT_RATE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_LIST",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POSITION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POSITION_LIST",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "REENTRANCY_GUARD_STATUS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SHORT_LIQUIDITY_THRESHOLD",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOKEN_BASE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TRADABLE_DEBT_MULTIPIER_FACTOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TREASURY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "WNT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod Keys {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6105d3610034600b8282823980515f1a607314602857634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061011c575f3560e01c80637535d246116100a9578063993f545011610079578063993f54501461019a5780639bfe0ccf146101a2578063b1827330146101aa578063b8b4a543146101b2578063cea63f5d146101ba575f5ffd5b80637535d2461461017a578063769af85d146101825780637a0c5ebf1461018a5780637bf43e4714610192575f5ffd5b806335bf7457116100ef57806335bf74571461015257806336fef13d1461015a5780633d49adda146101625780633fe6e1901461016a5780636714ddd514610172575f5ffd5b8063041429b8146101205780632ccfe1eb1461013a5780632d2c556514610142578063355ac5961461014a575b5f5ffd5b6101286101c2565b60405190815260200160405180910390f35b610128610214565b610128610255565b610128610281565b6101286102ad565b6101286102da565b610128610310565b610128610351565b610128610385565b6101286103c6565b6101286103ee565b61012861041c565b61012861044f565b610128610476565b6101286104b7565b6101286104f8565b61012861052b565b61012861055c565b6040516020016101fb906020808252601590820152741050d0d3d5539517d413d4d2551253d397d31254d5605a1b604082015260600190565b6040516020818303038152906040528051906020012081565b6040516020016101fb9060208082526019908201527f53484f52545f4c49515549444954595f5448524553484f4c4400000000000000604082015260600190565b6040516020016101fb90602080825260089082015267545245415355525960c01b604082015260600190565b6040516020016101fb906020808252600890820152672827a9a4aa24a7a760c11b604082015260600190565b6040516020016101fb906020808252600990820152681413d3d317d31254d560ba1b604082015260600190565b6040516020016101fb906020808252601290820152712222a12a2fa9a0a322aa2cafa320a1aa27a960711b604082015260600190565b6040516020016101fb906020808252601e908201527f5452414441424c455f444542545f4d554c5449504945525f464143544f520000604082015260600190565b6040516020016101fb9060208082526010908201526f4d41585f4445504f5349545f5241544560801b604082015260600190565b6040516020016101fb906020808252601e908201527f44454641554c545f494e5445524553545f524154455f53545241544547590000604082015260600190565b6040516020016101fb906020808252600490820152631413d3d360e21b604082015260600190565b6040516020016101fb906020808252600a9082015269544f4b454e5f4241534560b01b604082015260600190565b6040516020016101fb906020808252600f908201526e4d41585f424f52524f575f5241544560881b604082015260600190565b6040516020016101fb9060208082526003908201526215d39560ea1b604082015260600190565b6040516020016101fb906020808252601a908201527f44454641554c545f504f4f4c5f434f4e46494755524154494f4e000000000000604082015260600190565b6040516020016101fb9060208082526017908201527f5245454e5452414e43595f47554152445f535441545553000000000000000000604082015260600190565b6040516020016101fb906020808252600f908201526e4c49515549444154494f4e5f46454560881b604082015260600190565b6040516020016101fb906020808252600d908201526c1413d4d2551253d397d31254d5609a1b604082015260600190565b6040516020016101fb9060208082526017908201527f4d415247494e5f4c4556454c4c5f5448524553484f4c4400000000000000000060408201526060019056fea26469706673582212206b44d2b2ab2dbf9c471f0ec0b6bde717f1bd864af26eb372c962179a90026aa664736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x05\xD3a\x004`\x0B\x82\x82\x829\x80Q_\x1A`s\x14`(WcNH{q`\xE0\x1B_R_`\x04R`$_\xFD[0_R`s\x81S\x82\x81\xF3\xFEs\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R`\x046\x10a\x01\x1CW_5`\xE0\x1C\x80cu5\xD2F\x11a\0\xA9W\x80c\x99?TP\x11a\0yW\x80c\x99?TP\x14a\x01\x9AW\x80c\x9B\xFE\x0C\xCF\x14a\x01\xA2W\x80c\xB1\x82s0\x14a\x01\xAAW\x80c\xB8\xB4\xA5C\x14a\x01\xB2W\x80c\xCE\xA6?]\x14a\x01\xBAW__\xFD[\x80cu5\xD2F\x14a\x01zW\x80cv\x9A\xF8]\x14a\x01\x82W\x80cz\x0C^\xBF\x14a\x01\x8AW\x80c{\xF4>G\x14a\x01\x92W__\xFD[\x80c5\xBFtW\x11a\0\xEFW\x80c5\xBFtW\x14a\x01RW\x80c6\xFE\xF1=\x14a\x01ZW\x80c=I\xAD\xDA\x14a\x01bW\x80c?\xE6\xE1\x90\x14a\x01jW\x80cg\x14\xDD\xD5\x14a\x01rW__\xFD[\x80c\x04\x14)\xB8\x14a\x01 W\x80c,\xCF\xE1\xEB\x14a\x01:W\x80c-,Ue\x14a\x01BW\x80c5Z\xC5\x96\x14a\x01JW[__\xFD[a\x01(a\x01\xC2V[`@Q\x90\x81R` \x01`@Q\x80\x91\x03\x90\xF3[a\x01(a\x02\x14V[a\x01(a\x02UV[a\x01(a\x02\x81V[a\x01(a\x02\xADV[a\x01(a\x02\xDAV[a\x01(a\x03\x10V[a\x01(a\x03QV[a\x01(a\x03\x85V[a\x01(a\x03\xC6V[a\x01(a\x03\xEEV[a\x01(a\x04\x1CV[a\x01(a\x04OV[a\x01(a\x04vV[a\x01(a\x04\xB7V[a\x01(a\x04\xF8V[a\x01(a\x05+V[a\x01(a\x05\\V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x15\x90\x82\x01Rt\x10P\xD0\xD3\xD5S\x95\x17\xD4\x13\xD4\xD2U\x12S\xD3\x97\xD3\x12T\xD5`Z\x1B`@\x82\x01R``\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x19\x90\x82\x01R\x7FSHORT_LIQUIDITY_THRESHOLD\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x08\x90\x82\x01RgTREASURY`\xC0\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x08\x90\x82\x01Rg('\xA9\xA4\xAA$\xA7\xA7`\xC1\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\t\x90\x82\x01Rh\x14\x13\xD3\xD3\x17\xD3\x12T\xD5`\xBA\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x12\x90\x82\x01Rq\"\"\xA1*/\xA9\xA0\xA3\"\xAA,\xAF\xA3 \xA1\xAA'\xA9`q\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x1E\x90\x82\x01R\x7FTRADABLE_DEBT_MULTIPIER_FACTOR\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x10\x90\x82\x01RoMAX_DEPOSIT_RATE`\x80\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x1E\x90\x82\x01R\x7FDEFAULT_INTEREST_RATE_STRATEGY\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x04\x90\x82\x01Rc\x14\x13\xD3\xD3`\xE2\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\n\x90\x82\x01RiTOKEN_BASE`\xB0\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x0F\x90\x82\x01RnMAX_BORROW_RATE`\x88\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x03\x90\x82\x01Rb\x15\xD3\x95`\xEA\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x1A\x90\x82\x01R\x7FDEFAULT_POOL_CONFIGURATION\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x17\x90\x82\x01R\x7FREENTRANCY_GUARD_STATUS\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x0F\x90\x82\x01RnLIQUIDATION_FEE`\x88\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\r\x90\x82\x01Rl\x14\x13\xD4\xD2U\x12S\xD3\x97\xD3\x12T\xD5`\x9A\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x17\x90\x82\x01R\x7FMARGIN_LEVELL_THRESHOLD\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V\xFE\xA2dipfsX\"\x12 kD\xD2\xB2\xAB-\xBF\x9CG\x1F\x0E\xC0\xB6\xBD\xE7\x17\xF1\xBD\x86J\xF2n\xB3r\xC9b\x17\x9A\x90\x02j\xA6dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x730000000000000000000000000000000000000000301460806040526004361061011c575f3560e01c80637535d246116100a9578063993f545011610079578063993f54501461019a5780639bfe0ccf146101a2578063b1827330146101aa578063b8b4a543146101b2578063cea63f5d146101ba575f5ffd5b80637535d2461461017a578063769af85d146101825780637a0c5ebf1461018a5780637bf43e4714610192575f5ffd5b806335bf7457116100ef57806335bf74571461015257806336fef13d1461015a5780633d49adda146101625780633fe6e1901461016a5780636714ddd514610172575f5ffd5b8063041429b8146101205780632ccfe1eb1461013a5780632d2c556514610142578063355ac5961461014a575b5f5ffd5b6101286101c2565b60405190815260200160405180910390f35b610128610214565b610128610255565b610128610281565b6101286102ad565b6101286102da565b610128610310565b610128610351565b610128610385565b6101286103c6565b6101286103ee565b61012861041c565b61012861044f565b610128610476565b6101286104b7565b6101286104f8565b61012861052b565b61012861055c565b6040516020016101fb906020808252601590820152741050d0d3d5539517d413d4d2551253d397d31254d5605a1b604082015260600190565b6040516020818303038152906040528051906020012081565b6040516020016101fb9060208082526019908201527f53484f52545f4c49515549444954595f5448524553484f4c4400000000000000604082015260600190565b6040516020016101fb90602080825260089082015267545245415355525960c01b604082015260600190565b6040516020016101fb906020808252600890820152672827a9a4aa24a7a760c11b604082015260600190565b6040516020016101fb906020808252600990820152681413d3d317d31254d560ba1b604082015260600190565b6040516020016101fb906020808252601290820152712222a12a2fa9a0a322aa2cafa320a1aa27a960711b604082015260600190565b6040516020016101fb906020808252601e908201527f5452414441424c455f444542545f4d554c5449504945525f464143544f520000604082015260600190565b6040516020016101fb9060208082526010908201526f4d41585f4445504f5349545f5241544560801b604082015260600190565b6040516020016101fb906020808252601e908201527f44454641554c545f494e5445524553545f524154455f53545241544547590000604082015260600190565b6040516020016101fb906020808252600490820152631413d3d360e21b604082015260600190565b6040516020016101fb906020808252600a9082015269544f4b454e5f4241534560b01b604082015260600190565b6040516020016101fb906020808252600f908201526e4d41585f424f52524f575f5241544560881b604082015260600190565b6040516020016101fb9060208082526003908201526215d39560ea1b604082015260600190565b6040516020016101fb906020808252601a908201527f44454641554c545f504f4f4c5f434f4e46494755524154494f4e000000000000604082015260600190565b6040516020016101fb9060208082526017908201527f5245454e5452414e43595f47554152445f535441545553000000000000000000604082015260600190565b6040516020016101fb906020808252600f908201526e4c49515549444154494f4e5f46454560881b604082015260600190565b6040516020016101fb906020808252600d908201526c1413d4d2551253d397d31254d5609a1b604082015260600190565b6040516020016101fb9060208082526017908201527f4d415247494e5f4c4556454c4c5f5448524553484f4c4400000000000000000060408201526060019056fea26469706673582212206b44d2b2ab2dbf9c471f0ec0b6bde717f1bd864af26eb372c962179a90026aa664736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"s\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R`\x046\x10a\x01\x1CW_5`\xE0\x1C\x80cu5\xD2F\x11a\0\xA9W\x80c\x99?TP\x11a\0yW\x80c\x99?TP\x14a\x01\x9AW\x80c\x9B\xFE\x0C\xCF\x14a\x01\xA2W\x80c\xB1\x82s0\x14a\x01\xAAW\x80c\xB8\xB4\xA5C\x14a\x01\xB2W\x80c\xCE\xA6?]\x14a\x01\xBAW__\xFD[\x80cu5\xD2F\x14a\x01zW\x80cv\x9A\xF8]\x14a\x01\x82W\x80cz\x0C^\xBF\x14a\x01\x8AW\x80c{\xF4>G\x14a\x01\x92W__\xFD[\x80c5\xBFtW\x11a\0\xEFW\x80c5\xBFtW\x14a\x01RW\x80c6\xFE\xF1=\x14a\x01ZW\x80c=I\xAD\xDA\x14a\x01bW\x80c?\xE6\xE1\x90\x14a\x01jW\x80cg\x14\xDD\xD5\x14a\x01rW__\xFD[\x80c\x04\x14)\xB8\x14a\x01 W\x80c,\xCF\xE1\xEB\x14a\x01:W\x80c-,Ue\x14a\x01BW\x80c5Z\xC5\x96\x14a\x01JW[__\xFD[a\x01(a\x01\xC2V[`@Q\x90\x81R` \x01`@Q\x80\x91\x03\x90\xF3[a\x01(a\x02\x14V[a\x01(a\x02UV[a\x01(a\x02\x81V[a\x01(a\x02\xADV[a\x01(a\x02\xDAV[a\x01(a\x03\x10V[a\x01(a\x03QV[a\x01(a\x03\x85V[a\x01(a\x03\xC6V[a\x01(a\x03\xEEV[a\x01(a\x04\x1CV[a\x01(a\x04OV[a\x01(a\x04vV[a\x01(a\x04\xB7V[a\x01(a\x04\xF8V[a\x01(a\x05+V[a\x01(a\x05\\V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x15\x90\x82\x01Rt\x10P\xD0\xD3\xD5S\x95\x17\xD4\x13\xD4\xD2U\x12S\xD3\x97\xD3\x12T\xD5`Z\x1B`@\x82\x01R``\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x19\x90\x82\x01R\x7FSHORT_LIQUIDITY_THRESHOLD\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x08\x90\x82\x01RgTREASURY`\xC0\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x08\x90\x82\x01Rg('\xA9\xA4\xAA$\xA7\xA7`\xC1\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\t\x90\x82\x01Rh\x14\x13\xD3\xD3\x17\xD3\x12T\xD5`\xBA\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x12\x90\x82\x01Rq\"\"\xA1*/\xA9\xA0\xA3\"\xAA,\xAF\xA3 \xA1\xAA'\xA9`q\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x1E\x90\x82\x01R\x7FTRADABLE_DEBT_MULTIPIER_FACTOR\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x10\x90\x82\x01RoMAX_DEPOSIT_RATE`\x80\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x1E\x90\x82\x01R\x7FDEFAULT_INTEREST_RATE_STRATEGY\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x04\x90\x82\x01Rc\x14\x13\xD3\xD3`\xE2\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\n\x90\x82\x01RiTOKEN_BASE`\xB0\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x0F\x90\x82\x01RnMAX_BORROW_RATE`\x88\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x03\x90\x82\x01Rb\x15\xD3\x95`\xEA\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x1A\x90\x82\x01R\x7FDEFAULT_POOL_CONFIGURATION\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x17\x90\x82\x01R\x7FREENTRANCY_GUARD_STATUS\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x0F\x90\x82\x01RnLIQUIDATION_FEE`\x88\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\r\x90\x82\x01Rl\x14\x13\xD4\xD2U\x12S\xD3\x97\xD3\x12T\xD5`\x9A\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x01\xFB\x90` \x80\x82R`\x17\x90\x82\x01R\x7FMARGIN_LEVELL_THRESHOLD\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V\xFE\xA2dipfsX\"\x12 kD\xD2\xB2\xAB-\xBF\x9CG\x1F\x0E\xC0\xB6\xBD\xE7\x17\xF1\xBD\x86J\xF2n\xB3r\xC9b\x17\x9A\x90\x02j\xA6dsolcC\0\x08\x1C\x003",
    );
    /**Function with signature `ACCOUNT_POSITION_LIST()` and selector `0x041429b8`.
```solidity
function ACCOUNT_POSITION_LIST() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ACCOUNT_POSITION_LISTCall {}
    ///Container type for the return parameters of the [`ACCOUNT_POSITION_LIST()`](ACCOUNT_POSITION_LISTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ACCOUNT_POSITION_LISTReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ACCOUNT_POSITION_LISTCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ACCOUNT_POSITION_LISTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ACCOUNT_POSITION_LISTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ACCOUNT_POSITION_LISTReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ACCOUNT_POSITION_LISTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ACCOUNT_POSITION_LISTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ACCOUNT_POSITION_LISTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ACCOUNT_POSITION_LISTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ACCOUNT_POSITION_LIST()";
            const SELECTOR: [u8; 4] = [4u8, 20u8, 41u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEBT_SAFETY_FACTOR()` and selector `0x36fef13d`.
```solidity
function DEBT_SAFETY_FACTOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEBT_SAFETY_FACTORCall {}
    ///Container type for the return parameters of the [`DEBT_SAFETY_FACTOR()`](DEBT_SAFETY_FACTORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEBT_SAFETY_FACTORReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEBT_SAFETY_FACTORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEBT_SAFETY_FACTORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEBT_SAFETY_FACTORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEBT_SAFETY_FACTORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEBT_SAFETY_FACTORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEBT_SAFETY_FACTORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEBT_SAFETY_FACTORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEBT_SAFETY_FACTORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEBT_SAFETY_FACTOR()";
            const SELECTOR: [u8; 4] = [54u8, 254u8, 241u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_INTEREST_RATE_STRATEGY()` and selector `0x6714ddd5`.
```solidity
function DEFAULT_INTEREST_RATE_STRATEGY() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_INTEREST_RATE_STRATEGYCall {}
    ///Container type for the return parameters of the [`DEFAULT_INTEREST_RATE_STRATEGY()`](DEFAULT_INTEREST_RATE_STRATEGYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_INTEREST_RATE_STRATEGYReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_INTEREST_RATE_STRATEGYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_INTEREST_RATE_STRATEGYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_INTEREST_RATE_STRATEGYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_INTEREST_RATE_STRATEGYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_INTEREST_RATE_STRATEGYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_INTEREST_RATE_STRATEGYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_INTEREST_RATE_STRATEGYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_INTEREST_RATE_STRATEGYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_INTEREST_RATE_STRATEGY()";
            const SELECTOR: [u8; 4] = [103u8, 20u8, 221u8, 213u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_POOL_CONFIGURATION()` and selector `0x993f5450`.
```solidity
function DEFAULT_POOL_CONFIGURATION() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_POOL_CONFIGURATIONCall {}
    ///Container type for the return parameters of the [`DEFAULT_POOL_CONFIGURATION()`](DEFAULT_POOL_CONFIGURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_POOL_CONFIGURATIONReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_POOL_CONFIGURATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_POOL_CONFIGURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_POOL_CONFIGURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_POOL_CONFIGURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_POOL_CONFIGURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_POOL_CONFIGURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_POOL_CONFIGURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_POOL_CONFIGURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_POOL_CONFIGURATION()";
            const SELECTOR: [u8; 4] = [153u8, 63u8, 84u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `LIQUIDATION_FEE()` and selector `0xb1827330`.
```solidity
function LIQUIDATION_FEE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LIQUIDATION_FEECall {}
    ///Container type for the return parameters of the [`LIQUIDATION_FEE()`](LIQUIDATION_FEECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LIQUIDATION_FEEReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LIQUIDATION_FEECall> for UnderlyingRustTuple<'_> {
                fn from(value: LIQUIDATION_FEECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for LIQUIDATION_FEECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LIQUIDATION_FEEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LIQUIDATION_FEEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LIQUIDATION_FEEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LIQUIDATION_FEECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = LIQUIDATION_FEEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LIQUIDATION_FEE()";
            const SELECTOR: [u8; 4] = [177u8, 130u8, 115u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MARGIN_LEVELL_THRESHOLD()` and selector `0xcea63f5d`.
```solidity
function MARGIN_LEVELL_THRESHOLD() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MARGIN_LEVELL_THRESHOLDCall {}
    ///Container type for the return parameters of the [`MARGIN_LEVELL_THRESHOLD()`](MARGIN_LEVELL_THRESHOLDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MARGIN_LEVELL_THRESHOLDReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MARGIN_LEVELL_THRESHOLDCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MARGIN_LEVELL_THRESHOLDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MARGIN_LEVELL_THRESHOLDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MARGIN_LEVELL_THRESHOLDReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MARGIN_LEVELL_THRESHOLDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MARGIN_LEVELL_THRESHOLDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MARGIN_LEVELL_THRESHOLDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MARGIN_LEVELL_THRESHOLDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MARGIN_LEVELL_THRESHOLD()";
            const SELECTOR: [u8; 4] = [206u8, 166u8, 63u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MAX_BORROW_RATE()` and selector `0x7a0c5ebf`.
```solidity
function MAX_BORROW_RATE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_BORROW_RATECall {}
    ///Container type for the return parameters of the [`MAX_BORROW_RATE()`](MAX_BORROW_RATECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_BORROW_RATEReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_BORROW_RATECall> for UnderlyingRustTuple<'_> {
                fn from(value: MAX_BORROW_RATECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAX_BORROW_RATECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_BORROW_RATEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MAX_BORROW_RATEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MAX_BORROW_RATEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MAX_BORROW_RATECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MAX_BORROW_RATEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MAX_BORROW_RATE()";
            const SELECTOR: [u8; 4] = [122u8, 12u8, 94u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MAX_DEPOSIT_RATE()` and selector `0x3fe6e190`.
```solidity
function MAX_DEPOSIT_RATE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_DEPOSIT_RATECall {}
    ///Container type for the return parameters of the [`MAX_DEPOSIT_RATE()`](MAX_DEPOSIT_RATECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_DEPOSIT_RATEReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_DEPOSIT_RATECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MAX_DEPOSIT_RATECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MAX_DEPOSIT_RATECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_DEPOSIT_RATEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MAX_DEPOSIT_RATEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MAX_DEPOSIT_RATEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MAX_DEPOSIT_RATECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MAX_DEPOSIT_RATEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MAX_DEPOSIT_RATE()";
            const SELECTOR: [u8; 4] = [63u8, 230u8, 225u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL()` and selector `0x7535d246`.
```solidity
function POOL() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOLCall {}
    ///Container type for the return parameters of the [`POOL()`](POOLCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOLReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOLCall> for UnderlyingRustTuple<'_> {
                fn from(value: POOLCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOLCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOLReturn> for UnderlyingRustTuple<'_> {
                fn from(value: POOLReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOLReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOLCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOLReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL()";
            const SELECTOR: [u8; 4] = [117u8, 53u8, 210u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_LIST()` and selector `0x35bf7457`.
```solidity
function POOL_LIST() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_LISTCall {}
    ///Container type for the return parameters of the [`POOL_LIST()`](POOL_LISTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_LISTReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_LISTCall> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_LISTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_LISTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_LISTReturn> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_LISTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_LISTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_LISTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_LISTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_LIST()";
            const SELECTOR: [u8; 4] = [53u8, 191u8, 116u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POSITION()` and selector `0x355ac596`.
```solidity
function POSITION() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POSITIONCall {}
    ///Container type for the return parameters of the [`POSITION()`](POSITIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POSITIONReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POSITIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: POSITIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POSITIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POSITIONReturn> for UnderlyingRustTuple<'_> {
                fn from(value: POSITIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POSITIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POSITIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POSITIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POSITION()";
            const SELECTOR: [u8; 4] = [53u8, 90u8, 197u8, 150u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POSITION_LIST()` and selector `0xb8b4a543`.
```solidity
function POSITION_LIST() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POSITION_LISTCall {}
    ///Container type for the return parameters of the [`POSITION_LIST()`](POSITION_LISTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POSITION_LISTReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POSITION_LISTCall> for UnderlyingRustTuple<'_> {
                fn from(value: POSITION_LISTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POSITION_LISTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POSITION_LISTReturn> for UnderlyingRustTuple<'_> {
                fn from(value: POSITION_LISTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POSITION_LISTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POSITION_LISTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POSITION_LISTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POSITION_LIST()";
            const SELECTOR: [u8; 4] = [184u8, 180u8, 165u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `REENTRANCY_GUARD_STATUS()` and selector `0x9bfe0ccf`.
```solidity
function REENTRANCY_GUARD_STATUS() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REENTRANCY_GUARD_STATUSCall {}
    ///Container type for the return parameters of the [`REENTRANCY_GUARD_STATUS()`](REENTRANCY_GUARD_STATUSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct REENTRANCY_GUARD_STATUSReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REENTRANCY_GUARD_STATUSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: REENTRANCY_GUARD_STATUSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for REENTRANCY_GUARD_STATUSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<REENTRANCY_GUARD_STATUSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: REENTRANCY_GUARD_STATUSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for REENTRANCY_GUARD_STATUSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for REENTRANCY_GUARD_STATUSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = REENTRANCY_GUARD_STATUSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "REENTRANCY_GUARD_STATUS()";
            const SELECTOR: [u8; 4] = [155u8, 254u8, 12u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SHORT_LIQUIDITY_THRESHOLD()` and selector `0x2ccfe1eb`.
```solidity
function SHORT_LIQUIDITY_THRESHOLD() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SHORT_LIQUIDITY_THRESHOLDCall {}
    ///Container type for the return parameters of the [`SHORT_LIQUIDITY_THRESHOLD()`](SHORT_LIQUIDITY_THRESHOLDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SHORT_LIQUIDITY_THRESHOLDReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SHORT_LIQUIDITY_THRESHOLDCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SHORT_LIQUIDITY_THRESHOLDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SHORT_LIQUIDITY_THRESHOLDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SHORT_LIQUIDITY_THRESHOLDReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SHORT_LIQUIDITY_THRESHOLDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SHORT_LIQUIDITY_THRESHOLDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SHORT_LIQUIDITY_THRESHOLDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SHORT_LIQUIDITY_THRESHOLDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SHORT_LIQUIDITY_THRESHOLD()";
            const SELECTOR: [u8; 4] = [44u8, 207u8, 225u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOKEN_BASE()` and selector `0x769af85d`.
```solidity
function TOKEN_BASE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOKEN_BASECall {}
    ///Container type for the return parameters of the [`TOKEN_BASE()`](TOKEN_BASECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOKEN_BASEReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOKEN_BASECall> for UnderlyingRustTuple<'_> {
                fn from(value: TOKEN_BASECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOKEN_BASECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOKEN_BASEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOKEN_BASEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOKEN_BASEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOKEN_BASECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOKEN_BASEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOKEN_BASE()";
            const SELECTOR: [u8; 4] = [118u8, 154u8, 248u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TRADABLE_DEBT_MULTIPIER_FACTOR()` and selector `0x3d49adda`.
```solidity
function TRADABLE_DEBT_MULTIPIER_FACTOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TRADABLE_DEBT_MULTIPIER_FACTORCall {}
    ///Container type for the return parameters of the [`TRADABLE_DEBT_MULTIPIER_FACTOR()`](TRADABLE_DEBT_MULTIPIER_FACTORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TRADABLE_DEBT_MULTIPIER_FACTORReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TRADABLE_DEBT_MULTIPIER_FACTORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: TRADABLE_DEBT_MULTIPIER_FACTORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for TRADABLE_DEBT_MULTIPIER_FACTORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TRADABLE_DEBT_MULTIPIER_FACTORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: TRADABLE_DEBT_MULTIPIER_FACTORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for TRADABLE_DEBT_MULTIPIER_FACTORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TRADABLE_DEBT_MULTIPIER_FACTORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TRADABLE_DEBT_MULTIPIER_FACTORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TRADABLE_DEBT_MULTIPIER_FACTOR()";
            const SELECTOR: [u8; 4] = [61u8, 73u8, 173u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TREASURY()` and selector `0x2d2c5565`.
```solidity
function TREASURY() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TREASURYCall {}
    ///Container type for the return parameters of the [`TREASURY()`](TREASURYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TREASURYReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TREASURYCall> for UnderlyingRustTuple<'_> {
                fn from(value: TREASURYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TREASURYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TREASURYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TREASURYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TREASURYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TREASURYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TREASURYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TREASURY()";
            const SELECTOR: [u8; 4] = [45u8, 44u8, 85u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `WNT()` and selector `0x7bf43e47`.
```solidity
function WNT() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WNTCall {}
    ///Container type for the return parameters of the [`WNT()`](WNTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WNTReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<WNTCall> for UnderlyingRustTuple<'_> {
                fn from(value: WNTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for WNTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<WNTReturn> for UnderlyingRustTuple<'_> {
                fn from(value: WNTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for WNTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for WNTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = WNTReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WNT()";
            const SELECTOR: [u8; 4] = [123u8, 244u8, 62u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`Keys`](self) function calls.
    pub enum KeysCalls {
        ACCOUNT_POSITION_LIST(ACCOUNT_POSITION_LISTCall),
        DEBT_SAFETY_FACTOR(DEBT_SAFETY_FACTORCall),
        DEFAULT_INTEREST_RATE_STRATEGY(DEFAULT_INTEREST_RATE_STRATEGYCall),
        DEFAULT_POOL_CONFIGURATION(DEFAULT_POOL_CONFIGURATIONCall),
        LIQUIDATION_FEE(LIQUIDATION_FEECall),
        MARGIN_LEVELL_THRESHOLD(MARGIN_LEVELL_THRESHOLDCall),
        MAX_BORROW_RATE(MAX_BORROW_RATECall),
        MAX_DEPOSIT_RATE(MAX_DEPOSIT_RATECall),
        POOL(POOLCall),
        POOL_LIST(POOL_LISTCall),
        POSITION(POSITIONCall),
        POSITION_LIST(POSITION_LISTCall),
        REENTRANCY_GUARD_STATUS(REENTRANCY_GUARD_STATUSCall),
        SHORT_LIQUIDITY_THRESHOLD(SHORT_LIQUIDITY_THRESHOLDCall),
        TOKEN_BASE(TOKEN_BASECall),
        TRADABLE_DEBT_MULTIPIER_FACTOR(TRADABLE_DEBT_MULTIPIER_FACTORCall),
        TREASURY(TREASURYCall),
        WNT(WNTCall),
    }
    #[automatically_derived]
    impl KeysCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 20u8, 41u8, 184u8],
            [44u8, 207u8, 225u8, 235u8],
            [45u8, 44u8, 85u8, 101u8],
            [53u8, 90u8, 197u8, 150u8],
            [53u8, 191u8, 116u8, 87u8],
            [54u8, 254u8, 241u8, 61u8],
            [61u8, 73u8, 173u8, 218u8],
            [63u8, 230u8, 225u8, 144u8],
            [103u8, 20u8, 221u8, 213u8],
            [117u8, 53u8, 210u8, 70u8],
            [118u8, 154u8, 248u8, 93u8],
            [122u8, 12u8, 94u8, 191u8],
            [123u8, 244u8, 62u8, 71u8],
            [153u8, 63u8, 84u8, 80u8],
            [155u8, 254u8, 12u8, 207u8],
            [177u8, 130u8, 115u8, 48u8],
            [184u8, 180u8, 165u8, 67u8],
            [206u8, 166u8, 63u8, 93u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for KeysCalls {
        const NAME: &'static str = "KeysCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 18usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ACCOUNT_POSITION_LIST(_) => {
                    <ACCOUNT_POSITION_LISTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEBT_SAFETY_FACTOR(_) => {
                    <DEBT_SAFETY_FACTORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_INTEREST_RATE_STRATEGY(_) => {
                    <DEFAULT_INTEREST_RATE_STRATEGYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_POOL_CONFIGURATION(_) => {
                    <DEFAULT_POOL_CONFIGURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LIQUIDATION_FEE(_) => {
                    <LIQUIDATION_FEECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MARGIN_LEVELL_THRESHOLD(_) => {
                    <MARGIN_LEVELL_THRESHOLDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MAX_BORROW_RATE(_) => {
                    <MAX_BORROW_RATECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MAX_DEPOSIT_RATE(_) => {
                    <MAX_DEPOSIT_RATECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL(_) => <POOLCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::POOL_LIST(_) => {
                    <POOL_LISTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POSITION(_) => <POSITIONCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::POSITION_LIST(_) => {
                    <POSITION_LISTCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::REENTRANCY_GUARD_STATUS(_) => {
                    <REENTRANCY_GUARD_STATUSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SHORT_LIQUIDITY_THRESHOLD(_) => {
                    <SHORT_LIQUIDITY_THRESHOLDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOKEN_BASE(_) => {
                    <TOKEN_BASECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TRADABLE_DEBT_MULTIPIER_FACTOR(_) => {
                    <TRADABLE_DEBT_MULTIPIER_FACTORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TREASURY(_) => <TREASURYCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::WNT(_) => <WNTCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<KeysCalls>] = &[
                {
                    fn ACCOUNT_POSITION_LIST(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <ACCOUNT_POSITION_LISTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::ACCOUNT_POSITION_LIST)
                    }
                    ACCOUNT_POSITION_LIST
                },
                {
                    fn SHORT_LIQUIDITY_THRESHOLD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <SHORT_LIQUIDITY_THRESHOLDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::SHORT_LIQUIDITY_THRESHOLD)
                    }
                    SHORT_LIQUIDITY_THRESHOLD
                },
                {
                    fn TREASURY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <TREASURYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::TREASURY)
                    }
                    TREASURY
                },
                {
                    fn POSITION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <POSITIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::POSITION)
                    }
                    POSITION
                },
                {
                    fn POOL_LIST(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <POOL_LISTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::POOL_LIST)
                    }
                    POOL_LIST
                },
                {
                    fn DEBT_SAFETY_FACTOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <DEBT_SAFETY_FACTORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::DEBT_SAFETY_FACTOR)
                    }
                    DEBT_SAFETY_FACTOR
                },
                {
                    fn TRADABLE_DEBT_MULTIPIER_FACTOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <TRADABLE_DEBT_MULTIPIER_FACTORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::TRADABLE_DEBT_MULTIPIER_FACTOR)
                    }
                    TRADABLE_DEBT_MULTIPIER_FACTOR
                },
                {
                    fn MAX_DEPOSIT_RATE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <MAX_DEPOSIT_RATECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::MAX_DEPOSIT_RATE)
                    }
                    MAX_DEPOSIT_RATE
                },
                {
                    fn DEFAULT_INTEREST_RATE_STRATEGY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <DEFAULT_INTEREST_RATE_STRATEGYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::DEFAULT_INTEREST_RATE_STRATEGY)
                    }
                    DEFAULT_INTEREST_RATE_STRATEGY
                },
                {
                    fn POOL(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <POOLCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::POOL)
                    }
                    POOL
                },
                {
                    fn TOKEN_BASE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <TOKEN_BASECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::TOKEN_BASE)
                    }
                    TOKEN_BASE
                },
                {
                    fn MAX_BORROW_RATE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <MAX_BORROW_RATECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::MAX_BORROW_RATE)
                    }
                    MAX_BORROW_RATE
                },
                {
                    fn WNT(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <WNTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::WNT)
                    }
                    WNT
                },
                {
                    fn DEFAULT_POOL_CONFIGURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <DEFAULT_POOL_CONFIGURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::DEFAULT_POOL_CONFIGURATION)
                    }
                    DEFAULT_POOL_CONFIGURATION
                },
                {
                    fn REENTRANCY_GUARD_STATUS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <REENTRANCY_GUARD_STATUSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::REENTRANCY_GUARD_STATUS)
                    }
                    REENTRANCY_GUARD_STATUS
                },
                {
                    fn LIQUIDATION_FEE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <LIQUIDATION_FEECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::LIQUIDATION_FEE)
                    }
                    LIQUIDATION_FEE
                },
                {
                    fn POSITION_LIST(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <POSITION_LISTCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::POSITION_LIST)
                    }
                    POSITION_LIST
                },
                {
                    fn MARGIN_LEVELL_THRESHOLD(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<KeysCalls> {
                        <MARGIN_LEVELL_THRESHOLDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(KeysCalls::MARGIN_LEVELL_THRESHOLD)
                    }
                    MARGIN_LEVELL_THRESHOLD
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ACCOUNT_POSITION_LIST(inner) => {
                    <ACCOUNT_POSITION_LISTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEBT_SAFETY_FACTOR(inner) => {
                    <DEBT_SAFETY_FACTORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_INTEREST_RATE_STRATEGY(inner) => {
                    <DEFAULT_INTEREST_RATE_STRATEGYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_POOL_CONFIGURATION(inner) => {
                    <DEFAULT_POOL_CONFIGURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LIQUIDATION_FEE(inner) => {
                    <LIQUIDATION_FEECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MARGIN_LEVELL_THRESHOLD(inner) => {
                    <MARGIN_LEVELL_THRESHOLDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MAX_BORROW_RATE(inner) => {
                    <MAX_BORROW_RATECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MAX_DEPOSIT_RATE(inner) => {
                    <MAX_DEPOSIT_RATECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL(inner) => {
                    <POOLCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::POOL_LIST(inner) => {
                    <POOL_LISTCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::POSITION(inner) => {
                    <POSITIONCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::POSITION_LIST(inner) => {
                    <POSITION_LISTCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::REENTRANCY_GUARD_STATUS(inner) => {
                    <REENTRANCY_GUARD_STATUSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SHORT_LIQUIDITY_THRESHOLD(inner) => {
                    <SHORT_LIQUIDITY_THRESHOLDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOKEN_BASE(inner) => {
                    <TOKEN_BASECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::TRADABLE_DEBT_MULTIPIER_FACTOR(inner) => {
                    <TRADABLE_DEBT_MULTIPIER_FACTORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TREASURY(inner) => {
                    <TREASURYCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::WNT(inner) => {
                    <WNTCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ACCOUNT_POSITION_LIST(inner) => {
                    <ACCOUNT_POSITION_LISTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEBT_SAFETY_FACTOR(inner) => {
                    <DEBT_SAFETY_FACTORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_INTEREST_RATE_STRATEGY(inner) => {
                    <DEFAULT_INTEREST_RATE_STRATEGYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_POOL_CONFIGURATION(inner) => {
                    <DEFAULT_POOL_CONFIGURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LIQUIDATION_FEE(inner) => {
                    <LIQUIDATION_FEECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MARGIN_LEVELL_THRESHOLD(inner) => {
                    <MARGIN_LEVELL_THRESHOLDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MAX_BORROW_RATE(inner) => {
                    <MAX_BORROW_RATECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MAX_DEPOSIT_RATE(inner) => {
                    <MAX_DEPOSIT_RATECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL(inner) => {
                    <POOLCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::POOL_LIST(inner) => {
                    <POOL_LISTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POSITION(inner) => {
                    <POSITIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POSITION_LIST(inner) => {
                    <POSITION_LISTCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::REENTRANCY_GUARD_STATUS(inner) => {
                    <REENTRANCY_GUARD_STATUSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SHORT_LIQUIDITY_THRESHOLD(inner) => {
                    <SHORT_LIQUIDITY_THRESHOLDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOKEN_BASE(inner) => {
                    <TOKEN_BASECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TRADABLE_DEBT_MULTIPIER_FACTOR(inner) => {
                    <TRADABLE_DEBT_MULTIPIER_FACTORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TREASURY(inner) => {
                    <TREASURYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WNT(inner) => {
                    <WNTCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Keys`](self) contract instance.

See the [wrapper's documentation](`KeysInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(address: alloy_sol_types::private::Address, provider: P) -> KeysInstance<T, P, N> {
        KeysInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<KeysInstance<T, P, N>>,
    > {
        KeysInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        KeysInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`Keys`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Keys`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct KeysInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for KeysInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("KeysInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KeysInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Keys`](self) contract instance.

See the [wrapper's documentation](`KeysInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<KeysInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> KeysInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> KeysInstance<T, P, N> {
            KeysInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KeysInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`ACCOUNT_POSITION_LIST`] function.
        pub fn ACCOUNT_POSITION_LIST(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ACCOUNT_POSITION_LISTCall, N> {
            self.call_builder(&ACCOUNT_POSITION_LISTCall {})
        }
        ///Creates a new call builder for the [`DEBT_SAFETY_FACTOR`] function.
        pub fn DEBT_SAFETY_FACTOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEBT_SAFETY_FACTORCall, N> {
            self.call_builder(&DEBT_SAFETY_FACTORCall {})
        }
        ///Creates a new call builder for the [`DEFAULT_INTEREST_RATE_STRATEGY`] function.
        pub fn DEFAULT_INTEREST_RATE_STRATEGY(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            DEFAULT_INTEREST_RATE_STRATEGYCall,
            N,
        > {
            self.call_builder(
                &DEFAULT_INTEREST_RATE_STRATEGYCall {
                },
            )
        }
        ///Creates a new call builder for the [`DEFAULT_POOL_CONFIGURATION`] function.
        pub fn DEFAULT_POOL_CONFIGURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_POOL_CONFIGURATIONCall, N> {
            self.call_builder(&DEFAULT_POOL_CONFIGURATIONCall {})
        }
        ///Creates a new call builder for the [`LIQUIDATION_FEE`] function.
        pub fn LIQUIDATION_FEE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, LIQUIDATION_FEECall, N> {
            self.call_builder(&LIQUIDATION_FEECall {})
        }
        ///Creates a new call builder for the [`MARGIN_LEVELL_THRESHOLD`] function.
        pub fn MARGIN_LEVELL_THRESHOLD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MARGIN_LEVELL_THRESHOLDCall, N> {
            self.call_builder(&MARGIN_LEVELL_THRESHOLDCall {})
        }
        ///Creates a new call builder for the [`MAX_BORROW_RATE`] function.
        pub fn MAX_BORROW_RATE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MAX_BORROW_RATECall, N> {
            self.call_builder(&MAX_BORROW_RATECall {})
        }
        ///Creates a new call builder for the [`MAX_DEPOSIT_RATE`] function.
        pub fn MAX_DEPOSIT_RATE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MAX_DEPOSIT_RATECall, N> {
            self.call_builder(&MAX_DEPOSIT_RATECall {})
        }
        ///Creates a new call builder for the [`POOL`] function.
        pub fn POOL(&self) -> alloy_contract::SolCallBuilder<T, &P, POOLCall, N> {
            self.call_builder(&POOLCall {})
        }
        ///Creates a new call builder for the [`POOL_LIST`] function.
        pub fn POOL_LIST(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_LISTCall, N> {
            self.call_builder(&POOL_LISTCall {})
        }
        ///Creates a new call builder for the [`POSITION`] function.
        pub fn POSITION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POSITIONCall, N> {
            self.call_builder(&POSITIONCall {})
        }
        ///Creates a new call builder for the [`POSITION_LIST`] function.
        pub fn POSITION_LIST(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POSITION_LISTCall, N> {
            self.call_builder(&POSITION_LISTCall {})
        }
        ///Creates a new call builder for the [`REENTRANCY_GUARD_STATUS`] function.
        pub fn REENTRANCY_GUARD_STATUS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, REENTRANCY_GUARD_STATUSCall, N> {
            self.call_builder(&REENTRANCY_GUARD_STATUSCall {})
        }
        ///Creates a new call builder for the [`SHORT_LIQUIDITY_THRESHOLD`] function.
        pub fn SHORT_LIQUIDITY_THRESHOLD(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SHORT_LIQUIDITY_THRESHOLDCall, N> {
            self.call_builder(&SHORT_LIQUIDITY_THRESHOLDCall {})
        }
        ///Creates a new call builder for the [`TOKEN_BASE`] function.
        pub fn TOKEN_BASE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOKEN_BASECall, N> {
            self.call_builder(&TOKEN_BASECall {})
        }
        ///Creates a new call builder for the [`TRADABLE_DEBT_MULTIPIER_FACTOR`] function.
        pub fn TRADABLE_DEBT_MULTIPIER_FACTOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            TRADABLE_DEBT_MULTIPIER_FACTORCall,
            N,
        > {
            self.call_builder(
                &TRADABLE_DEBT_MULTIPIER_FACTORCall {
                },
            )
        }
        ///Creates a new call builder for the [`TREASURY`] function.
        pub fn TREASURY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TREASURYCall, N> {
            self.call_builder(&TREASURYCall {})
        }
        ///Creates a new call builder for the [`WNT`] function.
        pub fn WNT(&self) -> alloy_contract::SolCallBuilder<T, &P, WNTCall, N> {
            self.call_builder(&WNTCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > KeysInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
