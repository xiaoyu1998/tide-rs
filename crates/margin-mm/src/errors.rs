/**

Generated by the following Solidity interface...
```solidity
interface Errors {
    error AccountNotMatch(address accountInPosition, address account);
    error Balance1Insufficient(uint256 amount1, uint256 balance1);
    error ClosePercentageExceeding();
    error CollateralCanNotCoverDebt(uint256 collateralAmount, uint256 debtAmount);
    error CompactedArrayOutOfBounds(uint256[] compactedValues, uint256 index, uint256 slotIndex, string label);
    error CouldNotSendNativeToken(address receiver, uint256 amount);
    error DebtTokenOperationNotSupported();
    error EmptyAccount();
    error EmptyAddAmounts();
    error EmptyAmount();
    error EmptyBase();
    error EmptyBorrowAmounts();
    error EmptyBurnAmounts();
    error EmptyCollateral();
    error EmptyConfiguration();
    error EmptyDepositAmounts();
    error EmptyHoldingAddress();
    error EmptyInterestRateStrategy();
    error EmptyMintAmounts();
    error EmptyPool(bytes32 key);
    error EmptyPoolKeys();
    error EmptyPosition();
    error EmptyPositions(address account);
    error EmptyReceiver();
    error EmptyRemoveAmounts();
    error EmptyRepayAmounts();
    error EmptySwapInAmount();
    error EmptySwapOutAmount();
    error EmptyTokenBase();
    error EmptyTokenTranferGasLimit(address token);
    error EmptyTreasury();
    error EmptyUnclaimedFee(bytes32 pool);
    error EmptyWithdrawAmounts();
    error ErrorStep(address account, uint256 step);
    error InsufficientAvailableLiquidity(uint256 amount, uint256 availableLiquidity);
    error InsufficientCollateralAmount(uint256 amountToRemove, uint256 amountBalance);
    error InsufficientCollateralAmountForRepay(uint256 repayAmount, uint256 collateralAmount);
    error InsufficientCollateralForWidthdraw(uint256 amountToWithdraw, uint256 collateral);
    error InsufficientReverveForBorrow(uint256 amountToBorrow, uint256 availableReserve);
    error InsufficientSwapAmount(uint256 lastVirtualLiquidity0, uint256 lastVirtualLiquidity1, uint256 adjustedVirtualLiquidity0, uint256 adjustedVirtualLiquidity1);
    error InsufficientSwapCollateral(uint256 amountIn, uint256 collateral);
    error InsufficientUserBalance(uint256 balance, uint256 liquidity);
    error InvalidBorrowCapacity(uint256 borrowCapacity, uint256 MaxValidBorrowCapacity);
    error InvalidDecimals(uint256 decimals, uint256 MaxValidDecimals);
    error InvalidFeeFactor(uint256 feeFactor, uint256 MaxValidFeeFactor);
    error InvalidNativeTokenSender(address msgSender);
    error InvalidOptimalUsageRate(uint256 optimalUsageRatio);
    error InvalidPoolIndex(uint256 poolKeyId);
    error InvalidSupplyCapacity(uint256 supplyCapacity, uint256 MaxValidSupplyCapacity);
    error MarginAboveThreshold(uint256 marginLevel, uint256 marginLevelThreshold);
    error MarginBelowThreshold(uint256 marginLevel, uint256 marginLevelThreshold);
    error MaxDepositExceeds(uint256 maxDepositAmount, uint256 amountToDeposit);
    error MaxPositionId();
    error PoolAlreadyExists(bytes32 key, address poolBank);
    error PositionNotFound(bytes32 key);
    error RequestedAmount1ExceedsPriceLimit(uint256 amount1Out, uint256 amount1OutMax);
    error RequestedAmountOExceedsPriceLimit(uint256 amount0Out, uint256 amount0OutMax);
    error Reserve0Insufficient(uint256 amount0, uint256 availableReserve0);
    error Reserve1Insufficient(uint256 amount1, uint256 availableReserve1);
    error SelfTransferNotSupported(address receiver);
    error SingleTokenInOutSwapOnly();
    error ThereMustBeAtLeastOneRoleAdmin();
    error ThereMustBeAtLeastOneTimelockMultiSig();
    error TokenIndexNotSupport();
    error TokenTransferError(address token, address receiver, uint256 amount);
    error TokensNotMatch();
    error Unauthorized(address msgSender, string role);
    error UsdCollateralCanNotCoverDebt(uint256 usdCollateralAmount, uint256 usdCollateralAmountNeeded, uint256 debtAmount, address underlyingAsset);
    error UserDoNotHaveDebtInPosition(address account, bytes32 positionKey);
    error liquidityDidNotReachShortThreshord(uint256 threshold, uint256 basePriceReserve);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "error",
    "name": "AccountNotMatch",
    "inputs": [
      {
        "name": "accountInPosition",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "Balance1Insufficient",
    "inputs": [
      {
        "name": "amount1",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "balance1",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ClosePercentageExceeding",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CollateralCanNotCoverDebt",
    "inputs": [
      {
        "name": "collateralAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "debtAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "CompactedArrayOutOfBounds",
    "inputs": [
      {
        "name": "compactedValues",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "slotIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "label",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "CouldNotSendNativeToken",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "DebtTokenOperationNotSupported",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyAccount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyAddAmounts",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyBase",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyBorrowAmounts",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyBurnAmounts",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyCollateral",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyConfiguration",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyDepositAmounts",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyHoldingAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyInterestRateStrategy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyMintAmounts",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyPool",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EmptyPoolKeys",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyPosition",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyPositions",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "EmptyReceiver",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyRemoveAmounts",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyRepayAmounts",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptySwapInAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptySwapOutAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyTokenBase",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyTokenTranferGasLimit",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "EmptyTreasury",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyUnclaimedFee",
    "inputs": [
      {
        "name": "pool",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "EmptyWithdrawAmounts",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ErrorStep",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "step",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientAvailableLiquidity",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "availableLiquidity",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientCollateralAmount",
    "inputs": [
      {
        "name": "amountToRemove",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amountBalance",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientCollateralAmountForRepay",
    "inputs": [
      {
        "name": "repayAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "collateralAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientCollateralForWidthdraw",
    "inputs": [
      {
        "name": "amountToWithdraw",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "collateral",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientReverveForBorrow",
    "inputs": [
      {
        "name": "amountToBorrow",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "availableReserve",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientSwapAmount",
    "inputs": [
      {
        "name": "lastVirtualLiquidity0",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "lastVirtualLiquidity1",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "adjustedVirtualLiquidity0",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "adjustedVirtualLiquidity1",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientSwapCollateral",
    "inputs": [
      {
        "name": "amountIn",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "collateral",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientUserBalance",
    "inputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "liquidity",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidBorrowCapacity",
    "inputs": [
      {
        "name": "borrowCapacity",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "MaxValidBorrowCapacity",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidDecimals",
    "inputs": [
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "MaxValidDecimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidFeeFactor",
    "inputs": [
      {
        "name": "feeFactor",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "MaxValidFeeFactor",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidNativeTokenSender",
    "inputs": [
      {
        "name": "msgSender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidOptimalUsageRate",
    "inputs": [
      {
        "name": "optimalUsageRatio",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidPoolIndex",
    "inputs": [
      {
        "name": "poolKeyId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidSupplyCapacity",
    "inputs": [
      {
        "name": "supplyCapacity",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "MaxValidSupplyCapacity",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "MarginAboveThreshold",
    "inputs": [
      {
        "name": "marginLevel",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "marginLevelThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "MarginBelowThreshold",
    "inputs": [
      {
        "name": "marginLevel",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "marginLevelThreshold",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "MaxDepositExceeds",
    "inputs": [
      {
        "name": "maxDepositAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amountToDeposit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "MaxPositionId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PoolAlreadyExists",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "poolBank",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "PositionNotFound",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "RequestedAmount1ExceedsPriceLimit",
    "inputs": [
      {
        "name": "amount1Out",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount1OutMax",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "RequestedAmountOExceedsPriceLimit",
    "inputs": [
      {
        "name": "amount0Out",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount0OutMax",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "Reserve0Insufficient",
    "inputs": [
      {
        "name": "amount0",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "availableReserve0",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "Reserve1Insufficient",
    "inputs": [
      {
        "name": "amount1",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "availableReserve1",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "SelfTransferNotSupported",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "SingleTokenInOutSwapOnly",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ThereMustBeAtLeastOneRoleAdmin",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ThereMustBeAtLeastOneTimelockMultiSig",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TokenIndexNotSupport",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TokenTransferError",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "TokensNotMatch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Unauthorized",
    "inputs": [
      {
        "name": "msgSender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "role",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "UsdCollateralCanNotCoverDebt",
    "inputs": [
      {
        "name": "usdCollateralAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "usdCollateralAmountNeeded",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "debtAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "underlyingAsset",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "UserDoNotHaveDebtInPosition",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "positionKey",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "liquidityDidNotReachShortThreshord",
    "inputs": [
      {
        "name": "threshold",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "basePriceReserve",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod Errors {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f5ffdfea2646970667358221220253b0377015c945866847a266ef4f0012c0612d8e47ff2f5863d6536c1d1b36e64736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`U`2`\x0B\x82\x82\x829\x80Q_\x1A`s\x14`&WcNH{q`\xE0\x1B_R_`\x04R`$_\xFD[0_R`s\x81S\x82\x81\xF3\xFEs\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R__\xFD\xFE\xA2dipfsX\"\x12 %;\x03w\x01\\\x94Xf\x84z&n\xF4\xF0\x01,\x06\x12\xD8\xE4\x7F\xF2\xF5\x86=e6\xC1\xD1\xB3ndsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x730000000000000000000000000000000000000000301460806040525f5ffdfea2646970667358221220253b0377015c945866847a266ef4f0012c0612d8e47ff2f5863d6536c1d1b36e64736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"s\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R__\xFD\xFE\xA2dipfsX\"\x12 %;\x03w\x01\\\x94Xf\x84z&n\xF4\xF0\x01,\x06\x12\xD8\xE4\x7F\xF2\xF5\x86=e6\xC1\xD1\xB3ndsolcC\0\x08\x1C\x003",
    );
    /**Custom error with signature `AccountNotMatch(address,address)` and selector `0x25c7157e`.
```solidity
error AccountNotMatch(address accountInPosition, address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccountNotMatch {
        pub accountInPosition: alloy::sol_types::private::Address,
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccountNotMatch> for UnderlyingRustTuple<'_> {
            fn from(value: AccountNotMatch) -> Self {
                (value.accountInPosition, value.account)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AccountNotMatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    accountInPosition: tuple.0,
                    account: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccountNotMatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccountNotMatch(address,address)";
            const SELECTOR: [u8; 4] = [37u8, 199u8, 21u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.accountInPosition,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `Balance1Insufficient(uint256,uint256)` and selector `0x26211929`.
```solidity
error Balance1Insufficient(uint256 amount1, uint256 balance1);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Balance1Insufficient {
        pub amount1: alloy::sol_types::private::primitives::aliases::U256,
        pub balance1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Balance1Insufficient> for UnderlyingRustTuple<'_> {
            fn from(value: Balance1Insufficient) -> Self {
                (value.amount1, value.balance1)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Balance1Insufficient {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amount1: tuple.0,
                    balance1: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Balance1Insufficient {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Balance1Insufficient(uint256,uint256)";
            const SELECTOR: [u8; 4] = [38u8, 33u8, 25u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount1),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance1),
                )
            }
        }
    };
    /**Custom error with signature `ClosePercentageExceeding()` and selector `0x553af544`.
```solidity
error ClosePercentageExceeding();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClosePercentageExceeding {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ClosePercentageExceeding>
        for UnderlyingRustTuple<'_> {
            fn from(value: ClosePercentageExceeding) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ClosePercentageExceeding {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ClosePercentageExceeding {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ClosePercentageExceeding()";
            const SELECTOR: [u8; 4] = [85u8, 58u8, 245u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CollateralCanNotCoverDebt(uint256,uint256)` and selector `0xac3fb11d`.
```solidity
error CollateralCanNotCoverDebt(uint256 collateralAmount, uint256 debtAmount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CollateralCanNotCoverDebt {
        pub collateralAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub debtAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CollateralCanNotCoverDebt>
        for UnderlyingRustTuple<'_> {
            fn from(value: CollateralCanNotCoverDebt) -> Self {
                (value.collateralAmount, value.debtAmount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CollateralCanNotCoverDebt {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    collateralAmount: tuple.0,
                    debtAmount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CollateralCanNotCoverDebt {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CollateralCanNotCoverDebt(uint256,uint256)";
            const SELECTOR: [u8; 4] = [172u8, 63u8, 177u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.collateralAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.debtAmount),
                )
            }
        }
    };
    /**Custom error with signature `CompactedArrayOutOfBounds(uint256[],uint256,uint256,string)` and selector `0xbdec9c0d`.
```solidity
error CompactedArrayOutOfBounds(uint256[] compactedValues, uint256 index, uint256 slotIndex, string label);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CompactedArrayOutOfBounds {
        pub compactedValues: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        pub index: alloy::sol_types::private::primitives::aliases::U256,
        pub slotIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub label: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CompactedArrayOutOfBounds>
        for UnderlyingRustTuple<'_> {
            fn from(value: CompactedArrayOutOfBounds) -> Self {
                (value.compactedValues, value.index, value.slotIndex, value.label)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CompactedArrayOutOfBounds {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    compactedValues: tuple.0,
                    index: tuple.1,
                    slotIndex: tuple.2,
                    label: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CompactedArrayOutOfBounds {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CompactedArrayOutOfBounds(uint256[],uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [189u8, 236u8, 156u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.compactedValues),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slotIndex),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.label,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `CouldNotSendNativeToken(address,uint256)` and selector `0x321c1666`.
```solidity
error CouldNotSendNativeToken(address receiver, uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CouldNotSendNativeToken {
        pub receiver: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CouldNotSendNativeToken> for UnderlyingRustTuple<'_> {
            fn from(value: CouldNotSendNativeToken) -> Self {
                (value.receiver, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CouldNotSendNativeToken {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    receiver: tuple.0,
                    amount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CouldNotSendNativeToken {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CouldNotSendNativeToken(address,uint256)";
            const SELECTOR: [u8; 4] = [50u8, 28u8, 22u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
        }
    };
    /**Custom error with signature `DebtTokenOperationNotSupported()` and selector `0xe8964514`.
```solidity
error DebtTokenOperationNotSupported();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DebtTokenOperationNotSupported {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DebtTokenOperationNotSupported>
        for UnderlyingRustTuple<'_> {
            fn from(value: DebtTokenOperationNotSupported) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for DebtTokenOperationNotSupported {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DebtTokenOperationNotSupported {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DebtTokenOperationNotSupported()";
            const SELECTOR: [u8; 4] = [232u8, 150u8, 69u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyAccount()` and selector `0xdd7016a2`.
```solidity
error EmptyAccount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyAccount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyAccount> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyAccount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyAccount()";
            const SELECTOR: [u8; 4] = [221u8, 112u8, 22u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyAddAmounts()` and selector `0x6977ca0c`.
```solidity
error EmptyAddAmounts();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyAddAmounts {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyAddAmounts> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyAddAmounts) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyAddAmounts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyAddAmounts {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyAddAmounts()";
            const SELECTOR: [u8; 4] = [105u8, 119u8, 202u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyAmount()` and selector `0x0d143458`.
```solidity
error EmptyAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyAmount> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyAmount()";
            const SELECTOR: [u8; 4] = [13u8, 20u8, 52u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyBase()` and selector `0x23449c2c`.
```solidity
error EmptyBase();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyBase {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyBase> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyBase) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyBase {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyBase {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyBase()";
            const SELECTOR: [u8; 4] = [35u8, 68u8, 156u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyBorrowAmounts()` and selector `0x79646aaf`.
```solidity
error EmptyBorrowAmounts();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyBorrowAmounts {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyBorrowAmounts> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyBorrowAmounts) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyBorrowAmounts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyBorrowAmounts {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyBorrowAmounts()";
            const SELECTOR: [u8; 4] = [121u8, 100u8, 106u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyBurnAmounts()` and selector `0xf8badfd8`.
```solidity
error EmptyBurnAmounts();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyBurnAmounts {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyBurnAmounts> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyBurnAmounts) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyBurnAmounts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyBurnAmounts {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyBurnAmounts()";
            const SELECTOR: [u8; 4] = [248u8, 186u8, 223u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyCollateral()` and selector `0x6c53056d`.
```solidity
error EmptyCollateral();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyCollateral {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyCollateral> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyCollateral) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyCollateral {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyCollateral {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyCollateral()";
            const SELECTOR: [u8; 4] = [108u8, 83u8, 5u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyConfiguration()` and selector `0x18549934`.
```solidity
error EmptyConfiguration();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyConfiguration {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyConfiguration> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyConfiguration) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyConfiguration {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyConfiguration {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyConfiguration()";
            const SELECTOR: [u8; 4] = [24u8, 84u8, 153u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyDepositAmounts()` and selector `0x01af8c24`.
```solidity
error EmptyDepositAmounts();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyDepositAmounts {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyDepositAmounts> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyDepositAmounts) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyDepositAmounts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyDepositAmounts {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyDepositAmounts()";
            const SELECTOR: [u8; 4] = [1u8, 175u8, 140u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyHoldingAddress()` and selector `0xe9b78bd4`.
```solidity
error EmptyHoldingAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyHoldingAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyHoldingAddress> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyHoldingAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyHoldingAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyHoldingAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyHoldingAddress()";
            const SELECTOR: [u8; 4] = [233u8, 183u8, 139u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyInterestRateStrategy()` and selector `0xfa84aace`.
```solidity
error EmptyInterestRateStrategy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyInterestRateStrategy {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyInterestRateStrategy>
        for UnderlyingRustTuple<'_> {
            fn from(value: EmptyInterestRateStrategy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for EmptyInterestRateStrategy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyInterestRateStrategy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyInterestRateStrategy()";
            const SELECTOR: [u8; 4] = [250u8, 132u8, 170u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyMintAmounts()` and selector `0x75cf7209`.
```solidity
error EmptyMintAmounts();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyMintAmounts {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyMintAmounts> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyMintAmounts) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyMintAmounts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyMintAmounts {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyMintAmounts()";
            const SELECTOR: [u8; 4] = [117u8, 207u8, 114u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyPool(bytes32)` and selector `0x7357d91f`.
```solidity
error EmptyPool(bytes32 key);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyPool {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyPool> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyPool) -> Self {
                (value.key,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyPool {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { key: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyPool {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyPool(bytes32)";
            const SELECTOR: [u8; 4] = [115u8, 87u8, 217u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
        }
    };
    /**Custom error with signature `EmptyPoolKeys()` and selector `0x7a439c49`.
```solidity
error EmptyPoolKeys();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyPoolKeys {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyPoolKeys> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyPoolKeys) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyPoolKeys {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyPoolKeys {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyPoolKeys()";
            const SELECTOR: [u8; 4] = [122u8, 67u8, 156u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyPosition()` and selector `0x4dfbbff3`.
```solidity
error EmptyPosition();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyPosition {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyPosition> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyPosition) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyPosition {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyPosition {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyPosition()";
            const SELECTOR: [u8; 4] = [77u8, 251u8, 191u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyPositions(address)` and selector `0x73df2cd0`.
```solidity
error EmptyPositions(address account);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyPositions {
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyPositions> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyPositions) -> Self {
                (value.account,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyPositions {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { account: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyPositions {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyPositions(address)";
            const SELECTOR: [u8; 4] = [115u8, 223u8, 44u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `EmptyReceiver()` and selector `0xd551823d`.
```solidity
error EmptyReceiver();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyReceiver {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyReceiver) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyReceiver()";
            const SELECTOR: [u8; 4] = [213u8, 81u8, 130u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyRemoveAmounts()` and selector `0x51865911`.
```solidity
error EmptyRemoveAmounts();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyRemoveAmounts {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyRemoveAmounts> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyRemoveAmounts) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyRemoveAmounts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyRemoveAmounts {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyRemoveAmounts()";
            const SELECTOR: [u8; 4] = [81u8, 134u8, 89u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyRepayAmounts()` and selector `0xc6d7c04d`.
```solidity
error EmptyRepayAmounts();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyRepayAmounts {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyRepayAmounts> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyRepayAmounts) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyRepayAmounts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyRepayAmounts {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyRepayAmounts()";
            const SELECTOR: [u8; 4] = [198u8, 215u8, 192u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptySwapInAmount()` and selector `0xf9381afa`.
```solidity
error EmptySwapInAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptySwapInAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptySwapInAmount> for UnderlyingRustTuple<'_> {
            fn from(value: EmptySwapInAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptySwapInAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptySwapInAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptySwapInAmount()";
            const SELECTOR: [u8; 4] = [249u8, 56u8, 26u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptySwapOutAmount()` and selector `0xbd377b18`.
```solidity
error EmptySwapOutAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptySwapOutAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptySwapOutAmount> for UnderlyingRustTuple<'_> {
            fn from(value: EmptySwapOutAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptySwapOutAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptySwapOutAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptySwapOutAmount()";
            const SELECTOR: [u8; 4] = [189u8, 55u8, 123u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyTokenBase()` and selector `0x58c52e4d`.
```solidity
error EmptyTokenBase();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyTokenBase {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyTokenBase> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyTokenBase) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyTokenBase {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyTokenBase {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyTokenBase()";
            const SELECTOR: [u8; 4] = [88u8, 197u8, 46u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyTokenTranferGasLimit(address)` and selector `0x9fc297fa`.
```solidity
error EmptyTokenTranferGasLimit(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyTokenTranferGasLimit {
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyTokenTranferGasLimit>
        for UnderlyingRustTuple<'_> {
            fn from(value: EmptyTokenTranferGasLimit) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for EmptyTokenTranferGasLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyTokenTranferGasLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyTokenTranferGasLimit(address)";
            const SELECTOR: [u8; 4] = [159u8, 194u8, 151u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `EmptyTreasury()` and selector `0xcdcb50b4`.
```solidity
error EmptyTreasury();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyTreasury {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyTreasury> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyTreasury) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyTreasury {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyTreasury {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyTreasury()";
            const SELECTOR: [u8; 4] = [205u8, 203u8, 80u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmptyUnclaimedFee(bytes32)` and selector `0x4e4b0d59`.
```solidity
error EmptyUnclaimedFee(bytes32 pool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyUnclaimedFee {
        pub pool: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyUnclaimedFee> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyUnclaimedFee) -> Self {
                (value.pool,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyUnclaimedFee {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { pool: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyUnclaimedFee {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyUnclaimedFee(bytes32)";
            const SELECTOR: [u8; 4] = [78u8, 75u8, 13u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.pool),
                )
            }
        }
    };
    /**Custom error with signature `EmptyWithdrawAmounts()` and selector `0xfd9e68c4`.
```solidity
error EmptyWithdrawAmounts();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmptyWithdrawAmounts {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmptyWithdrawAmounts> for UnderlyingRustTuple<'_> {
            fn from(value: EmptyWithdrawAmounts) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmptyWithdrawAmounts {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmptyWithdrawAmounts {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmptyWithdrawAmounts()";
            const SELECTOR: [u8; 4] = [253u8, 158u8, 104u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ErrorStep(address,uint256)` and selector `0xe8d2ae39`.
```solidity
error ErrorStep(address account, uint256 step);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ErrorStep {
        pub account: alloy::sol_types::private::Address,
        pub step: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ErrorStep> for UnderlyingRustTuple<'_> {
            fn from(value: ErrorStep) -> Self {
                (value.account, value.step)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ErrorStep {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    step: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ErrorStep {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ErrorStep(address,uint256)";
            const SELECTOR: [u8; 4] = [232u8, 210u8, 174u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.step),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientAvailableLiquidity(uint256,uint256)` and selector `0xaf9a97d4`.
```solidity
error InsufficientAvailableLiquidity(uint256 amount, uint256 availableLiquidity);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientAvailableLiquidity {
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        pub availableLiquidity: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientAvailableLiquidity>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientAvailableLiquidity) -> Self {
                (value.amount, value.availableLiquidity)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientAvailableLiquidity {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amount: tuple.0,
                    availableLiquidity: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientAvailableLiquidity {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientAvailableLiquidity(uint256,uint256)";
            const SELECTOR: [u8; 4] = [175u8, 154u8, 151u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.availableLiquidity),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientCollateralAmount(uint256,uint256)` and selector `0x1f4824b4`.
```solidity
error InsufficientCollateralAmount(uint256 amountToRemove, uint256 amountBalance);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientCollateralAmount {
        pub amountToRemove: alloy::sol_types::private::primitives::aliases::U256,
        pub amountBalance: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientCollateralAmount>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientCollateralAmount) -> Self {
                (value.amountToRemove, value.amountBalance)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientCollateralAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amountToRemove: tuple.0,
                    amountBalance: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientCollateralAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientCollateralAmount(uint256,uint256)";
            const SELECTOR: [u8; 4] = [31u8, 72u8, 36u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountToRemove),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountBalance),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientCollateralAmountForRepay(uint256,uint256)` and selector `0x86c4ec21`.
```solidity
error InsufficientCollateralAmountForRepay(uint256 repayAmount, uint256 collateralAmount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientCollateralAmountForRepay {
        pub repayAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub collateralAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientCollateralAmountForRepay>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientCollateralAmountForRepay) -> Self {
                (value.repayAmount, value.collateralAmount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientCollateralAmountForRepay {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    repayAmount: tuple.0,
                    collateralAmount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientCollateralAmountForRepay {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientCollateralAmountForRepay(uint256,uint256)";
            const SELECTOR: [u8; 4] = [134u8, 196u8, 236u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.repayAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.collateralAmount),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientCollateralForWidthdraw(uint256,uint256)` and selector `0x8ef2e53e`.
```solidity
error InsufficientCollateralForWidthdraw(uint256 amountToWithdraw, uint256 collateral);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientCollateralForWidthdraw {
        pub amountToWithdraw: alloy::sol_types::private::primitives::aliases::U256,
        pub collateral: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientCollateralForWidthdraw>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientCollateralForWidthdraw) -> Self {
                (value.amountToWithdraw, value.collateral)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientCollateralForWidthdraw {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amountToWithdraw: tuple.0,
                    collateral: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientCollateralForWidthdraw {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientCollateralForWidthdraw(uint256,uint256)";
            const SELECTOR: [u8; 4] = [142u8, 242u8, 229u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountToWithdraw),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.collateral),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientReverveForBorrow(uint256,uint256)` and selector `0x47959502`.
```solidity
error InsufficientReverveForBorrow(uint256 amountToBorrow, uint256 availableReserve);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientReverveForBorrow {
        pub amountToBorrow: alloy::sol_types::private::primitives::aliases::U256,
        pub availableReserve: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientReverveForBorrow>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientReverveForBorrow) -> Self {
                (value.amountToBorrow, value.availableReserve)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientReverveForBorrow {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amountToBorrow: tuple.0,
                    availableReserve: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientReverveForBorrow {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientReverveForBorrow(uint256,uint256)";
            const SELECTOR: [u8; 4] = [71u8, 149u8, 149u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountToBorrow),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.availableReserve),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientSwapAmount(uint256,uint256,uint256,uint256)` and selector `0x58595e41`.
```solidity
error InsufficientSwapAmount(uint256 lastVirtualLiquidity0, uint256 lastVirtualLiquidity1, uint256 adjustedVirtualLiquidity0, uint256 adjustedVirtualLiquidity1);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientSwapAmount {
        pub lastVirtualLiquidity0: alloy::sol_types::private::primitives::aliases::U256,
        pub lastVirtualLiquidity1: alloy::sol_types::private::primitives::aliases::U256,
        pub adjustedVirtualLiquidity0: alloy::sol_types::private::primitives::aliases::U256,
        pub adjustedVirtualLiquidity1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientSwapAmount> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientSwapAmount) -> Self {
                (
                    value.lastVirtualLiquidity0,
                    value.lastVirtualLiquidity1,
                    value.adjustedVirtualLiquidity0,
                    value.adjustedVirtualLiquidity1,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientSwapAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    lastVirtualLiquidity0: tuple.0,
                    lastVirtualLiquidity1: tuple.1,
                    adjustedVirtualLiquidity0: tuple.2,
                    adjustedVirtualLiquidity1: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientSwapAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientSwapAmount(uint256,uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [88u8, 89u8, 94u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.lastVirtualLiquidity0,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.lastVirtualLiquidity1,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.adjustedVirtualLiquidity0,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.adjustedVirtualLiquidity1,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientSwapCollateral(uint256,uint256)` and selector `0x671abd07`.
```solidity
error InsufficientSwapCollateral(uint256 amountIn, uint256 collateral);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientSwapCollateral {
        pub amountIn: alloy::sol_types::private::primitives::aliases::U256,
        pub collateral: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientSwapCollateral>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientSwapCollateral) -> Self {
                (value.amountIn, value.collateral)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientSwapCollateral {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amountIn: tuple.0,
                    collateral: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientSwapCollateral {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientSwapCollateral(uint256,uint256)";
            const SELECTOR: [u8; 4] = [103u8, 26u8, 189u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountIn),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.collateral),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientUserBalance(uint256,uint256)` and selector `0x5f504d20`.
```solidity
error InsufficientUserBalance(uint256 balance, uint256 liquidity);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientUserBalance {
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        pub liquidity: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientUserBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientUserBalance) -> Self {
                (value.balance, value.liquidity)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientUserBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    balance: tuple.0,
                    liquidity: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientUserBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientUserBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [95u8, 80u8, 77u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.liquidity),
                )
            }
        }
    };
    /**Custom error with signature `InvalidBorrowCapacity(uint256,uint256)` and selector `0x95c0bec8`.
```solidity
error InvalidBorrowCapacity(uint256 borrowCapacity, uint256 MaxValidBorrowCapacity);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidBorrowCapacity {
        pub borrowCapacity: alloy::sol_types::private::primitives::aliases::U256,
        pub MaxValidBorrowCapacity: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidBorrowCapacity> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidBorrowCapacity) -> Self {
                (value.borrowCapacity, value.MaxValidBorrowCapacity)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidBorrowCapacity {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    borrowCapacity: tuple.0,
                    MaxValidBorrowCapacity: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidBorrowCapacity {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidBorrowCapacity(uint256,uint256)";
            const SELECTOR: [u8; 4] = [149u8, 192u8, 190u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.borrowCapacity),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.MaxValidBorrowCapacity,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `InvalidDecimals(uint256,uint256)` and selector `0xc3ca0e37`.
```solidity
error InvalidDecimals(uint256 decimals, uint256 MaxValidDecimals);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDecimals {
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub MaxValidDecimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDecimals> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDecimals) -> Self {
                (value.decimals, value.MaxValidDecimals)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidDecimals {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    decimals: tuple.0,
                    MaxValidDecimals: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDecimals {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDecimals(uint256,uint256)";
            const SELECTOR: [u8; 4] = [195u8, 202u8, 14u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.decimals),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.MaxValidDecimals),
                )
            }
        }
    };
    /**Custom error with signature `InvalidFeeFactor(uint256,uint256)` and selector `0x9d1ea70b`.
```solidity
error InvalidFeeFactor(uint256 feeFactor, uint256 MaxValidFeeFactor);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidFeeFactor {
        pub feeFactor: alloy::sol_types::private::primitives::aliases::U256,
        pub MaxValidFeeFactor: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidFeeFactor> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidFeeFactor) -> Self {
                (value.feeFactor, value.MaxValidFeeFactor)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidFeeFactor {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    feeFactor: tuple.0,
                    MaxValidFeeFactor: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidFeeFactor {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidFeeFactor(uint256,uint256)";
            const SELECTOR: [u8; 4] = [157u8, 30u8, 167u8, 11u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.feeFactor),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.MaxValidFeeFactor),
                )
            }
        }
    };
    /**Custom error with signature `InvalidNativeTokenSender(address)` and selector `0xe71a51be`.
```solidity
error InvalidNativeTokenSender(address msgSender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNativeTokenSender {
        pub msgSender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNativeTokenSender>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNativeTokenSender) -> Self {
                (value.msgSender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidNativeTokenSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { msgSender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNativeTokenSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNativeTokenSender(address)";
            const SELECTOR: [u8; 4] = [231u8, 26u8, 81u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.msgSender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `InvalidOptimalUsageRate(uint256)` and selector `0xb90df3f2`.
```solidity
error InvalidOptimalUsageRate(uint256 optimalUsageRatio);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidOptimalUsageRate {
        pub optimalUsageRatio: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidOptimalUsageRate> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidOptimalUsageRate) -> Self {
                (value.optimalUsageRatio,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidOptimalUsageRate {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { optimalUsageRatio: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidOptimalUsageRate {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidOptimalUsageRate(uint256)";
            const SELECTOR: [u8; 4] = [185u8, 13u8, 243u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.optimalUsageRatio),
                )
            }
        }
    };
    /**Custom error with signature `InvalidPoolIndex(uint256)` and selector `0x782cbada`.
```solidity
error InvalidPoolIndex(uint256 poolKeyId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidPoolIndex {
        pub poolKeyId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidPoolIndex> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidPoolIndex) -> Self {
                (value.poolKeyId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidPoolIndex {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { poolKeyId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidPoolIndex {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidPoolIndex(uint256)";
            const SELECTOR: [u8; 4] = [120u8, 44u8, 186u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.poolKeyId),
                )
            }
        }
    };
    /**Custom error with signature `InvalidSupplyCapacity(uint256,uint256)` and selector `0x178d1d2b`.
```solidity
error InvalidSupplyCapacity(uint256 supplyCapacity, uint256 MaxValidSupplyCapacity);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSupplyCapacity {
        pub supplyCapacity: alloy::sol_types::private::primitives::aliases::U256,
        pub MaxValidSupplyCapacity: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSupplyCapacity> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSupplyCapacity) -> Self {
                (value.supplyCapacity, value.MaxValidSupplyCapacity)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSupplyCapacity {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    supplyCapacity: tuple.0,
                    MaxValidSupplyCapacity: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSupplyCapacity {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSupplyCapacity(uint256,uint256)";
            const SELECTOR: [u8; 4] = [23u8, 141u8, 29u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.supplyCapacity),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.MaxValidSupplyCapacity,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `MarginAboveThreshold(uint256,uint256)` and selector `0xe9d064f4`.
```solidity
error MarginAboveThreshold(uint256 marginLevel, uint256 marginLevelThreshold);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MarginAboveThreshold {
        pub marginLevel: alloy::sol_types::private::primitives::aliases::U256,
        pub marginLevelThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MarginAboveThreshold> for UnderlyingRustTuple<'_> {
            fn from(value: MarginAboveThreshold) -> Self {
                (value.marginLevel, value.marginLevelThreshold)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MarginAboveThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    marginLevel: tuple.0,
                    marginLevelThreshold: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MarginAboveThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MarginAboveThreshold(uint256,uint256)";
            const SELECTOR: [u8; 4] = [233u8, 208u8, 100u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.marginLevel),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.marginLevelThreshold),
                )
            }
        }
    };
    /**Custom error with signature `MarginBelowThreshold(uint256,uint256)` and selector `0x82d6353f`.
```solidity
error MarginBelowThreshold(uint256 marginLevel, uint256 marginLevelThreshold);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MarginBelowThreshold {
        pub marginLevel: alloy::sol_types::private::primitives::aliases::U256,
        pub marginLevelThreshold: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MarginBelowThreshold> for UnderlyingRustTuple<'_> {
            fn from(value: MarginBelowThreshold) -> Self {
                (value.marginLevel, value.marginLevelThreshold)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MarginBelowThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    marginLevel: tuple.0,
                    marginLevelThreshold: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MarginBelowThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MarginBelowThreshold(uint256,uint256)";
            const SELECTOR: [u8; 4] = [130u8, 214u8, 53u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.marginLevel),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.marginLevelThreshold),
                )
            }
        }
    };
    /**Custom error with signature `MaxDepositExceeds(uint256,uint256)` and selector `0x1df2e035`.
```solidity
error MaxDepositExceeds(uint256 maxDepositAmount, uint256 amountToDeposit);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MaxDepositExceeds {
        pub maxDepositAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub amountToDeposit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MaxDepositExceeds> for UnderlyingRustTuple<'_> {
            fn from(value: MaxDepositExceeds) -> Self {
                (value.maxDepositAmount, value.amountToDeposit)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MaxDepositExceeds {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    maxDepositAmount: tuple.0,
                    amountToDeposit: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MaxDepositExceeds {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MaxDepositExceeds(uint256,uint256)";
            const SELECTOR: [u8; 4] = [29u8, 242u8, 224u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxDepositAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountToDeposit),
                )
            }
        }
    };
    /**Custom error with signature `MaxPositionId()` and selector `0xb611be74`.
```solidity
error MaxPositionId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MaxPositionId {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MaxPositionId> for UnderlyingRustTuple<'_> {
            fn from(value: MaxPositionId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MaxPositionId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MaxPositionId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MaxPositionId()";
            const SELECTOR: [u8; 4] = [182u8, 17u8, 190u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `PoolAlreadyExists(bytes32,address)` and selector `0x0b8422c3`.
```solidity
error PoolAlreadyExists(bytes32 key, address poolBank);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PoolAlreadyExists {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub poolBank: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PoolAlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: PoolAlreadyExists) -> Self {
                (value.key, value.poolBank)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PoolAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    key: tuple.0,
                    poolBank: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PoolAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PoolAlreadyExists(bytes32,address)";
            const SELECTOR: [u8; 4] = [11u8, 132u8, 34u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.poolBank,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `PositionNotFound(bytes32)` and selector `0x426cfff0`.
```solidity
error PositionNotFound(bytes32 key);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PositionNotFound {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PositionNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: PositionNotFound) -> Self {
                (value.key,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PositionNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { key: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PositionNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PositionNotFound(bytes32)";
            const SELECTOR: [u8; 4] = [66u8, 108u8, 255u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
        }
    };
    /**Custom error with signature `RequestedAmount1ExceedsPriceLimit(uint256,uint256)` and selector `0xea1d6892`.
```solidity
error RequestedAmount1ExceedsPriceLimit(uint256 amount1Out, uint256 amount1OutMax);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RequestedAmount1ExceedsPriceLimit {
        pub amount1Out: alloy::sol_types::private::primitives::aliases::U256,
        pub amount1OutMax: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RequestedAmount1ExceedsPriceLimit>
        for UnderlyingRustTuple<'_> {
            fn from(value: RequestedAmount1ExceedsPriceLimit) -> Self {
                (value.amount1Out, value.amount1OutMax)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for RequestedAmount1ExceedsPriceLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amount1Out: tuple.0,
                    amount1OutMax: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RequestedAmount1ExceedsPriceLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RequestedAmount1ExceedsPriceLimit(uint256,uint256)";
            const SELECTOR: [u8; 4] = [234u8, 29u8, 104u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount1Out),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount1OutMax),
                )
            }
        }
    };
    /**Custom error with signature `RequestedAmountOExceedsPriceLimit(uint256,uint256)` and selector `0xcf0f1582`.
```solidity
error RequestedAmountOExceedsPriceLimit(uint256 amount0Out, uint256 amount0OutMax);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RequestedAmountOExceedsPriceLimit {
        pub amount0Out: alloy::sol_types::private::primitives::aliases::U256,
        pub amount0OutMax: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RequestedAmountOExceedsPriceLimit>
        for UnderlyingRustTuple<'_> {
            fn from(value: RequestedAmountOExceedsPriceLimit) -> Self {
                (value.amount0Out, value.amount0OutMax)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for RequestedAmountOExceedsPriceLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amount0Out: tuple.0,
                    amount0OutMax: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RequestedAmountOExceedsPriceLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RequestedAmountOExceedsPriceLimit(uint256,uint256)";
            const SELECTOR: [u8; 4] = [207u8, 15u8, 21u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount0Out),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount0OutMax),
                )
            }
        }
    };
    /**Custom error with signature `Reserve0Insufficient(uint256,uint256)` and selector `0x1fc107c1`.
```solidity
error Reserve0Insufficient(uint256 amount0, uint256 availableReserve0);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Reserve0Insufficient {
        pub amount0: alloy::sol_types::private::primitives::aliases::U256,
        pub availableReserve0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Reserve0Insufficient> for UnderlyingRustTuple<'_> {
            fn from(value: Reserve0Insufficient) -> Self {
                (value.amount0, value.availableReserve0)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Reserve0Insufficient {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amount0: tuple.0,
                    availableReserve0: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Reserve0Insufficient {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Reserve0Insufficient(uint256,uint256)";
            const SELECTOR: [u8; 4] = [31u8, 193u8, 7u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.availableReserve0),
                )
            }
        }
    };
    /**Custom error with signature `Reserve1Insufficient(uint256,uint256)` and selector `0x0e793baf`.
```solidity
error Reserve1Insufficient(uint256 amount1, uint256 availableReserve1);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Reserve1Insufficient {
        pub amount1: alloy::sol_types::private::primitives::aliases::U256,
        pub availableReserve1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Reserve1Insufficient> for UnderlyingRustTuple<'_> {
            fn from(value: Reserve1Insufficient) -> Self {
                (value.amount1, value.availableReserve1)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Reserve1Insufficient {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amount1: tuple.0,
                    availableReserve1: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Reserve1Insufficient {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Reserve1Insufficient(uint256,uint256)";
            const SELECTOR: [u8; 4] = [14u8, 121u8, 59u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount1),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.availableReserve1),
                )
            }
        }
    };
    /**Custom error with signature `SelfTransferNotSupported(address)` and selector `0xe70f9152`.
```solidity
error SelfTransferNotSupported(address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SelfTransferNotSupported {
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SelfTransferNotSupported>
        for UnderlyingRustTuple<'_> {
            fn from(value: SelfTransferNotSupported) -> Self {
                (value.receiver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SelfTransferNotSupported {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { receiver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SelfTransferNotSupported {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SelfTransferNotSupported(address)";
            const SELECTOR: [u8; 4] = [231u8, 15u8, 145u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `SingleTokenInOutSwapOnly()` and selector `0x6331fab1`.
```solidity
error SingleTokenInOutSwapOnly();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SingleTokenInOutSwapOnly {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SingleTokenInOutSwapOnly>
        for UnderlyingRustTuple<'_> {
            fn from(value: SingleTokenInOutSwapOnly) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SingleTokenInOutSwapOnly {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SingleTokenInOutSwapOnly {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SingleTokenInOutSwapOnly()";
            const SELECTOR: [u8; 4] = [99u8, 49u8, 250u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ThereMustBeAtLeastOneRoleAdmin()` and selector `0xb783c88a`.
```solidity
error ThereMustBeAtLeastOneRoleAdmin();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ThereMustBeAtLeastOneRoleAdmin {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ThereMustBeAtLeastOneRoleAdmin>
        for UnderlyingRustTuple<'_> {
            fn from(value: ThereMustBeAtLeastOneRoleAdmin) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ThereMustBeAtLeastOneRoleAdmin {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ThereMustBeAtLeastOneRoleAdmin {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ThereMustBeAtLeastOneRoleAdmin()";
            const SELECTOR: [u8; 4] = [183u8, 131u8, 200u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ThereMustBeAtLeastOneTimelockMultiSig()` and selector `0x282b5b70`.
```solidity
error ThereMustBeAtLeastOneTimelockMultiSig();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ThereMustBeAtLeastOneTimelockMultiSig {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ThereMustBeAtLeastOneTimelockMultiSig>
        for UnderlyingRustTuple<'_> {
            fn from(value: ThereMustBeAtLeastOneTimelockMultiSig) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ThereMustBeAtLeastOneTimelockMultiSig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ThereMustBeAtLeastOneTimelockMultiSig {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ThereMustBeAtLeastOneTimelockMultiSig()";
            const SELECTOR: [u8; 4] = [40u8, 43u8, 91u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TokenIndexNotSupport()` and selector `0xa04d606c`.
```solidity
error TokenIndexNotSupport();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TokenIndexNotSupport {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TokenIndexNotSupport> for UnderlyingRustTuple<'_> {
            fn from(value: TokenIndexNotSupport) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TokenIndexNotSupport {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TokenIndexNotSupport {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TokenIndexNotSupport()";
            const SELECTOR: [u8; 4] = [160u8, 77u8, 96u8, 108u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TokenTransferError(address,address,uint256)` and selector `0x979dc780`.
```solidity
error TokenTransferError(address token, address receiver, uint256 amount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TokenTransferError {
        pub token: alloy::sol_types::private::Address,
        pub receiver: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TokenTransferError> for UnderlyingRustTuple<'_> {
            fn from(value: TokenTransferError) -> Self {
                (value.token, value.receiver, value.amount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TokenTransferError {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    token: tuple.0,
                    receiver: tuple.1,
                    amount: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TokenTransferError {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TokenTransferError(address,address,uint256)";
            const SELECTOR: [u8; 4] = [151u8, 157u8, 199u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
        }
    };
    /**Custom error with signature `TokensNotMatch()` and selector `0x23cac742`.
```solidity
error TokensNotMatch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TokensNotMatch {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TokensNotMatch> for UnderlyingRustTuple<'_> {
            fn from(value: TokensNotMatch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TokensNotMatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TokensNotMatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TokensNotMatch()";
            const SELECTOR: [u8; 4] = [35u8, 202u8, 199u8, 66u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `Unauthorized(address,string)` and selector `0xa35b150b`.
```solidity
error Unauthorized(address msgSender, string role);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Unauthorized {
        pub msgSender: alloy::sol_types::private::Address,
        pub role: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Unauthorized> for UnderlyingRustTuple<'_> {
            fn from(value: Unauthorized) -> Self {
                (value.msgSender, value.role)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Unauthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    msgSender: tuple.0,
                    role: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Unauthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Unauthorized(address,string)";
            const SELECTOR: [u8; 4] = [163u8, 91u8, 21u8, 11u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.msgSender,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.role,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `UsdCollateralCanNotCoverDebt(uint256,uint256,uint256,address)` and selector `0xb2a4b254`.
```solidity
error UsdCollateralCanNotCoverDebt(uint256 usdCollateralAmount, uint256 usdCollateralAmountNeeded, uint256 debtAmount, address underlyingAsset);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UsdCollateralCanNotCoverDebt {
        pub usdCollateralAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub usdCollateralAmountNeeded: alloy::sol_types::private::primitives::aliases::U256,
        pub debtAmount: alloy::sol_types::private::primitives::aliases::U256,
        pub underlyingAsset: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UsdCollateralCanNotCoverDebt>
        for UnderlyingRustTuple<'_> {
            fn from(value: UsdCollateralCanNotCoverDebt) -> Self {
                (
                    value.usdCollateralAmount,
                    value.usdCollateralAmountNeeded,
                    value.debtAmount,
                    value.underlyingAsset,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UsdCollateralCanNotCoverDebt {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    usdCollateralAmount: tuple.0,
                    usdCollateralAmountNeeded: tuple.1,
                    debtAmount: tuple.2,
                    underlyingAsset: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UsdCollateralCanNotCoverDebt {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UsdCollateralCanNotCoverDebt(uint256,uint256,uint256,address)";
            const SELECTOR: [u8; 4] = [178u8, 164u8, 178u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.usdCollateralAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.usdCollateralAmountNeeded,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.debtAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.underlyingAsset,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `UserDoNotHaveDebtInPosition(address,bytes32)` and selector `0x31439e89`.
```solidity
error UserDoNotHaveDebtInPosition(address account, bytes32 positionKey);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UserDoNotHaveDebtInPosition {
        pub account: alloy::sol_types::private::Address,
        pub positionKey: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UserDoNotHaveDebtInPosition>
        for UnderlyingRustTuple<'_> {
            fn from(value: UserDoNotHaveDebtInPosition) -> Self {
                (value.account, value.positionKey)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UserDoNotHaveDebtInPosition {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    positionKey: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UserDoNotHaveDebtInPosition {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UserDoNotHaveDebtInPosition(address,bytes32)";
            const SELECTOR: [u8; 4] = [49u8, 67u8, 158u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.positionKey),
                )
            }
        }
    };
    /**Custom error with signature `liquidityDidNotReachShortThreshord(uint256,uint256)` and selector `0xfe0081af`.
```solidity
error liquidityDidNotReachShortThreshord(uint256 threshold, uint256 basePriceReserve);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct liquidityDidNotReachShortThreshord {
        pub threshold: alloy::sol_types::private::primitives::aliases::U256,
        pub basePriceReserve: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<liquidityDidNotReachShortThreshord>
        for UnderlyingRustTuple<'_> {
            fn from(value: liquidityDidNotReachShortThreshord) -> Self {
                (value.threshold, value.basePriceReserve)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for liquidityDidNotReachShortThreshord {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    threshold: tuple.0,
                    basePriceReserve: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for liquidityDidNotReachShortThreshord {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "liquidityDidNotReachShortThreshord(uint256,uint256)";
            const SELECTOR: [u8; 4] = [254u8, 0u8, 129u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.threshold),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.basePriceReserve),
                )
            }
        }
    };
    ///Container for all the [`Errors`](self) custom errors.
    pub enum ErrorsErrors {
        AccountNotMatch(AccountNotMatch),
        Balance1Insufficient(Balance1Insufficient),
        ClosePercentageExceeding(ClosePercentageExceeding),
        CollateralCanNotCoverDebt(CollateralCanNotCoverDebt),
        CompactedArrayOutOfBounds(CompactedArrayOutOfBounds),
        CouldNotSendNativeToken(CouldNotSendNativeToken),
        DebtTokenOperationNotSupported(DebtTokenOperationNotSupported),
        EmptyAccount(EmptyAccount),
        EmptyAddAmounts(EmptyAddAmounts),
        EmptyAmount(EmptyAmount),
        EmptyBase(EmptyBase),
        EmptyBorrowAmounts(EmptyBorrowAmounts),
        EmptyBurnAmounts(EmptyBurnAmounts),
        EmptyCollateral(EmptyCollateral),
        EmptyConfiguration(EmptyConfiguration),
        EmptyDepositAmounts(EmptyDepositAmounts),
        EmptyHoldingAddress(EmptyHoldingAddress),
        EmptyInterestRateStrategy(EmptyInterestRateStrategy),
        EmptyMintAmounts(EmptyMintAmounts),
        EmptyPool(EmptyPool),
        EmptyPoolKeys(EmptyPoolKeys),
        EmptyPosition(EmptyPosition),
        EmptyPositions(EmptyPositions),
        EmptyReceiver(EmptyReceiver),
        EmptyRemoveAmounts(EmptyRemoveAmounts),
        EmptyRepayAmounts(EmptyRepayAmounts),
        EmptySwapInAmount(EmptySwapInAmount),
        EmptySwapOutAmount(EmptySwapOutAmount),
        EmptyTokenBase(EmptyTokenBase),
        EmptyTokenTranferGasLimit(EmptyTokenTranferGasLimit),
        EmptyTreasury(EmptyTreasury),
        EmptyUnclaimedFee(EmptyUnclaimedFee),
        EmptyWithdrawAmounts(EmptyWithdrawAmounts),
        ErrorStep(ErrorStep),
        InsufficientAvailableLiquidity(InsufficientAvailableLiquidity),
        InsufficientCollateralAmount(InsufficientCollateralAmount),
        InsufficientCollateralAmountForRepay(InsufficientCollateralAmountForRepay),
        InsufficientCollateralForWidthdraw(InsufficientCollateralForWidthdraw),
        InsufficientReverveForBorrow(InsufficientReverveForBorrow),
        InsufficientSwapAmount(InsufficientSwapAmount),
        InsufficientSwapCollateral(InsufficientSwapCollateral),
        InsufficientUserBalance(InsufficientUserBalance),
        InvalidBorrowCapacity(InvalidBorrowCapacity),
        InvalidDecimals(InvalidDecimals),
        InvalidFeeFactor(InvalidFeeFactor),
        InvalidNativeTokenSender(InvalidNativeTokenSender),
        InvalidOptimalUsageRate(InvalidOptimalUsageRate),
        InvalidPoolIndex(InvalidPoolIndex),
        InvalidSupplyCapacity(InvalidSupplyCapacity),
        MarginAboveThreshold(MarginAboveThreshold),
        MarginBelowThreshold(MarginBelowThreshold),
        MaxDepositExceeds(MaxDepositExceeds),
        MaxPositionId(MaxPositionId),
        PoolAlreadyExists(PoolAlreadyExists),
        PositionNotFound(PositionNotFound),
        RequestedAmount1ExceedsPriceLimit(RequestedAmount1ExceedsPriceLimit),
        RequestedAmountOExceedsPriceLimit(RequestedAmountOExceedsPriceLimit),
        Reserve0Insufficient(Reserve0Insufficient),
        Reserve1Insufficient(Reserve1Insufficient),
        SelfTransferNotSupported(SelfTransferNotSupported),
        SingleTokenInOutSwapOnly(SingleTokenInOutSwapOnly),
        ThereMustBeAtLeastOneRoleAdmin(ThereMustBeAtLeastOneRoleAdmin),
        ThereMustBeAtLeastOneTimelockMultiSig(ThereMustBeAtLeastOneTimelockMultiSig),
        TokenIndexNotSupport(TokenIndexNotSupport),
        TokenTransferError(TokenTransferError),
        TokensNotMatch(TokensNotMatch),
        Unauthorized(Unauthorized),
        UsdCollateralCanNotCoverDebt(UsdCollateralCanNotCoverDebt),
        UserDoNotHaveDebtInPosition(UserDoNotHaveDebtInPosition),
        liquidityDidNotReachShortThreshord(liquidityDidNotReachShortThreshord),
    }
    #[automatically_derived]
    impl ErrorsErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 175u8, 140u8, 36u8],
            [11u8, 132u8, 34u8, 195u8],
            [13u8, 20u8, 52u8, 88u8],
            [14u8, 121u8, 59u8, 175u8],
            [23u8, 141u8, 29u8, 43u8],
            [24u8, 84u8, 153u8, 52u8],
            [29u8, 242u8, 224u8, 53u8],
            [31u8, 72u8, 36u8, 180u8],
            [31u8, 193u8, 7u8, 193u8],
            [35u8, 68u8, 156u8, 44u8],
            [35u8, 202u8, 199u8, 66u8],
            [37u8, 199u8, 21u8, 126u8],
            [38u8, 33u8, 25u8, 41u8],
            [40u8, 43u8, 91u8, 112u8],
            [49u8, 67u8, 158u8, 137u8],
            [50u8, 28u8, 22u8, 102u8],
            [66u8, 108u8, 255u8, 240u8],
            [71u8, 149u8, 149u8, 2u8],
            [77u8, 251u8, 191u8, 243u8],
            [78u8, 75u8, 13u8, 89u8],
            [81u8, 134u8, 89u8, 17u8],
            [85u8, 58u8, 245u8, 68u8],
            [88u8, 89u8, 94u8, 65u8],
            [88u8, 197u8, 46u8, 77u8],
            [95u8, 80u8, 77u8, 32u8],
            [99u8, 49u8, 250u8, 177u8],
            [103u8, 26u8, 189u8, 7u8],
            [105u8, 119u8, 202u8, 12u8],
            [108u8, 83u8, 5u8, 109u8],
            [115u8, 87u8, 217u8, 31u8],
            [115u8, 223u8, 44u8, 208u8],
            [117u8, 207u8, 114u8, 9u8],
            [120u8, 44u8, 186u8, 218u8],
            [121u8, 100u8, 106u8, 175u8],
            [122u8, 67u8, 156u8, 73u8],
            [130u8, 214u8, 53u8, 63u8],
            [134u8, 196u8, 236u8, 33u8],
            [142u8, 242u8, 229u8, 62u8],
            [149u8, 192u8, 190u8, 200u8],
            [151u8, 157u8, 199u8, 128u8],
            [157u8, 30u8, 167u8, 11u8],
            [159u8, 194u8, 151u8, 250u8],
            [160u8, 77u8, 96u8, 108u8],
            [163u8, 91u8, 21u8, 11u8],
            [172u8, 63u8, 177u8, 29u8],
            [175u8, 154u8, 151u8, 212u8],
            [178u8, 164u8, 178u8, 84u8],
            [182u8, 17u8, 190u8, 116u8],
            [183u8, 131u8, 200u8, 138u8],
            [185u8, 13u8, 243u8, 242u8],
            [189u8, 55u8, 123u8, 24u8],
            [189u8, 236u8, 156u8, 13u8],
            [195u8, 202u8, 14u8, 55u8],
            [198u8, 215u8, 192u8, 77u8],
            [205u8, 203u8, 80u8, 180u8],
            [207u8, 15u8, 21u8, 130u8],
            [213u8, 81u8, 130u8, 61u8],
            [221u8, 112u8, 22u8, 162u8],
            [231u8, 15u8, 145u8, 82u8],
            [231u8, 26u8, 81u8, 190u8],
            [232u8, 150u8, 69u8, 20u8],
            [232u8, 210u8, 174u8, 57u8],
            [233u8, 183u8, 139u8, 212u8],
            [233u8, 208u8, 100u8, 244u8],
            [234u8, 29u8, 104u8, 146u8],
            [248u8, 186u8, 223u8, 216u8],
            [249u8, 56u8, 26u8, 250u8],
            [250u8, 132u8, 170u8, 206u8],
            [253u8, 158u8, 104u8, 196u8],
            [254u8, 0u8, 129u8, 175u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ErrorsErrors {
        const NAME: &'static str = "ErrorsErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 70usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccountNotMatch(_) => {
                    <AccountNotMatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Balance1Insufficient(_) => {
                    <Balance1Insufficient as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ClosePercentageExceeding(_) => {
                    <ClosePercentageExceeding as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CollateralCanNotCoverDebt(_) => {
                    <CollateralCanNotCoverDebt as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CompactedArrayOutOfBounds(_) => {
                    <CompactedArrayOutOfBounds as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CouldNotSendNativeToken(_) => {
                    <CouldNotSendNativeToken as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DebtTokenOperationNotSupported(_) => {
                    <DebtTokenOperationNotSupported as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyAccount(_) => {
                    <EmptyAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyAddAmounts(_) => {
                    <EmptyAddAmounts as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyAmount(_) => {
                    <EmptyAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyBase(_) => <EmptyBase as alloy_sol_types::SolError>::SELECTOR,
                Self::EmptyBorrowAmounts(_) => {
                    <EmptyBorrowAmounts as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyBurnAmounts(_) => {
                    <EmptyBurnAmounts as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyCollateral(_) => {
                    <EmptyCollateral as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyConfiguration(_) => {
                    <EmptyConfiguration as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyDepositAmounts(_) => {
                    <EmptyDepositAmounts as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyHoldingAddress(_) => {
                    <EmptyHoldingAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyInterestRateStrategy(_) => {
                    <EmptyInterestRateStrategy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyMintAmounts(_) => {
                    <EmptyMintAmounts as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyPool(_) => <EmptyPool as alloy_sol_types::SolError>::SELECTOR,
                Self::EmptyPoolKeys(_) => {
                    <EmptyPoolKeys as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyPosition(_) => {
                    <EmptyPosition as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyPositions(_) => {
                    <EmptyPositions as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyReceiver(_) => {
                    <EmptyReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyRemoveAmounts(_) => {
                    <EmptyRemoveAmounts as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyRepayAmounts(_) => {
                    <EmptyRepayAmounts as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptySwapInAmount(_) => {
                    <EmptySwapInAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptySwapOutAmount(_) => {
                    <EmptySwapOutAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyTokenBase(_) => {
                    <EmptyTokenBase as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyTokenTranferGasLimit(_) => {
                    <EmptyTokenTranferGasLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyTreasury(_) => {
                    <EmptyTreasury as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyUnclaimedFee(_) => {
                    <EmptyUnclaimedFee as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmptyWithdrawAmounts(_) => {
                    <EmptyWithdrawAmounts as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ErrorStep(_) => <ErrorStep as alloy_sol_types::SolError>::SELECTOR,
                Self::InsufficientAvailableLiquidity(_) => {
                    <InsufficientAvailableLiquidity as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientCollateralAmount(_) => {
                    <InsufficientCollateralAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientCollateralAmountForRepay(_) => {
                    <InsufficientCollateralAmountForRepay as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientCollateralForWidthdraw(_) => {
                    <InsufficientCollateralForWidthdraw as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientReverveForBorrow(_) => {
                    <InsufficientReverveForBorrow as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientSwapAmount(_) => {
                    <InsufficientSwapAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientSwapCollateral(_) => {
                    <InsufficientSwapCollateral as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientUserBalance(_) => {
                    <InsufficientUserBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidBorrowCapacity(_) => {
                    <InvalidBorrowCapacity as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDecimals(_) => {
                    <InvalidDecimals as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidFeeFactor(_) => {
                    <InvalidFeeFactor as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNativeTokenSender(_) => {
                    <InvalidNativeTokenSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidOptimalUsageRate(_) => {
                    <InvalidOptimalUsageRate as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidPoolIndex(_) => {
                    <InvalidPoolIndex as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSupplyCapacity(_) => {
                    <InvalidSupplyCapacity as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MarginAboveThreshold(_) => {
                    <MarginAboveThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MarginBelowThreshold(_) => {
                    <MarginBelowThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MaxDepositExceeds(_) => {
                    <MaxDepositExceeds as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MaxPositionId(_) => {
                    <MaxPositionId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PoolAlreadyExists(_) => {
                    <PoolAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PositionNotFound(_) => {
                    <PositionNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RequestedAmount1ExceedsPriceLimit(_) => {
                    <RequestedAmount1ExceedsPriceLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RequestedAmountOExceedsPriceLimit(_) => {
                    <RequestedAmountOExceedsPriceLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Reserve0Insufficient(_) => {
                    <Reserve0Insufficient as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Reserve1Insufficient(_) => {
                    <Reserve1Insufficient as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SelfTransferNotSupported(_) => {
                    <SelfTransferNotSupported as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SingleTokenInOutSwapOnly(_) => {
                    <SingleTokenInOutSwapOnly as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ThereMustBeAtLeastOneRoleAdmin(_) => {
                    <ThereMustBeAtLeastOneRoleAdmin as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ThereMustBeAtLeastOneTimelockMultiSig(_) => {
                    <ThereMustBeAtLeastOneTimelockMultiSig as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TokenIndexNotSupport(_) => {
                    <TokenIndexNotSupport as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TokenTransferError(_) => {
                    <TokenTransferError as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TokensNotMatch(_) => {
                    <TokensNotMatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Unauthorized(_) => {
                    <Unauthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UsdCollateralCanNotCoverDebt(_) => {
                    <UsdCollateralCanNotCoverDebt as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UserDoNotHaveDebtInPosition(_) => {
                    <UserDoNotHaveDebtInPosition as alloy_sol_types::SolError>::SELECTOR
                }
                Self::liquidityDidNotReachShortThreshord(_) => {
                    <liquidityDidNotReachShortThreshord as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ErrorsErrors>] = &[
                {
                    fn EmptyDepositAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyDepositAmounts as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyDepositAmounts)
                    }
                    EmptyDepositAmounts
                },
                {
                    fn PoolAlreadyExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <PoolAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::PoolAlreadyExists)
                    }
                    PoolAlreadyExists
                },
                {
                    fn EmptyAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyAmount)
                    }
                    EmptyAmount
                },
                {
                    fn Reserve1Insufficient(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <Reserve1Insufficient as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::Reserve1Insufficient)
                    }
                    Reserve1Insufficient
                },
                {
                    fn InvalidSupplyCapacity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InvalidSupplyCapacity as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InvalidSupplyCapacity)
                    }
                    InvalidSupplyCapacity
                },
                {
                    fn EmptyConfiguration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyConfiguration as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyConfiguration)
                    }
                    EmptyConfiguration
                },
                {
                    fn MaxDepositExceeds(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <MaxDepositExceeds as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::MaxDepositExceeds)
                    }
                    MaxDepositExceeds
                },
                {
                    fn InsufficientCollateralAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InsufficientCollateralAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InsufficientCollateralAmount)
                    }
                    InsufficientCollateralAmount
                },
                {
                    fn Reserve0Insufficient(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <Reserve0Insufficient as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::Reserve0Insufficient)
                    }
                    Reserve0Insufficient
                },
                {
                    fn EmptyBase(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyBase as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyBase)
                    }
                    EmptyBase
                },
                {
                    fn TokensNotMatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <TokensNotMatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::TokensNotMatch)
                    }
                    TokensNotMatch
                },
                {
                    fn AccountNotMatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <AccountNotMatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::AccountNotMatch)
                    }
                    AccountNotMatch
                },
                {
                    fn Balance1Insufficient(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <Balance1Insufficient as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::Balance1Insufficient)
                    }
                    Balance1Insufficient
                },
                {
                    fn ThereMustBeAtLeastOneTimelockMultiSig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <ThereMustBeAtLeastOneTimelockMultiSig as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::ThereMustBeAtLeastOneTimelockMultiSig)
                    }
                    ThereMustBeAtLeastOneTimelockMultiSig
                },
                {
                    fn UserDoNotHaveDebtInPosition(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <UserDoNotHaveDebtInPosition as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::UserDoNotHaveDebtInPosition)
                    }
                    UserDoNotHaveDebtInPosition
                },
                {
                    fn CouldNotSendNativeToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <CouldNotSendNativeToken as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::CouldNotSendNativeToken)
                    }
                    CouldNotSendNativeToken
                },
                {
                    fn PositionNotFound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <PositionNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::PositionNotFound)
                    }
                    PositionNotFound
                },
                {
                    fn InsufficientReverveForBorrow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InsufficientReverveForBorrow as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InsufficientReverveForBorrow)
                    }
                    InsufficientReverveForBorrow
                },
                {
                    fn EmptyPosition(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyPosition as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyPosition)
                    }
                    EmptyPosition
                },
                {
                    fn EmptyUnclaimedFee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyUnclaimedFee as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyUnclaimedFee)
                    }
                    EmptyUnclaimedFee
                },
                {
                    fn EmptyRemoveAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyRemoveAmounts as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyRemoveAmounts)
                    }
                    EmptyRemoveAmounts
                },
                {
                    fn ClosePercentageExceeding(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <ClosePercentageExceeding as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::ClosePercentageExceeding)
                    }
                    ClosePercentageExceeding
                },
                {
                    fn InsufficientSwapAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InsufficientSwapAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InsufficientSwapAmount)
                    }
                    InsufficientSwapAmount
                },
                {
                    fn EmptyTokenBase(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyTokenBase as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyTokenBase)
                    }
                    EmptyTokenBase
                },
                {
                    fn InsufficientUserBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InsufficientUserBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InsufficientUserBalance)
                    }
                    InsufficientUserBalance
                },
                {
                    fn SingleTokenInOutSwapOnly(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <SingleTokenInOutSwapOnly as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::SingleTokenInOutSwapOnly)
                    }
                    SingleTokenInOutSwapOnly
                },
                {
                    fn InsufficientSwapCollateral(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InsufficientSwapCollateral as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InsufficientSwapCollateral)
                    }
                    InsufficientSwapCollateral
                },
                {
                    fn EmptyAddAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyAddAmounts as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyAddAmounts)
                    }
                    EmptyAddAmounts
                },
                {
                    fn EmptyCollateral(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyCollateral as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyCollateral)
                    }
                    EmptyCollateral
                },
                {
                    fn EmptyPool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyPool as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyPool)
                    }
                    EmptyPool
                },
                {
                    fn EmptyPositions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyPositions as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyPositions)
                    }
                    EmptyPositions
                },
                {
                    fn EmptyMintAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyMintAmounts as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyMintAmounts)
                    }
                    EmptyMintAmounts
                },
                {
                    fn InvalidPoolIndex(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InvalidPoolIndex as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InvalidPoolIndex)
                    }
                    InvalidPoolIndex
                },
                {
                    fn EmptyBorrowAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyBorrowAmounts as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyBorrowAmounts)
                    }
                    EmptyBorrowAmounts
                },
                {
                    fn EmptyPoolKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyPoolKeys as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyPoolKeys)
                    }
                    EmptyPoolKeys
                },
                {
                    fn MarginBelowThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <MarginBelowThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::MarginBelowThreshold)
                    }
                    MarginBelowThreshold
                },
                {
                    fn InsufficientCollateralAmountForRepay(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InsufficientCollateralAmountForRepay as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InsufficientCollateralAmountForRepay)
                    }
                    InsufficientCollateralAmountForRepay
                },
                {
                    fn InsufficientCollateralForWidthdraw(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InsufficientCollateralForWidthdraw as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InsufficientCollateralForWidthdraw)
                    }
                    InsufficientCollateralForWidthdraw
                },
                {
                    fn InvalidBorrowCapacity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InvalidBorrowCapacity as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InvalidBorrowCapacity)
                    }
                    InvalidBorrowCapacity
                },
                {
                    fn TokenTransferError(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <TokenTransferError as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::TokenTransferError)
                    }
                    TokenTransferError
                },
                {
                    fn InvalidFeeFactor(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InvalidFeeFactor as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InvalidFeeFactor)
                    }
                    InvalidFeeFactor
                },
                {
                    fn EmptyTokenTranferGasLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyTokenTranferGasLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyTokenTranferGasLimit)
                    }
                    EmptyTokenTranferGasLimit
                },
                {
                    fn TokenIndexNotSupport(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <TokenIndexNotSupport as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::TokenIndexNotSupport)
                    }
                    TokenIndexNotSupport
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn CollateralCanNotCoverDebt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <CollateralCanNotCoverDebt as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::CollateralCanNotCoverDebt)
                    }
                    CollateralCanNotCoverDebt
                },
                {
                    fn InsufficientAvailableLiquidity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InsufficientAvailableLiquidity as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InsufficientAvailableLiquidity)
                    }
                    InsufficientAvailableLiquidity
                },
                {
                    fn UsdCollateralCanNotCoverDebt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <UsdCollateralCanNotCoverDebt as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::UsdCollateralCanNotCoverDebt)
                    }
                    UsdCollateralCanNotCoverDebt
                },
                {
                    fn MaxPositionId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <MaxPositionId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::MaxPositionId)
                    }
                    MaxPositionId
                },
                {
                    fn ThereMustBeAtLeastOneRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <ThereMustBeAtLeastOneRoleAdmin as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::ThereMustBeAtLeastOneRoleAdmin)
                    }
                    ThereMustBeAtLeastOneRoleAdmin
                },
                {
                    fn InvalidOptimalUsageRate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InvalidOptimalUsageRate as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InvalidOptimalUsageRate)
                    }
                    InvalidOptimalUsageRate
                },
                {
                    fn EmptySwapOutAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptySwapOutAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptySwapOutAmount)
                    }
                    EmptySwapOutAmount
                },
                {
                    fn CompactedArrayOutOfBounds(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <CompactedArrayOutOfBounds as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::CompactedArrayOutOfBounds)
                    }
                    CompactedArrayOutOfBounds
                },
                {
                    fn InvalidDecimals(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InvalidDecimals as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InvalidDecimals)
                    }
                    InvalidDecimals
                },
                {
                    fn EmptyRepayAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyRepayAmounts as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyRepayAmounts)
                    }
                    EmptyRepayAmounts
                },
                {
                    fn EmptyTreasury(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyTreasury as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyTreasury)
                    }
                    EmptyTreasury
                },
                {
                    fn RequestedAmountOExceedsPriceLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <RequestedAmountOExceedsPriceLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::RequestedAmountOExceedsPriceLimit)
                    }
                    RequestedAmountOExceedsPriceLimit
                },
                {
                    fn EmptyReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyReceiver)
                    }
                    EmptyReceiver
                },
                {
                    fn EmptyAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyAccount)
                    }
                    EmptyAccount
                },
                {
                    fn SelfTransferNotSupported(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <SelfTransferNotSupported as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::SelfTransferNotSupported)
                    }
                    SelfTransferNotSupported
                },
                {
                    fn InvalidNativeTokenSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <InvalidNativeTokenSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::InvalidNativeTokenSender)
                    }
                    InvalidNativeTokenSender
                },
                {
                    fn DebtTokenOperationNotSupported(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <DebtTokenOperationNotSupported as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::DebtTokenOperationNotSupported)
                    }
                    DebtTokenOperationNotSupported
                },
                {
                    fn ErrorStep(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <ErrorStep as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::ErrorStep)
                    }
                    ErrorStep
                },
                {
                    fn EmptyHoldingAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyHoldingAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyHoldingAddress)
                    }
                    EmptyHoldingAddress
                },
                {
                    fn MarginAboveThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <MarginAboveThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::MarginAboveThreshold)
                    }
                    MarginAboveThreshold
                },
                {
                    fn RequestedAmount1ExceedsPriceLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <RequestedAmount1ExceedsPriceLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::RequestedAmount1ExceedsPriceLimit)
                    }
                    RequestedAmount1ExceedsPriceLimit
                },
                {
                    fn EmptyBurnAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyBurnAmounts as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyBurnAmounts)
                    }
                    EmptyBurnAmounts
                },
                {
                    fn EmptySwapInAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptySwapInAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptySwapInAmount)
                    }
                    EmptySwapInAmount
                },
                {
                    fn EmptyInterestRateStrategy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyInterestRateStrategy as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyInterestRateStrategy)
                    }
                    EmptyInterestRateStrategy
                },
                {
                    fn EmptyWithdrawAmounts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <EmptyWithdrawAmounts as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::EmptyWithdrawAmounts)
                    }
                    EmptyWithdrawAmounts
                },
                {
                    fn liquidityDidNotReachShortThreshord(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ErrorsErrors> {
                        <liquidityDidNotReachShortThreshord as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ErrorsErrors::liquidityDidNotReachShortThreshord)
                    }
                    liquidityDidNotReachShortThreshord
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccountNotMatch(inner) => {
                    <AccountNotMatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Balance1Insufficient(inner) => {
                    <Balance1Insufficient as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ClosePercentageExceeding(inner) => {
                    <ClosePercentageExceeding as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CollateralCanNotCoverDebt(inner) => {
                    <CollateralCanNotCoverDebt as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CompactedArrayOutOfBounds(inner) => {
                    <CompactedArrayOutOfBounds as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CouldNotSendNativeToken(inner) => {
                    <CouldNotSendNativeToken as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DebtTokenOperationNotSupported(inner) => {
                    <DebtTokenOperationNotSupported as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyAccount(inner) => {
                    <EmptyAccount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyAddAmounts(inner) => {
                    <EmptyAddAmounts as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyAmount(inner) => {
                    <EmptyAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyBase(inner) => {
                    <EmptyBase as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyBorrowAmounts(inner) => {
                    <EmptyBorrowAmounts as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyBurnAmounts(inner) => {
                    <EmptyBurnAmounts as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyCollateral(inner) => {
                    <EmptyCollateral as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyConfiguration(inner) => {
                    <EmptyConfiguration as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyDepositAmounts(inner) => {
                    <EmptyDepositAmounts as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyHoldingAddress(inner) => {
                    <EmptyHoldingAddress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyInterestRateStrategy(inner) => {
                    <EmptyInterestRateStrategy as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyMintAmounts(inner) => {
                    <EmptyMintAmounts as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyPool(inner) => {
                    <EmptyPool as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyPoolKeys(inner) => {
                    <EmptyPoolKeys as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyPosition(inner) => {
                    <EmptyPosition as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyPositions(inner) => {
                    <EmptyPositions as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyReceiver(inner) => {
                    <EmptyReceiver as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyRemoveAmounts(inner) => {
                    <EmptyRemoveAmounts as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyRepayAmounts(inner) => {
                    <EmptyRepayAmounts as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptySwapInAmount(inner) => {
                    <EmptySwapInAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptySwapOutAmount(inner) => {
                    <EmptySwapOutAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyTokenBase(inner) => {
                    <EmptyTokenBase as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyTokenTranferGasLimit(inner) => {
                    <EmptyTokenTranferGasLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyTreasury(inner) => {
                    <EmptyTreasury as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EmptyUnclaimedFee(inner) => {
                    <EmptyUnclaimedFee as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmptyWithdrawAmounts(inner) => {
                    <EmptyWithdrawAmounts as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ErrorStep(inner) => {
                    <ErrorStep as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientAvailableLiquidity(inner) => {
                    <InsufficientAvailableLiquidity as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientCollateralAmount(inner) => {
                    <InsufficientCollateralAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientCollateralAmountForRepay(inner) => {
                    <InsufficientCollateralAmountForRepay as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientCollateralForWidthdraw(inner) => {
                    <InsufficientCollateralForWidthdraw as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientReverveForBorrow(inner) => {
                    <InsufficientReverveForBorrow as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientSwapAmount(inner) => {
                    <InsufficientSwapAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientSwapCollateral(inner) => {
                    <InsufficientSwapCollateral as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientUserBalance(inner) => {
                    <InsufficientUserBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidBorrowCapacity(inner) => {
                    <InvalidBorrowCapacity as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidDecimals(inner) => {
                    <InvalidDecimals as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidFeeFactor(inner) => {
                    <InvalidFeeFactor as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNativeTokenSender(inner) => {
                    <InvalidNativeTokenSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidOptimalUsageRate(inner) => {
                    <InvalidOptimalUsageRate as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidPoolIndex(inner) => {
                    <InvalidPoolIndex as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidSupplyCapacity(inner) => {
                    <InvalidSupplyCapacity as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MarginAboveThreshold(inner) => {
                    <MarginAboveThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MarginBelowThreshold(inner) => {
                    <MarginBelowThreshold as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MaxDepositExceeds(inner) => {
                    <MaxDepositExceeds as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MaxPositionId(inner) => {
                    <MaxPositionId as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::PoolAlreadyExists(inner) => {
                    <PoolAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PositionNotFound(inner) => {
                    <PositionNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RequestedAmount1ExceedsPriceLimit(inner) => {
                    <RequestedAmount1ExceedsPriceLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RequestedAmountOExceedsPriceLimit(inner) => {
                    <RequestedAmountOExceedsPriceLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Reserve0Insufficient(inner) => {
                    <Reserve0Insufficient as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Reserve1Insufficient(inner) => {
                    <Reserve1Insufficient as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SelfTransferNotSupported(inner) => {
                    <SelfTransferNotSupported as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SingleTokenInOutSwapOnly(inner) => {
                    <SingleTokenInOutSwapOnly as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ThereMustBeAtLeastOneRoleAdmin(inner) => {
                    <ThereMustBeAtLeastOneRoleAdmin as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ThereMustBeAtLeastOneTimelockMultiSig(inner) => {
                    <ThereMustBeAtLeastOneTimelockMultiSig as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TokenIndexNotSupport(inner) => {
                    <TokenIndexNotSupport as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TokenTransferError(inner) => {
                    <TokenTransferError as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TokensNotMatch(inner) => {
                    <TokensNotMatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::UsdCollateralCanNotCoverDebt(inner) => {
                    <UsdCollateralCanNotCoverDebt as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UserDoNotHaveDebtInPosition(inner) => {
                    <UserDoNotHaveDebtInPosition as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::liquidityDidNotReachShortThreshord(inner) => {
                    <liquidityDidNotReachShortThreshord as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccountNotMatch(inner) => {
                    <AccountNotMatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Balance1Insufficient(inner) => {
                    <Balance1Insufficient as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ClosePercentageExceeding(inner) => {
                    <ClosePercentageExceeding as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CollateralCanNotCoverDebt(inner) => {
                    <CollateralCanNotCoverDebt as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CompactedArrayOutOfBounds(inner) => {
                    <CompactedArrayOutOfBounds as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CouldNotSendNativeToken(inner) => {
                    <CouldNotSendNativeToken as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DebtTokenOperationNotSupported(inner) => {
                    <DebtTokenOperationNotSupported as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyAccount(inner) => {
                    <EmptyAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyAddAmounts(inner) => {
                    <EmptyAddAmounts as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyAmount(inner) => {
                    <EmptyAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyBase(inner) => {
                    <EmptyBase as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::EmptyBorrowAmounts(inner) => {
                    <EmptyBorrowAmounts as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyBurnAmounts(inner) => {
                    <EmptyBurnAmounts as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyCollateral(inner) => {
                    <EmptyCollateral as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyConfiguration(inner) => {
                    <EmptyConfiguration as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyDepositAmounts(inner) => {
                    <EmptyDepositAmounts as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyHoldingAddress(inner) => {
                    <EmptyHoldingAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyInterestRateStrategy(inner) => {
                    <EmptyInterestRateStrategy as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyMintAmounts(inner) => {
                    <EmptyMintAmounts as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyPool(inner) => {
                    <EmptyPool as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::EmptyPoolKeys(inner) => {
                    <EmptyPoolKeys as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyPosition(inner) => {
                    <EmptyPosition as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyPositions(inner) => {
                    <EmptyPositions as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyReceiver(inner) => {
                    <EmptyReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyRemoveAmounts(inner) => {
                    <EmptyRemoveAmounts as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyRepayAmounts(inner) => {
                    <EmptyRepayAmounts as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptySwapInAmount(inner) => {
                    <EmptySwapInAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptySwapOutAmount(inner) => {
                    <EmptySwapOutAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyTokenBase(inner) => {
                    <EmptyTokenBase as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyTokenTranferGasLimit(inner) => {
                    <EmptyTokenTranferGasLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyTreasury(inner) => {
                    <EmptyTreasury as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyUnclaimedFee(inner) => {
                    <EmptyUnclaimedFee as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmptyWithdrawAmounts(inner) => {
                    <EmptyWithdrawAmounts as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ErrorStep(inner) => {
                    <ErrorStep as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InsufficientAvailableLiquidity(inner) => {
                    <InsufficientAvailableLiquidity as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientCollateralAmount(inner) => {
                    <InsufficientCollateralAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientCollateralAmountForRepay(inner) => {
                    <InsufficientCollateralAmountForRepay as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientCollateralForWidthdraw(inner) => {
                    <InsufficientCollateralForWidthdraw as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientReverveForBorrow(inner) => {
                    <InsufficientReverveForBorrow as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientSwapAmount(inner) => {
                    <InsufficientSwapAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientSwapCollateral(inner) => {
                    <InsufficientSwapCollateral as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientUserBalance(inner) => {
                    <InsufficientUserBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidBorrowCapacity(inner) => {
                    <InvalidBorrowCapacity as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDecimals(inner) => {
                    <InvalidDecimals as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidFeeFactor(inner) => {
                    <InvalidFeeFactor as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNativeTokenSender(inner) => {
                    <InvalidNativeTokenSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidOptimalUsageRate(inner) => {
                    <InvalidOptimalUsageRate as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidPoolIndex(inner) => {
                    <InvalidPoolIndex as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSupplyCapacity(inner) => {
                    <InvalidSupplyCapacity as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MarginAboveThreshold(inner) => {
                    <MarginAboveThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MarginBelowThreshold(inner) => {
                    <MarginBelowThreshold as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MaxDepositExceeds(inner) => {
                    <MaxDepositExceeds as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MaxPositionId(inner) => {
                    <MaxPositionId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PoolAlreadyExists(inner) => {
                    <PoolAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PositionNotFound(inner) => {
                    <PositionNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RequestedAmount1ExceedsPriceLimit(inner) => {
                    <RequestedAmount1ExceedsPriceLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RequestedAmountOExceedsPriceLimit(inner) => {
                    <RequestedAmountOExceedsPriceLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Reserve0Insufficient(inner) => {
                    <Reserve0Insufficient as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Reserve1Insufficient(inner) => {
                    <Reserve1Insufficient as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SelfTransferNotSupported(inner) => {
                    <SelfTransferNotSupported as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SingleTokenInOutSwapOnly(inner) => {
                    <SingleTokenInOutSwapOnly as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ThereMustBeAtLeastOneRoleAdmin(inner) => {
                    <ThereMustBeAtLeastOneRoleAdmin as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ThereMustBeAtLeastOneTimelockMultiSig(inner) => {
                    <ThereMustBeAtLeastOneTimelockMultiSig as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TokenIndexNotSupport(inner) => {
                    <TokenIndexNotSupport as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TokenTransferError(inner) => {
                    <TokenTransferError as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TokensNotMatch(inner) => {
                    <TokensNotMatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UsdCollateralCanNotCoverDebt(inner) => {
                    <UsdCollateralCanNotCoverDebt as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UserDoNotHaveDebtInPosition(inner) => {
                    <UserDoNotHaveDebtInPosition as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::liquidityDidNotReachShortThreshord(inner) => {
                    <liquidityDidNotReachShortThreshord as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Errors`](self) contract instance.

See the [wrapper's documentation](`ErrorsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ErrorsInstance<T, P, N> {
        ErrorsInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<ErrorsInstance<T, P, N>>,
    > {
        ErrorsInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        ErrorsInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`Errors`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Errors`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ErrorsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ErrorsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ErrorsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ErrorsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Errors`](self) contract instance.

See the [wrapper's documentation](`ErrorsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<ErrorsInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ErrorsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ErrorsInstance<T, P, N> {
            ErrorsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ErrorsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ErrorsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
