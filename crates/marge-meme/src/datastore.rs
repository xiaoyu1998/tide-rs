/**

Generated by the following Solidity interface...
```solidity
interface DataStore {
    error SafeCastOverflowedIntToUint(int256 value);
    error Unauthorized(address msgSender, string role);

    constructor(address _roleStore);

    function addAddress(bytes32 setKey, address value) external;
    function addBytes32(bytes32 setKey, bytes32 value) external;
    function addUint(bytes32 setKey, uint256 value) external;
    function addressArrayValues(bytes32, uint256) external view returns (address);
    function addressValues(bytes32) external view returns (address);
    function applyBoundedDeltaToUint(bytes32 key, int256 value) external returns (uint256);
    function applyDeltaToInt(bytes32 key, int256 value) external returns (int256);
    function applyDeltaToUint(bytes32 key, int256 value, string memory errorMessage) external returns (uint256);
    function applyDeltaToUint(bytes32 key, uint256 value) external returns (uint256);
    function boolArrayValues(bytes32, uint256) external view returns (bool);
    function boolValues(bytes32) external view returns (bool);
    function bytes32ArrayValues(bytes32, uint256) external view returns (bytes32);
    function bytes32Values(bytes32) external view returns (bytes32);
    function containsAddress(bytes32 setKey, address value) external view returns (bool);
    function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool);
    function containsUint(bytes32 setKey, uint256 value) external view returns (bool);
    function decrementInt(bytes32 key, int256 value) external returns (int256);
    function decrementUint(bytes32 key, uint256 value) external returns (uint256);
    function getAddress(bytes32 key) external view returns (address);
    function getAddressArray(bytes32 key) external view returns (address[] memory);
    function getAddressCount(bytes32 setKey) external view returns (uint256);
    function getAddressValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (address[] memory);
    function getBool(bytes32 key) external view returns (bool);
    function getBoolArray(bytes32 key) external view returns (bool[] memory);
    function getBytes32(bytes32 key) external view returns (bytes32);
    function getBytes32Array(bytes32 key) external view returns (bytes32[] memory);
    function getBytes32Count(bytes32 setKey) external view returns (uint256);
    function getBytes32ValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (bytes32[] memory);
    function getInt(bytes32 key) external view returns (int256);
    function getIntArray(bytes32 key) external view returns (int256[] memory);
    function getString(bytes32 key) external view returns (string memory);
    function getStringArray(bytes32 key) external view returns (string[] memory);
    function getUint(bytes32 key) external view returns (uint256);
    function getUintArray(bytes32 key) external view returns (uint256[] memory);
    function getUintCount(bytes32 setKey) external view returns (uint256);
    function getUintValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (uint256[] memory);
    function incrementInt(bytes32 key, int256 value) external returns (int256);
    function incrementUint(bytes32 key, uint256 value) external returns (uint256);
    function intArrayValues(bytes32, uint256) external view returns (int256);
    function intValues(bytes32) external view returns (int256);
    function removeAddress(bytes32 setKey, address value) external;
    function removeAddress(bytes32 key) external;
    function removeAddressArray(bytes32 key) external;
    function removeBool(bytes32 key) external;
    function removeBoolArray(bytes32 key) external;
    function removeBytes32(bytes32 setKey, bytes32 value) external;
    function removeBytes32(bytes32 key) external;
    function removeBytes32Array(bytes32 key) external;
    function removeInt(bytes32 key) external;
    function removeIntArray(bytes32 key) external;
    function removeString(bytes32 key) external;
    function removeStringArray(bytes32 key) external;
    function removeUint(bytes32 key) external;
    function removeUint(bytes32 setKey, uint256 value) external;
    function removeUintArray(bytes32 key) external;
    function roleStore() external view returns (address);
    function setAddress(bytes32 key, address value) external returns (address);
    function setAddressArray(bytes32 key, address[] memory value) external;
    function setBool(bytes32 key, bool value) external returns (bool);
    function setBoolArray(bytes32 key, bool[] memory value) external;
    function setBytes32(bytes32 key, bytes32 value) external returns (bytes32);
    function setBytes32Array(bytes32 key, bytes32[] memory value) external;
    function setInt(bytes32 key, int256 value) external returns (int256);
    function setIntArray(bytes32 key, int256[] memory value) external;
    function setString(bytes32 key, string memory value) external returns (string memory);
    function setStringArray(bytes32 key, string[] memory value) external;
    function setUint(bytes32 key, uint256 value) external returns (uint256);
    function setUintArray(bytes32 key, uint256[] memory value) external;
    function stringArrayValues(bytes32, uint256) external view returns (string memory);
    function stringValues(bytes32) external view returns (string memory);
    function uintArrayValues(bytes32, uint256) external view returns (uint256);
    function uintValues(bytes32) external view returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_roleStore",
        "type": "address",
        "internalType": "contract RoleStore"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addAddress",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addBytes32",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addUint",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addressArrayValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "addressValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "applyBoundedDeltaToUint",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "applyDeltaToInt",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "applyDeltaToUint",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "errorMessage",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "applyDeltaToUint",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "boolArrayValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "boolValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bytes32ArrayValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bytes32Values",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "containsAddress",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "containsBytes32",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "containsUint",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decrementInt",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "decrementUint",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getAddress",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAddressArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAddressCount",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAddressValuesAt",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "start",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "end",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBool",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBoolArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBytes32",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBytes32Array",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBytes32Count",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBytes32ValuesAt",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "start",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "end",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getInt",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getIntArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getString",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getStringArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUint",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUintArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUintCount",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getUintValuesAt",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "start",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "end",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "incrementInt",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "incrementUint",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "intArrayValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "intValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeAddress",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeAddress",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeAddressArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeBool",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeBoolArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeBytes32",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeBytes32",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeBytes32Array",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeInt",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeIntArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeString",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeStringArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeUint",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeUint",
    "inputs": [
      {
        "name": "setKey",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeUintArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "roleStore",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract RoleStore"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setAddress",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAddressArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBool",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBoolArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBytes32",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBytes32Array",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setInt",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setIntArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setString",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setStringArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setUint",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setUintArray",
    "inputs": [
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "value",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stringArrayValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "stringValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "uintArrayValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "uintValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "error",
    "name": "SafeCastOverflowedIntToUint",
    "inputs": [
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ]
  },
  {
    "type": "error",
    "name": "Unauthorized",
    "inputs": [
      {
        "name": "msgSender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "role",
        "type": "string",
        "internalType": "string"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod DataStore {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a0604052348015600e575f5ffd5b506040516128ab3803806128ab833981016040819052602b91603b565b6001600160a01b03166080526066565b5f60208284031215604a575f5ffd5b81516001600160a01b0381168114605f575f5ffd5b9392505050565b6080516128266100855f395f8181610617015261180a01526128265ff3fe608060405234801561000f575f5ffd5b5060043610610417575f3560e01c80639921c3cc11610221578063cbb093dd1161012a578063e4e36c4e116100b4578063ec672cf611610084578063ec672cf614610a27578063f069052a14610a3a578063f15caeac14610a4d578063f3903b9f14610a60578063f51fc0d914610a73575f5ffd5b8063e4e36c4e1461091f578063e62461ce146109ee578063e7e4148e14610a01578063e98aabc114610a14575f5ffd5b8063d52852af116100fa578063d52852af14610977578063dc97d96214610996578063dd031997146109b5578063e208a70d146109c8578063e2a4853a146109db575f5ffd5b8063cbb093dd1461091f578063cc50eadd14610932578063cf6a872214610945578063d38eebc714610958575f5ffd5b8063bd02d0f5116101ab578063c1dc91821161017b578063c1dc9182146108c0578063c4f00fde146108d3578063c769d1a1146108e6578063c80f4c62146108f9578063ca446dd91461090c575f5ffd5b8063bd02d0f514610868578063be43caa314610887578063bf498dd31461089a578063bf7f035a146108ad575f5ffd5b8063a9fcf76b116101f1578063a9fcf76b14610809578063abfdcced1461081c578063adb353dc1461082f578063b348e63914610842578063b8320a0814610855575f5ffd5b80639921c3cc146107b15780639faf6fb6146107c45780639fe7ac12146107d7578063a6ed563e146107ea575f5ffd5b80634a4a7b0411610323578063743df325116102ad57806388021a721161027d57806388021a72146107525780638ca498b01461076557806391d4403c1461077857806393266f9a1461078b578063986e791a1461079e575f5ffd5b8063743df325146106eb5780637ae1cfca1461070a57806380aacdcd1461072c57806386ac6bdf1461073f575f5ffd5b80636339734d116102f35780636339734d1461067f57806369721d41146106925780636e899550146106a55780636fae54f0146106c55780637026d42c146106d8575f5ffd5b80634a4a7b04146106125780634e91db08146106395780635948f7331461064c5780635eb07dbd1461066c575f5ffd5b806332f85bbf116103a45780633dbacd1a116103745780633dbacd1a146105a45780633e49bed0146105b757806342c3bd96146105ca57806344a242b1146105dd578063499ea50e146105ff575f5ffd5b806332f85bbf14610558578063340dbab31461056b57806335d4d4071461057e57806335ea805914610591575f5ffd5b806322538dae116103ea57806322538dae146104c557806322f87464146104ed57806326004846146105005780632d2899b614610515578063310b888214610535575f5ffd5b806301677da21461041b578063065f21a714610444578063116bb9291461046557806321f8a72114610485575b5f5ffd5b61042e610429366004611f6a565b610a86565b60405161043b9190611faf565b60405180910390f35b610457610452366004611f6a565b610b6b565b60405190815260200161043b565b610478610473366004611f6a565b610b87565b60405161043b9190612012565b6104ad610493366004611f6a565b5f908152600260205260409020546001600160a01b031690565b6040516001600160a01b03909116815260200161043b565b6104ad6104d3366004611f6a565b60026020525f90815260409020546001600160a01b031681565b6104ad6104fb366004612056565b610c05565b61051361050e3660046120dc565b610c39565b005b610528610523366004611f6a565b610cac565b60405161043b919061217d565b610548610543366004612056565b610d0a565b604051901515815260200161043b565b61045761056636600461221f565b610d28565b610457610579366004612056565b610db5565b61051361058c366004612277565b610dfa565b61045761059f366004611f6a565b610e2a565b6104576105b2366004612056565b610e40565b6104576105c5366004612056565b610e86565b6105136105d8366004611f6a565b610eae565b6105486105eb366004611f6a565b60036020525f908152604090205460ff1681565b61051361060d366004611f6a565b610ed0565b6104ad7f000000000000000000000000000000000000000000000000000000000000000081565b610457610647366004612056565b610efb565b61065f61065a366004611f6a565b610f23565b60405161043b919061230e565b61051361067a3660046120dc565b610f8b565b61045761068d366004612056565b610fbb565b6105136106a0366004612369565b610fe6565b6106b86106b3366004612393565b61100f565b60405161043b91906123d6565b6104576106d3366004612056565b611042565b6105286106e63660046123e8565b611087565b6104576106f9366004611f6a565b60016020525f908152604090205481565b610548610718366004611f6a565b5f9081526003602052604090205460ff1690565b61054861073a366004612056565b6110aa565b61052861074d366004611f6a565b6110e8565b610513610760366004612411565b611145565b610457610773366004612056565b611175565b610548610786366004612056565b6111d6565b610513610799366004612056565b6111ed565b6106b86107ac366004611f6a565b611216565b6105136107bf366004612056565b6112ab565b6105136107d2366004611f6a565b6112d4565b6105136107e5366004611f6a565b611303565b6104576107f8366004611f6a565b5f9081526005602052604090205490565b6105136108173660046120dc565b61132c565b61054861082a3660046124cc565b61135c565b61051361083d366004612056565b61138d565b610513610850366004612369565b6113b6565b6106b8610863366004612056565b6113df565b610457610876366004611f6a565b5f9081526020819052604090205490565b610513610895366004611f6a565b611490565b6104576108a8366004612056565b6114b8565b6105136108bb366004611f6a565b6114d1565b6105136108ce366004611f6a565b6114f9565b6104576108e1366004612056565b611521565b6105486108f4366004612369565b61153a565b610513610907366004612056565b611551565b6104ad61091a366004612369565b61157a565b61045761092d366004612056565b6115b8565b610513610940366004611f6a565b6115e4565b610513610953366004611f6a565b61160c565b610457610966366004611f6a565b5f6020819052908152604090205481565b610457610985366004611f6a565b60056020525f908152604090205481565b6104576109a4366004611f6a565b5f9081526001602052604090205490565b6105286109c3366004611f6a565b61162e565b6105136109d6366004611f6a565b61168b565b6104576109e9366004612056565b6116b3565b6105136109fc366004611f6a565b6116db565b61065f610a0f3660046123e8565b6116fd565b610457610a22366004612056565b611718565b610513610a353660046124fa565b611744565b610528610a483660046123e8565b611774565b6106b8610a5b366004611f6a565b61178f565b610457610a6e366004611f6a565b6117a7565b610513610a81366004611f6a565b6117bd565b6060600a5f8381526020019081526020015f20805480602002602001604051908101604052809291908181526020015f905b82821015610b60578382905f5260205f20018054610ad59061258f565b80601f0160208091040260200160405190810160405280929190818152602001828054610b019061258f565b8015610b4c5780601f10610b2357610100808354040283529160200191610b4c565b820191905f5260205f20905b815481529060010190602001808311610b2f57829003601f168201915b505050505081526020019060010190610ab8565b505050509050919050565b5f818152600e60205260408120610b81906117e5565b92915050565b5f81815260096020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f20905f905b825461010083900a900460ff161515815260206001928301818104948501949093039092029101808411610bc85790505b50505050509050919050565b6008602052815f5260405f208181548110610c1e575f80fd5b5f918252602090912001546001600160a01b03169150829050565b610c89604051602001610c4b906125c7565b604051602081830303815290604052805190602001206040518060400160405280600a81526020016921a7a72a2927a62622a960b11b8152506117ee565b5f828152600b602090815260409091208251610ca792840190611d2c565b505050565b5f81815260076020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f20905b815481526020019060010190808311610ceb5750505050509050919050565b5f828152600e60205260408120610d2190836118a0565b9392505050565b5f610d3b604051602001610c4b906125c7565b5f848152602081905260408120549084128015610d67575080610d65610d60866125ff565b6118b7565b115b15610d8f578260405162461bcd60e51b8152600401610d8691906123d6565b60405180910390fd5b5f610d9a82866118e0565b5f878152602081905260409020819055925050509392505050565b5f610dc8604051602001610c4b906125c7565b5f83815260208190526040812054610de1908490612619565b5f85815260208190526040902081905591505092915050565b610e0c604051602001610c4b906125c7565b5f8281526009602090815260409091208251610ca792840190611d71565b5f818152600d60205260408120610b81906117e5565b5f610e53604051602001610c4b906125c7565b5f8381526020819052604081205490610e6c8483612619565b5f8681526020819052604090208190559250505092915050565b5f610e99604051602001610c4b906125c7565b505f9182526001602052604090912081905590565b610ec0604051602001610c4b906125c7565b5f90815260208190526040812055565b610ee2604051602001610c4b906125c7565b5f818152600760205260408120610ef891611e0c565b50565b5f610f0e604051602001610c4b906125c7565b505f9182526005602052604090912081905590565b5f81815260086020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f20905b81546001600160a01b03168152600190910190602001808311610f625750505050509050919050565b610f9d604051602001610c4b906125c7565b5f8281526006602090815260409091208251610ca792840190611d2c565b6007602052815f5260405f208181548110610fd4575f80fd5b905f5260205f20015f91509150505481565b610ff8604051602001610c4b906125c7565b5f828152600d60205260409020610ca79082611916565b6060611023604051602001610c4b906125c7565b5f83815260046020526040902061103a8382612677565b509092915050565b5f611055604051602001610c4b906125c7565b5f8381526001602052604081205461106e908490612731565b5f85815260016020526040902081905591505092915050565b5f838152600e602052604090206060906110a290848461192a565b949350505050565b6009602052815f5260405f2081815481106110c3575f80fd5b905f5260205f209060209182820401919006915091509054906101000a900460ff1681565b5f81815260066020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f2090815481526020019060010190808311610ceb5750505050509050919050565b611157604051602001610c4b906125c7565b5f828152600a602090815260409091208251610ca792840190611e27565b5f611188604051602001610c4b906125c7565b5f8381526020819052604081205490831280156111af5750806111ad610d60856125ff565b115b156111cb5750505f828152602081905260408120819055610b81565b5f610e6c82856118e0565b5f828152600c60205260408120610d2190836118a0565b6111ff604051602001610c4b906125c7565b5f828152600e60205260409020610ca79082611a01565b5f8181526004602052604090208054606091906112329061258f565b80601f016020809104026020016040519081016040528092919081815260200182805461125e9061258f565b8015610bf95780601f1061128057610100808354040283529160200191610bf9565b820191905f5260205f20905b81548152906001019060200180831161128c5750939695505050505050565b6112bd604051602001610c4b906125c7565b5f828152600c60205260409020610ca79082611a01565b6112e6604051602001610c4b906125c7565b5f90815260026020526040902080546001600160a01b0319169055565b611315604051602001610c4b906125c7565b5f908152600360205260409020805460ff19169055565b61133e604051602001610c4b906125c7565b5f8281526007602090815260409091208251610ca792840190611d2c565b5f61136f604051602001610c4b906125c7565b505f91825260036020526040909120805460ff191682151517905590565b61139f604051602001610c4b906125c7565b5f828152600e60205260409020610ca79082611a0c565b6113c8604051602001610c4b906125c7565b5f828152600d60205260409020610ca79082611a17565b600a602052815f5260405f2081815481106113f8575f80fd5b905f5260205f20015f915091505080546114119061258f565b80601f016020809104026020016040519081016040528092919081815260200182805461143d9061258f565b80156114885780601f1061145f57610100808354040283529160200191611488565b820191905f5260205f20905b81548152906001019060200180831161146b57829003601f168201915b505050505081565b6114a2604051602001610c4b906125c7565b5f818152600660205260408120610ef891611e0c565b600b602052815f5260405f208181548110610fd4575f80fd5b6114e3604051602001610c4b906125c7565b5f818152600b60205260408120610ef891611e0c565b61150b604051602001610c4b906125c7565b5f818152600860205260408120610ef891611e0c565b6006602052815f5260405f208181548110610fd4575f80fd5b5f828152600d60205260408120610d219083611a2b565b611563604051602001610c4b906125c7565b5f828152600c60205260409020610ca79082611a0c565b5f61158d604051602001610c4b906125c7565b505f9182526002602052604090912080546001600160a01b0319166001600160a01b03831617905590565b5f6115cb604051602001610c4b906125c7565b5f8381526001602052604081205461106e908490612750565b6115f6604051602001610c4b906125c7565b5f818152600460205260408120610ef891611e77565b61161e604051602001610c4b906125c7565b5f90815260056020526040812055565b5f818152600b6020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f2090815481526020019060010190808311610ceb5750505050509050919050565b61169d604051602001610c4b906125c7565b5f818152600a60205260408120610ef891611eae565b5f6116c6604051602001610c4b906125c7565b505f9182526020829052604090912081905590565b6116ed604051602001610c4b906125c7565b5f90815260016020526040812055565b5f838152600d602052604090206060906110a2908484611a4c565b5f61172b604051602001610c4b906125c7565b5f83815260208190526040812054610de1908490612777565b611756604051602001610c4b906125c7565b5f8281526008602090815260409091208251610ca792840190611ec9565b5f838152600c602052604090206060906110a2908484611b03565b60046020525f9081526040902080546114119061258f565b5f818152600c60205260408120610b81906117e5565b6117cf604051602001610c4b906125c7565b5f818152600960205260408120610ef891611f1c565b5f610b81825490565b60405163ac4ab3fb60e01b8152336004820152602481018390527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063ac4ab3fb90604401602060405180830381865afa158015611857573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061187b919061278a565b61189c57338160405163a35b150b60e01b8152600401610d869291906127a5565b5050565b5f8181526001830160205260408120541515610d21565b5f5f8212156118dc57604051635467221960e11b815260048101839052602401610d86565b5090565b5f5f821315611903576118f282611bad565b6118fc9084612619565b9050610b81565b61190c82611bad565b610d219084612777565b5f610d21836001600160a01b038416611bbe565b6060611935846117e5565b831061194f5750604080515f815260208101909152610d21565b5f611959856117e5565b905080831115611967578092505b5f6119728585612777565b6001600160401b0381111561198957611989612076565b6040519080825280602002602001820160405280156119b2578160200160208202803683370190505b509050845b848110156119f7576119c98782611ca8565b826119d48884612777565b815181106119e4576119e46127c8565b60209081029190910101526001016119b7565b5095945050505050565b5f610d218383611bbe565b5f610d218383611cb3565b5f610d21836001600160a01b038416611cb3565b6001600160a01b0381165f9081526001830160205260408120541515610d21565b60605f611a58856117e5565b905080831115611a66578092505b5f611a718585612777565b6001600160401b03811115611a8857611a88612076565b604051908082528060200260200182016040528015611ab1578160200160208202803683370190505b509050845b848110156119f757611ac88782611ca8565b82611ad38884612777565b81518110611ae357611ae36127c8565b6001600160a01b0390921660209283029190910190910152600101611ab6565b60605f611b0f856117e5565b905080831115611b1d578092505b5f611b288585612777565b6001600160401b03811115611b3f57611b3f612076565b604051908082528060200260200182016040528015611b68578160200160208202803683370190505b509050845b848110156119f757611b7f8782611cff565b82611b8a8884612777565b81518110611b9a57611b9a6127c8565b6020908102919091010152600101611b6d565b5f5f8212156118dc57815f03610b81565b5f8181526001830160205260408120548015611c98575f611be0600183612777565b85549091505f90611bf390600190612777565b9050808214611c52575f865f018281548110611c1157611c116127c8565b905f5260205f200154905080875f018481548110611c3157611c316127c8565b5f918252602080832090910192909255918252600188019052604090208390555b8554869080611c6357611c636127dc565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f905560019350505050610b81565b5f915050610b81565b5092915050565b5f610d218383611d06565b5f818152600183016020526040812054611cf857508154600181810184555f848152602080822090930184905584548482528286019093526040902091909155610b81565b505f610b81565b5f610d2183835b5f825f018281548110611d1b57611d1b6127c8565b905f5260205f200154905092915050565b828054828255905f5260205f20908101928215611d65579160200282015b82811115611d65578251825591602001919060010190611d4a565b506118dc929150611f3a565b828054828255905f5260205f2090601f01602090048101928215611d65579160200282015f5b83821115611dd357835183826101000a81548160ff02191690831515021790555092602001926001016020815f01049283019260010302611d97565b8015611dff5782816101000a81549060ff02191690556001016020815f01049283019260010302611dd3565b50506118dc929150611f3a565b5080545f8255905f5260205f2090810190610ef89190611f3a565b828054828255905f5260205f20908101928215611e6b579160200282015b82811115611e6b5782518290611e5b9082612677565b5091602001919060010190611e45565b506118dc929150611f4e565b508054611e839061258f565b5f825580601f10611e92575050565b601f0160209004905f5260205f2090810190610ef89190611f3a565b5080545f8255905f5260205f2090810190610ef89190611f4e565b828054828255905f5260205f20908101928215611d65579160200282015b82811115611d6557825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190611ee7565b5080545f8255601f0160209004905f5260205f2090810190610ef891905b5b808211156118dc575f8155600101611f3b565b808211156118dc575f611f618282611e77565b50600101611f4e565b5f60208284031215611f7a575f5ffd5b5035919050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f602082016020835280845180835260408501915060408160051b8601019250602086015f5b8281101561200657603f19878603018452611ff1858351611f81565b94506020938401939190910190600101611fd5565b50929695505050505050565b602080825282518282018190525f918401906040840190835b8181101561204b578351151583526020938401939092019160010161202b565b509095945050505050565b5f5f60408385031215612067575f5ffd5b50508035926020909101359150565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b03811182821017156120b2576120b2612076565b604052919050565b5f6001600160401b038211156120d2576120d2612076565b5060051b60200190565b5f5f604083850312156120ed575f5ffd5b8235915060208301356001600160401b03811115612109575f5ffd5b8301601f81018513612119575f5ffd5b803561212c612127826120ba565b61208a565b8082825260208201915060208360051b85010192508783111561214d575f5ffd5b6020840193505b8284101561216f578335825260209384019390910190612154565b809450505050509250929050565b602080825282518282018190525f918401906040840190835b8181101561204b578351835260209384019390920191600101612196565b5f82601f8301126121c3575f5ffd5b81356001600160401b038111156121dc576121dc612076565b6121ef601f8201601f191660200161208a565b818152846020838601011115612203575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f5f5f60608486031215612231575f5ffd5b833592506020840135915060408401356001600160401b03811115612254575f5ffd5b612260868287016121b4565b9150509250925092565b8015158114610ef8575f5ffd5b5f5f60408385031215612288575f5ffd5b8235915060208301356001600160401b038111156122a4575f5ffd5b8301601f810185136122b4575f5ffd5b80356122c2612127826120ba565b8082825260208201915060208360051b8501019250878311156122e3575f5ffd5b6020840193505b8284101561216f5783356122fd8161226a565b8252602093840193909101906122ea565b602080825282518282018190525f918401906040840190835b8181101561204b5783516001600160a01b0316835260209384019390920191600101612327565b80356001600160a01b0381168114612364575f5ffd5b919050565b5f5f6040838503121561237a575f5ffd5b8235915061238a6020840161234e565b90509250929050565b5f5f604083850312156123a4575f5ffd5b8235915060208301356001600160401b038111156123c0575f5ffd5b6123cc858286016121b4565b9150509250929050565b602081525f610d216020830184611f81565b5f5f5f606084860312156123fa575f5ffd5b505081359360208301359350604090920135919050565b5f5f60408385031215612422575f5ffd5b8235915060208301356001600160401b0381111561243e575f5ffd5b8301601f8101851361244e575f5ffd5b803561245c612127826120ba565b8082825260208201915060208360051b85010192508783111561247d575f5ffd5b602084015b838110156124bd5780356001600160401b0381111561249f575f5ffd5b6124ae8a6020838901016121b4565b84525060209283019201612482565b50809450505050509250929050565b5f5f604083850312156124dd575f5ffd5b8235915060208301356124ef8161226a565b809150509250929050565b5f5f6040838503121561250b575f5ffd5b8235915060208301356001600160401b03811115612527575f5ffd5b8301601f81018513612537575f5ffd5b8035612545612127826120ba565b8082825260208201915060208360051b850101925087831115612566575f5ffd5b6020840193505b8284101561216f5761257e8461234e565b82526020938401939091019061256d565b600181811c908216806125a357607f821691505b6020821081036125c157634e487b7160e01b5f52602260045260245ffd5b50919050565b6020808252600a908201526921a7a72a2927a62622a960b11b604082015260600190565b634e487b7160e01b5f52601160045260245ffd5b5f600160ff1b8201612613576126136125eb565b505f0390565b80820180821115610b8157610b816125eb565b601f821115610ca757805f5260205f20601f840160051c810160208510156126515750805b601f840160051c820191505b81811015612670575f815560010161265d565b5050505050565b81516001600160401b0381111561269057612690612076565b6126a48161269e845461258f565b8461262c565b6020601f8211600181146126d6575f83156126bf5750848201515b5f19600385901b1c1916600184901b178455612670565b5f84815260208120601f198516915b8281101561270557878501518255602094850194600190920191016126e5565b508482101561272257868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b8181035f831280158383131683831282161715611ca157611ca16125eb565b8082018281125f83128015821682158216171561276f5761276f6125eb565b505092915050565b81810381811115610b8157610b816125eb565b5f6020828403121561279a575f5ffd5b8151610d218161226a565b6001600160a01b03831681526040602082018190525f906110a290830184611f81565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52603160045260245ffdfea264697066735822122044f84de08dbe23ac2069566d437f01a2296818acc38b3d48ba480c04f7ec144164736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4\x80\x15`\x0EW__\xFD[P`@Qa(\xAB8\x03\x80a(\xAB\x839\x81\x01`@\x81\x90R`+\x91`;V[`\x01`\x01`\xA0\x1B\x03\x16`\x80R`fV[_` \x82\x84\x03\x12\x15`JW__\xFD[\x81Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14`_W__\xFD[\x93\x92PPPV[`\x80Qa(&a\0\x85_9_\x81\x81a\x06\x17\x01Ra\x18\n\x01Ra(&_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x04\x17W_5`\xE0\x1C\x80c\x99!\xC3\xCC\x11a\x02!W\x80c\xCB\xB0\x93\xDD\x11a\x01*W\x80c\xE4\xE3lN\x11a\0\xB4W\x80c\xECg,\xF6\x11a\0\x84W\x80c\xECg,\xF6\x14a\n'W\x80c\xF0i\x05*\x14a\n:W\x80c\xF1\\\xAE\xAC\x14a\nMW\x80c\xF3\x90;\x9F\x14a\n`W\x80c\xF5\x1F\xC0\xD9\x14a\nsW__\xFD[\x80c\xE4\xE3lN\x14a\t\x1FW\x80c\xE6$a\xCE\x14a\t\xEEW\x80c\xE7\xE4\x14\x8E\x14a\n\x01W\x80c\xE9\x8A\xAB\xC1\x14a\n\x14W__\xFD[\x80c\xD5(R\xAF\x11a\0\xFAW\x80c\xD5(R\xAF\x14a\twW\x80c\xDC\x97\xD9b\x14a\t\x96W\x80c\xDD\x03\x19\x97\x14a\t\xB5W\x80c\xE2\x08\xA7\r\x14a\t\xC8W\x80c\xE2\xA4\x85:\x14a\t\xDBW__\xFD[\x80c\xCB\xB0\x93\xDD\x14a\t\x1FW\x80c\xCCP\xEA\xDD\x14a\t2W\x80c\xCFj\x87\"\x14a\tEW\x80c\xD3\x8E\xEB\xC7\x14a\tXW__\xFD[\x80c\xBD\x02\xD0\xF5\x11a\x01\xABW\x80c\xC1\xDC\x91\x82\x11a\x01{W\x80c\xC1\xDC\x91\x82\x14a\x08\xC0W\x80c\xC4\xF0\x0F\xDE\x14a\x08\xD3W\x80c\xC7i\xD1\xA1\x14a\x08\xE6W\x80c\xC8\x0FLb\x14a\x08\xF9W\x80c\xCADm\xD9\x14a\t\x0CW__\xFD[\x80c\xBD\x02\xD0\xF5\x14a\x08hW\x80c\xBEC\xCA\xA3\x14a\x08\x87W\x80c\xBFI\x8D\xD3\x14a\x08\x9AW\x80c\xBF\x7F\x03Z\x14a\x08\xADW__\xFD[\x80c\xA9\xFC\xF7k\x11a\x01\xF1W\x80c\xA9\xFC\xF7k\x14a\x08\tW\x80c\xAB\xFD\xCC\xED\x14a\x08\x1CW\x80c\xAD\xB3S\xDC\x14a\x08/W\x80c\xB3H\xE69\x14a\x08BW\x80c\xB82\n\x08\x14a\x08UW__\xFD[\x80c\x99!\xC3\xCC\x14a\x07\xB1W\x80c\x9F\xAFo\xB6\x14a\x07\xC4W\x80c\x9F\xE7\xAC\x12\x14a\x07\xD7W\x80c\xA6\xEDV>\x14a\x07\xEAW__\xFD[\x80cJJ{\x04\x11a\x03#W\x80ct=\xF3%\x11a\x02\xADW\x80c\x88\x02\x1Ar\x11a\x02}W\x80c\x88\x02\x1Ar\x14a\x07RW\x80c\x8C\xA4\x98\xB0\x14a\x07eW\x80c\x91\xD4@<\x14a\x07xW\x80c\x93&o\x9A\x14a\x07\x8BW\x80c\x98ny\x1A\x14a\x07\x9EW__\xFD[\x80ct=\xF3%\x14a\x06\xEBW\x80cz\xE1\xCF\xCA\x14a\x07\nW\x80c\x80\xAA\xCD\xCD\x14a\x07,W\x80c\x86\xACk\xDF\x14a\x07?W__\xFD[\x80cc9sM\x11a\x02\xF3W\x80cc9sM\x14a\x06\x7FW\x80cir\x1DA\x14a\x06\x92W\x80cn\x89\x95P\x14a\x06\xA5W\x80co\xAET\xF0\x14a\x06\xC5W\x80cp&\xD4,\x14a\x06\xD8W__\xFD[\x80cJJ{\x04\x14a\x06\x12W\x80cN\x91\xDB\x08\x14a\x069W\x80cYH\xF73\x14a\x06LW\x80c^\xB0}\xBD\x14a\x06lW__\xFD[\x80c2\xF8[\xBF\x11a\x03\xA4W\x80c=\xBA\xCD\x1A\x11a\x03tW\x80c=\xBA\xCD\x1A\x14a\x05\xA4W\x80c>I\xBE\xD0\x14a\x05\xB7W\x80cB\xC3\xBD\x96\x14a\x05\xCAW\x80cD\xA2B\xB1\x14a\x05\xDDW\x80cI\x9E\xA5\x0E\x14a\x05\xFFW__\xFD[\x80c2\xF8[\xBF\x14a\x05XW\x80c4\r\xBA\xB3\x14a\x05kW\x80c5\xD4\xD4\x07\x14a\x05~W\x80c5\xEA\x80Y\x14a\x05\x91W__\xFD[\x80c\"S\x8D\xAE\x11a\x03\xEAW\x80c\"S\x8D\xAE\x14a\x04\xC5W\x80c\"\xF8td\x14a\x04\xEDW\x80c&\0HF\x14a\x05\0W\x80c-(\x99\xB6\x14a\x05\x15W\x80c1\x0B\x88\x82\x14a\x055W__\xFD[\x80c\x01g}\xA2\x14a\x04\x1BW\x80c\x06_!\xA7\x14a\x04DW\x80c\x11k\xB9)\x14a\x04eW\x80c!\xF8\xA7!\x14a\x04\x85W[__\xFD[a\x04.a\x04)6`\x04a\x1FjV[a\n\x86V[`@Qa\x04;\x91\x90a\x1F\xAFV[`@Q\x80\x91\x03\x90\xF3[a\x04Wa\x04R6`\x04a\x1FjV[a\x0BkV[`@Q\x90\x81R` \x01a\x04;V[a\x04xa\x04s6`\x04a\x1FjV[a\x0B\x87V[`@Qa\x04;\x91\x90a \x12V[a\x04\xADa\x04\x936`\x04a\x1FjV[_\x90\x81R`\x02` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x04;V[a\x04\xADa\x04\xD36`\x04a\x1FjV[`\x02` R_\x90\x81R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x04\xADa\x04\xFB6`\x04a VV[a\x0C\x05V[a\x05\x13a\x05\x0E6`\x04a \xDCV[a\x0C9V[\0[a\x05(a\x05#6`\x04a\x1FjV[a\x0C\xACV[`@Qa\x04;\x91\x90a!}V[a\x05Ha\x05C6`\x04a VV[a\r\nV[`@Q\x90\x15\x15\x81R` \x01a\x04;V[a\x04Wa\x05f6`\x04a\"\x1FV[a\r(V[a\x04Wa\x05y6`\x04a VV[a\r\xB5V[a\x05\x13a\x05\x8C6`\x04a\"wV[a\r\xFAV[a\x04Wa\x05\x9F6`\x04a\x1FjV[a\x0E*V[a\x04Wa\x05\xB26`\x04a VV[a\x0E@V[a\x04Wa\x05\xC56`\x04a VV[a\x0E\x86V[a\x05\x13a\x05\xD86`\x04a\x1FjV[a\x0E\xAEV[a\x05Ha\x05\xEB6`\x04a\x1FjV[`\x03` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[a\x05\x13a\x06\r6`\x04a\x1FjV[a\x0E\xD0V[a\x04\xAD\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x04Wa\x06G6`\x04a VV[a\x0E\xFBV[a\x06_a\x06Z6`\x04a\x1FjV[a\x0F#V[`@Qa\x04;\x91\x90a#\x0EV[a\x05\x13a\x06z6`\x04a \xDCV[a\x0F\x8BV[a\x04Wa\x06\x8D6`\x04a VV[a\x0F\xBBV[a\x05\x13a\x06\xA06`\x04a#iV[a\x0F\xE6V[a\x06\xB8a\x06\xB36`\x04a#\x93V[a\x10\x0FV[`@Qa\x04;\x91\x90a#\xD6V[a\x04Wa\x06\xD36`\x04a VV[a\x10BV[a\x05(a\x06\xE66`\x04a#\xE8V[a\x10\x87V[a\x04Wa\x06\xF96`\x04a\x1FjV[`\x01` R_\x90\x81R`@\x90 T\x81V[a\x05Ha\x07\x186`\x04a\x1FjV[_\x90\x81R`\x03` R`@\x90 T`\xFF\x16\x90V[a\x05Ha\x07:6`\x04a VV[a\x10\xAAV[a\x05(a\x07M6`\x04a\x1FjV[a\x10\xE8V[a\x05\x13a\x07`6`\x04a$\x11V[a\x11EV[a\x04Wa\x07s6`\x04a VV[a\x11uV[a\x05Ha\x07\x866`\x04a VV[a\x11\xD6V[a\x05\x13a\x07\x996`\x04a VV[a\x11\xEDV[a\x06\xB8a\x07\xAC6`\x04a\x1FjV[a\x12\x16V[a\x05\x13a\x07\xBF6`\x04a VV[a\x12\xABV[a\x05\x13a\x07\xD26`\x04a\x1FjV[a\x12\xD4V[a\x05\x13a\x07\xE56`\x04a\x1FjV[a\x13\x03V[a\x04Wa\x07\xF86`\x04a\x1FjV[_\x90\x81R`\x05` R`@\x90 T\x90V[a\x05\x13a\x08\x176`\x04a \xDCV[a\x13,V[a\x05Ha\x08*6`\x04a$\xCCV[a\x13\\V[a\x05\x13a\x08=6`\x04a VV[a\x13\x8DV[a\x05\x13a\x08P6`\x04a#iV[a\x13\xB6V[a\x06\xB8a\x08c6`\x04a VV[a\x13\xDFV[a\x04Wa\x08v6`\x04a\x1FjV[_\x90\x81R` \x81\x90R`@\x90 T\x90V[a\x05\x13a\x08\x956`\x04a\x1FjV[a\x14\x90V[a\x04Wa\x08\xA86`\x04a VV[a\x14\xB8V[a\x05\x13a\x08\xBB6`\x04a\x1FjV[a\x14\xD1V[a\x05\x13a\x08\xCE6`\x04a\x1FjV[a\x14\xF9V[a\x04Wa\x08\xE16`\x04a VV[a\x15!V[a\x05Ha\x08\xF46`\x04a#iV[a\x15:V[a\x05\x13a\t\x076`\x04a VV[a\x15QV[a\x04\xADa\t\x1A6`\x04a#iV[a\x15zV[a\x04Wa\t-6`\x04a VV[a\x15\xB8V[a\x05\x13a\t@6`\x04a\x1FjV[a\x15\xE4V[a\x05\x13a\tS6`\x04a\x1FjV[a\x16\x0CV[a\x04Wa\tf6`\x04a\x1FjV[_` \x81\x90R\x90\x81R`@\x90 T\x81V[a\x04Wa\t\x856`\x04a\x1FjV[`\x05` R_\x90\x81R`@\x90 T\x81V[a\x04Wa\t\xA46`\x04a\x1FjV[_\x90\x81R`\x01` R`@\x90 T\x90V[a\x05(a\t\xC36`\x04a\x1FjV[a\x16.V[a\x05\x13a\t\xD66`\x04a\x1FjV[a\x16\x8BV[a\x04Wa\t\xE96`\x04a VV[a\x16\xB3V[a\x05\x13a\t\xFC6`\x04a\x1FjV[a\x16\xDBV[a\x06_a\n\x0F6`\x04a#\xE8V[a\x16\xFDV[a\x04Wa\n\"6`\x04a VV[a\x17\x18V[a\x05\x13a\n56`\x04a$\xFAV[a\x17DV[a\x05(a\nH6`\x04a#\xE8V[a\x17tV[a\x06\xB8a\n[6`\x04a\x1FjV[a\x17\x8FV[a\x04Wa\nn6`\x04a\x1FjV[a\x17\xA7V[a\x05\x13a\n\x816`\x04a\x1FjV[a\x17\xBDV[```\n_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x0B`W\x83\x82\x90_R` _ \x01\x80Ta\n\xD5\x90a%\x8FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x01\x90a%\x8FV[\x80\x15a\x0BLW\x80`\x1F\x10a\x0B#Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0BLV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B/W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01\x90`\x01\x01\x90a\n\xB8V[PPPP\x90P\x91\x90PV[_\x81\x81R`\x0E` R`@\x81 a\x0B\x81\x90a\x17\xE5V[\x92\x91PPV[_\x81\x81R`\t` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90_\x90[\x82Ta\x01\0\x83\x90\n\x90\x04`\xFF\x16\x15\x15\x81R` `\x01\x92\x83\x01\x81\x81\x04\x94\x85\x01\x94\x90\x93\x03\x90\x92\x02\x91\x01\x80\x84\x11a\x0B\xC8W\x90P[PPPPP\x90P\x91\x90PV[`\x08` R\x81_R`@_ \x81\x81T\x81\x10a\x0C\x1EW_\x80\xFD[_\x91\x82R` \x90\x91 \x01T`\x01`\x01`\xA0\x1B\x03\x16\x91P\x82\x90PV[a\x0C\x89`@Q` \x01a\x0CK\x90a%\xC7V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `@Q\x80`@\x01`@R\x80`\n\x81R` \x01i!\xA7\xA7*)'\xA6&\"\xA9`\xB1\x1B\x81RPa\x17\xEEV[_\x82\x81R`\x0B` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1D,V[PPPV[_\x81\x81R`\x07` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x0C\xEBWPPPPP\x90P\x91\x90PV[_\x82\x81R`\x0E` R`@\x81 a\r!\x90\x83a\x18\xA0V[\x93\x92PPPV[_a\r;`@Q` \x01a\x0CK\x90a%\xC7V[_\x84\x81R` \x81\x90R`@\x81 T\x90\x84\x12\x80\x15a\rgWP\x80a\rea\r`\x86a%\xFFV[a\x18\xB7V[\x11[\x15a\r\x8FW\x82`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\r\x86\x91\x90a#\xD6V[`@Q\x80\x91\x03\x90\xFD[_a\r\x9A\x82\x86a\x18\xE0V[_\x87\x81R` \x81\x90R`@\x90 \x81\x90U\x92PPP\x93\x92PPPV[_a\r\xC8`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R` \x81\x90R`@\x81 Ta\r\xE1\x90\x84\x90a&\x19V[_\x85\x81R` \x81\x90R`@\x90 \x81\x90U\x91PP\x92\x91PPV[a\x0E\x0C`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\t` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1DqV[_\x81\x81R`\r` R`@\x81 a\x0B\x81\x90a\x17\xE5V[_a\x0ES`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R` \x81\x90R`@\x81 T\x90a\x0El\x84\x83a&\x19V[_\x86\x81R` \x81\x90R`@\x90 \x81\x90U\x92PPP\x92\x91PPV[_a\x0E\x99`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R`\x01` R`@\x90\x91 \x81\x90U\x90V[a\x0E\xC0`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R` \x81\x90R`@\x81 UV[a\x0E\xE2`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x07` R`@\x81 a\x0E\xF8\x91a\x1E\x0CV[PV[_a\x0F\x0E`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R`\x05` R`@\x90\x91 \x81\x90U\x90V[_\x81\x81R`\x08` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90[\x81T`\x01`\x01`\xA0\x1B\x03\x16\x81R`\x01\x90\x91\x01\x90` \x01\x80\x83\x11a\x0FbWPPPPP\x90P\x91\x90PV[a\x0F\x9D`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x06` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1D,V[`\x07` R\x81_R`@_ \x81\x81T\x81\x10a\x0F\xD4W_\x80\xFD[\x90_R` _ \x01_\x91P\x91PPT\x81V[a\x0F\xF8`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\r` R`@\x90 a\x0C\xA7\x90\x82a\x19\x16V[``a\x10#`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R`\x04` R`@\x90 a\x10:\x83\x82a&wV[P\x90\x92\x91PPV[_a\x10U`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R`\x01` R`@\x81 Ta\x10n\x90\x84\x90a'1V[_\x85\x81R`\x01` R`@\x90 \x81\x90U\x91PP\x92\x91PPV[_\x83\x81R`\x0E` R`@\x90 ``\x90a\x10\xA2\x90\x84\x84a\x19*V[\x94\x93PPPPV[`\t` R\x81_R`@_ \x81\x81T\x81\x10a\x10\xC3W_\x80\xFD[\x90_R` _ \x90` \x91\x82\x82\x04\x01\x91\x90\x06\x91P\x91P\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[_\x81\x81R`\x06` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x0C\xEBWPPPPP\x90P\x91\x90PV[a\x11W`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\n` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1E'V[_a\x11\x88`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R` \x81\x90R`@\x81 T\x90\x83\x12\x80\x15a\x11\xAFWP\x80a\x11\xADa\r`\x85a%\xFFV[\x11[\x15a\x11\xCBWPP_\x82\x81R` \x81\x90R`@\x81 \x81\x90Ua\x0B\x81V[_a\x0El\x82\x85a\x18\xE0V[_\x82\x81R`\x0C` R`@\x81 a\r!\x90\x83a\x18\xA0V[a\x11\xFF`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x0E` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x01V[_\x81\x81R`\x04` R`@\x90 \x80T``\x91\x90a\x122\x90a%\x8FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x12^\x90a%\x8FV[\x80\x15a\x0B\xF9W\x80`\x1F\x10a\x12\x80Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B\xF9V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x12\x8CWP\x93\x96\x95PPPPPPV[a\x12\xBD`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x0C` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x01V[a\x12\xE6`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R`\x02` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UV[a\x13\x15`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R`\x03` R`@\x90 \x80T`\xFF\x19\x16\x90UV[a\x13>`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x07` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1D,V[_a\x13o`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R`\x03` R`@\x90\x91 \x80T`\xFF\x19\x16\x82\x15\x15\x17\x90U\x90V[a\x13\x9F`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x0E` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x0CV[a\x13\xC8`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\r` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x17V[`\n` R\x81_R`@_ \x81\x81T\x81\x10a\x13\xF8W_\x80\xFD[\x90_R` _ \x01_\x91P\x91PP\x80Ta\x14\x11\x90a%\x8FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x14=\x90a%\x8FV[\x80\x15a\x14\x88W\x80`\x1F\x10a\x14_Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x14\x88V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x14kW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[a\x14\xA2`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x06` R`@\x81 a\x0E\xF8\x91a\x1E\x0CV[`\x0B` R\x81_R`@_ \x81\x81T\x81\x10a\x0F\xD4W_\x80\xFD[a\x14\xE3`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x0B` R`@\x81 a\x0E\xF8\x91a\x1E\x0CV[a\x15\x0B`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x08` R`@\x81 a\x0E\xF8\x91a\x1E\x0CV[`\x06` R\x81_R`@_ \x81\x81T\x81\x10a\x0F\xD4W_\x80\xFD[_\x82\x81R`\r` R`@\x81 a\r!\x90\x83a\x1A+V[a\x15c`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x0C` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x0CV[_a\x15\x8D`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R`\x02` R`@\x90\x91 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x17\x90U\x90V[_a\x15\xCB`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R`\x01` R`@\x81 Ta\x10n\x90\x84\x90a'PV[a\x15\xF6`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x04` R`@\x81 a\x0E\xF8\x91a\x1EwV[a\x16\x1E`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R`\x05` R`@\x81 UV[_\x81\x81R`\x0B` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x0C\xEBWPPPPP\x90P\x91\x90PV[a\x16\x9D`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\n` R`@\x81 a\x0E\xF8\x91a\x1E\xAEV[_a\x16\xC6`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R` \x82\x90R`@\x90\x91 \x81\x90U\x90V[a\x16\xED`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R`\x01` R`@\x81 UV[_\x83\x81R`\r` R`@\x90 ``\x90a\x10\xA2\x90\x84\x84a\x1ALV[_a\x17+`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R` \x81\x90R`@\x81 Ta\r\xE1\x90\x84\x90a'wV[a\x17V`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x08` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1E\xC9V[_\x83\x81R`\x0C` R`@\x90 ``\x90a\x10\xA2\x90\x84\x84a\x1B\x03V[`\x04` R_\x90\x81R`@\x90 \x80Ta\x14\x11\x90a%\x8FV[_\x81\x81R`\x0C` R`@\x81 a\x0B\x81\x90a\x17\xE5V[a\x17\xCF`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\t` R`@\x81 a\x0E\xF8\x91a\x1F\x1CV[_a\x0B\x81\x82T\x90V[`@Qc\xACJ\xB3\xFB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x83\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90c\xACJ\xB3\xFB\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x18WW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18{\x91\x90a'\x8AV[a\x18\x9CW3\x81`@Qc\xA3[\x15\x0B`\xE0\x1B\x81R`\x04\x01a\r\x86\x92\x91\x90a'\xA5V[PPV[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x15\x15a\r!V[__\x82\x12\x15a\x18\xDCW`@QcTg\"\x19`\xE1\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\r\x86V[P\x90V[__\x82\x13\x15a\x19\x03Wa\x18\xF2\x82a\x1B\xADV[a\x18\xFC\x90\x84a&\x19V[\x90Pa\x0B\x81V[a\x19\x0C\x82a\x1B\xADV[a\r!\x90\x84a'wV[_a\r!\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x1B\xBEV[``a\x195\x84a\x17\xE5V[\x83\x10a\x19OWP`@\x80Q_\x81R` \x81\x01\x90\x91Ra\r!V[_a\x19Y\x85a\x17\xE5V[\x90P\x80\x83\x11\x15a\x19gW\x80\x92P[_a\x19r\x85\x85a'wV[`\x01`\x01`@\x1B\x03\x81\x11\x15a\x19\x89Wa\x19\x89a vV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x19\xB2W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x84[\x84\x81\x10\x15a\x19\xF7Wa\x19\xC9\x87\x82a\x1C\xA8V[\x82a\x19\xD4\x88\x84a'wV[\x81Q\x81\x10a\x19\xE4Wa\x19\xE4a'\xC8V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x19\xB7V[P\x95\x94PPPPPV[_a\r!\x83\x83a\x1B\xBEV[_a\r!\x83\x83a\x1C\xB3V[_a\r!\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x1C\xB3V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x01\x83\x01` R`@\x81 T\x15\x15a\r!V[``_a\x1AX\x85a\x17\xE5V[\x90P\x80\x83\x11\x15a\x1AfW\x80\x92P[_a\x1Aq\x85\x85a'wV[`\x01`\x01`@\x1B\x03\x81\x11\x15a\x1A\x88Wa\x1A\x88a vV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1A\xB1W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x84[\x84\x81\x10\x15a\x19\xF7Wa\x1A\xC8\x87\x82a\x1C\xA8V[\x82a\x1A\xD3\x88\x84a'wV[\x81Q\x81\x10a\x1A\xE3Wa\x1A\xE3a'\xC8V[`\x01`\x01`\xA0\x1B\x03\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\x1A\xB6V[``_a\x1B\x0F\x85a\x17\xE5V[\x90P\x80\x83\x11\x15a\x1B\x1DW\x80\x92P[_a\x1B(\x85\x85a'wV[`\x01`\x01`@\x1B\x03\x81\x11\x15a\x1B?Wa\x1B?a vV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1BhW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x84[\x84\x81\x10\x15a\x19\xF7Wa\x1B\x7F\x87\x82a\x1C\xFFV[\x82a\x1B\x8A\x88\x84a'wV[\x81Q\x81\x10a\x1B\x9AWa\x1B\x9Aa'\xC8V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x1BmV[__\x82\x12\x15a\x18\xDCW\x81_\x03a\x0B\x81V[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a\x1C\x98W_a\x1B\xE0`\x01\x83a'wV[\x85T\x90\x91P_\x90a\x1B\xF3\x90`\x01\x90a'wV[\x90P\x80\x82\x14a\x1CRW_\x86_\x01\x82\x81T\x81\x10a\x1C\x11Wa\x1C\x11a'\xC8V[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10a\x1C1Wa\x1C1a'\xC8V[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a\x1CcWa\x1Cca'\xDCV[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\x0B\x81V[_\x91PPa\x0B\x81V[P\x92\x91PPV[_a\r!\x83\x83a\x1D\x06V[_\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x1C\xF8WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x0B\x81V[P_a\x0B\x81V[_a\r!\x83\x83[_\x82_\x01\x82\x81T\x81\x10a\x1D\x1BWa\x1D\x1Ba'\xC8V[\x90_R` _ \x01T\x90P\x92\x91PPV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\x1DeW\x91` \x02\x82\x01[\x82\x81\x11\x15a\x1DeW\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90a\x1DJV[Pa\x18\xDC\x92\x91Pa\x1F:V[\x82\x80T\x82\x82U\x90_R` _ \x90`\x1F\x01` \x90\x04\x81\x01\x92\x82\x15a\x1DeW\x91` \x02\x82\x01_[\x83\x82\x11\x15a\x1D\xD3W\x83Q\x83\x82a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x92` \x01\x92`\x01\x01` \x81_\x01\x04\x92\x83\x01\x92`\x01\x03\x02a\x1D\x97V[\x80\x15a\x1D\xFFW\x82\x81a\x01\0\n\x81T\x90`\xFF\x02\x19\x16\x90U`\x01\x01` \x81_\x01\x04\x92\x83\x01\x92`\x01\x03\x02a\x1D\xD3V[PPa\x18\xDC\x92\x91Pa\x1F:V[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x0E\xF8\x91\x90a\x1F:V[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\x1EkW\x91` \x02\x82\x01[\x82\x81\x11\x15a\x1EkW\x82Q\x82\x90a\x1E[\x90\x82a&wV[P\x91` \x01\x91\x90`\x01\x01\x90a\x1EEV[Pa\x18\xDC\x92\x91Pa\x1FNV[P\x80Ta\x1E\x83\x90a%\x8FV[_\x82U\x80`\x1F\x10a\x1E\x92WPPV[`\x1F\x01` \x90\x04\x90_R` _ \x90\x81\x01\x90a\x0E\xF8\x91\x90a\x1F:V[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x0E\xF8\x91\x90a\x1FNV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\x1DeW\x91` \x02\x82\x01[\x82\x81\x11\x15a\x1DeW\x82Q\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x17\x82U` \x90\x92\x01\x91`\x01\x90\x91\x01\x90a\x1E\xE7V[P\x80T_\x82U`\x1F\x01` \x90\x04\x90_R` _ \x90\x81\x01\x90a\x0E\xF8\x91\x90[[\x80\x82\x11\x15a\x18\xDCW_\x81U`\x01\x01a\x1F;V[\x80\x82\x11\x15a\x18\xDCW_a\x1Fa\x82\x82a\x1EwV[P`\x01\x01a\x1FNV[_` \x82\x84\x03\x12\x15a\x1FzW__\xFD[P5\x91\x90PV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[_` \x82\x01` \x83R\x80\x84Q\x80\x83R`@\x85\x01\x91P`@\x81`\x05\x1B\x86\x01\x01\x92P` \x86\x01_[\x82\x81\x10\x15a \x06W`?\x19\x87\x86\x03\x01\x84Ra\x1F\xF1\x85\x83Qa\x1F\x81V[\x94P` \x93\x84\x01\x93\x91\x90\x91\x01\x90`\x01\x01a\x1F\xD5V[P\x92\x96\x95PPPPPPV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a KW\x83Q\x15\x15\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a +V[P\x90\x95\x94PPPPPV[__`@\x83\x85\x03\x12\x15a gW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a \xB2Wa \xB2a vV[`@R\x91\x90PV[_`\x01`\x01`@\x1B\x03\x82\x11\x15a \xD2Wa \xD2a vV[P`\x05\x1B` \x01\x90V[__`@\x83\x85\x03\x12\x15a \xEDW__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a!\tW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a!\x19W__\xFD[\x805a!,a!'\x82a \xBAV[a \x8AV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a!MW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a!oW\x835\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a!TV[\x80\x94PPPPP\x92P\x92\x90PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a KW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a!\x96V[_\x82`\x1F\x83\x01\x12a!\xC3W__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a!\xDCWa!\xDCa vV[a!\xEF`\x1F\x82\x01`\x1F\x19\x16` \x01a \x8AV[\x81\x81R\x84` \x83\x86\x01\x01\x11\x15a\"\x03W__\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[___``\x84\x86\x03\x12\x15a\"1W__\xFD[\x835\x92P` \x84\x015\x91P`@\x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\"TW__\xFD[a\"`\x86\x82\x87\x01a!\xB4V[\x91PP\x92P\x92P\x92V[\x80\x15\x15\x81\x14a\x0E\xF8W__\xFD[__`@\x83\x85\x03\x12\x15a\"\x88W__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\"\xA4W__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\"\xB4W__\xFD[\x805a\"\xC2a!'\x82a \xBAV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a\"\xE3W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a!oW\x835a\"\xFD\x81a\"jV[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a\"\xEAV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a KW\x83Q`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a#'V[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a#dW__\xFD[\x91\x90PV[__`@\x83\x85\x03\x12\x15a#zW__\xFD[\x825\x91Pa#\x8A` \x84\x01a#NV[\x90P\x92P\x92\x90PV[__`@\x83\x85\x03\x12\x15a#\xA4W__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a#\xC0W__\xFD[a#\xCC\x85\x82\x86\x01a!\xB4V[\x91PP\x92P\x92\x90PV[` \x81R_a\r!` \x83\x01\x84a\x1F\x81V[___``\x84\x86\x03\x12\x15a#\xFAW__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[__`@\x83\x85\x03\x12\x15a$\"W__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a$>W__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a$NW__\xFD[\x805a$\\a!'\x82a \xBAV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a$}W__\xFD[` \x84\x01[\x83\x81\x10\x15a$\xBDW\x805`\x01`\x01`@\x1B\x03\x81\x11\x15a$\x9FW__\xFD[a$\xAE\x8A` \x83\x89\x01\x01a!\xB4V[\x84RP` \x92\x83\x01\x92\x01a$\x82V[P\x80\x94PPPPP\x92P\x92\x90PV[__`@\x83\x85\x03\x12\x15a$\xDDW__\xFD[\x825\x91P` \x83\x015a$\xEF\x81a\"jV[\x80\x91PP\x92P\x92\x90PV[__`@\x83\x85\x03\x12\x15a%\x0BW__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a%'W__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a%7W__\xFD[\x805a%Ea!'\x82a \xBAV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a%fW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a!oWa%~\x84a#NV[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a%mV[`\x01\x81\x81\x1C\x90\x82\x16\x80a%\xA3W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a%\xC1WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[` \x80\x82R`\n\x90\x82\x01Ri!\xA7\xA7*)'\xA6&\"\xA9`\xB1\x1B`@\x82\x01R``\x01\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_`\x01`\xFF\x1B\x82\x01a&\x13Wa&\x13a%\xEBV[P_\x03\x90V[\x80\x82\x01\x80\x82\x11\x15a\x0B\x81Wa\x0B\x81a%\xEBV[`\x1F\x82\x11\x15a\x0C\xA7W\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a&QWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a&pW_\x81U`\x01\x01a&]V[PPPPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a&\x90Wa&\x90a vV[a&\xA4\x81a&\x9E\x84Ta%\x8FV[\x84a&,V[` `\x1F\x82\x11`\x01\x81\x14a&\xD6W_\x83\x15a&\xBFWP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua&pV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a'\x05W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a&\xE5V[P\x84\x82\x10\x15a'\"W\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[\x81\x81\x03_\x83\x12\x80\x15\x83\x83\x13\x16\x83\x83\x12\x82\x16\x17\x15a\x1C\xA1Wa\x1C\xA1a%\xEBV[\x80\x82\x01\x82\x81\x12_\x83\x12\x80\x15\x82\x16\x82\x15\x82\x16\x17\x15a'oWa'oa%\xEBV[PP\x92\x91PPV[\x81\x81\x03\x81\x81\x11\x15a\x0B\x81Wa\x0B\x81a%\xEBV[_` \x82\x84\x03\x12\x15a'\x9AW__\xFD[\x81Qa\r!\x81a\"jV[`\x01`\x01`\xA0\x1B\x03\x83\x16\x81R`@` \x82\x01\x81\x90R_\x90a\x10\xA2\x90\x83\x01\x84a\x1F\x81V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD\xFE\xA2dipfsX\"\x12 D\xF8M\xE0\x8D\xBE#\xAC iVmC\x7F\x01\xA2)h\x18\xAC\xC3\x8B=H\xBAH\x0C\x04\xF7\xEC\x14AdsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610417575f3560e01c80639921c3cc11610221578063cbb093dd1161012a578063e4e36c4e116100b4578063ec672cf611610084578063ec672cf614610a27578063f069052a14610a3a578063f15caeac14610a4d578063f3903b9f14610a60578063f51fc0d914610a73575f5ffd5b8063e4e36c4e1461091f578063e62461ce146109ee578063e7e4148e14610a01578063e98aabc114610a14575f5ffd5b8063d52852af116100fa578063d52852af14610977578063dc97d96214610996578063dd031997146109b5578063e208a70d146109c8578063e2a4853a146109db575f5ffd5b8063cbb093dd1461091f578063cc50eadd14610932578063cf6a872214610945578063d38eebc714610958575f5ffd5b8063bd02d0f5116101ab578063c1dc91821161017b578063c1dc9182146108c0578063c4f00fde146108d3578063c769d1a1146108e6578063c80f4c62146108f9578063ca446dd91461090c575f5ffd5b8063bd02d0f514610868578063be43caa314610887578063bf498dd31461089a578063bf7f035a146108ad575f5ffd5b8063a9fcf76b116101f1578063a9fcf76b14610809578063abfdcced1461081c578063adb353dc1461082f578063b348e63914610842578063b8320a0814610855575f5ffd5b80639921c3cc146107b15780639faf6fb6146107c45780639fe7ac12146107d7578063a6ed563e146107ea575f5ffd5b80634a4a7b0411610323578063743df325116102ad57806388021a721161027d57806388021a72146107525780638ca498b01461076557806391d4403c1461077857806393266f9a1461078b578063986e791a1461079e575f5ffd5b8063743df325146106eb5780637ae1cfca1461070a57806380aacdcd1461072c57806386ac6bdf1461073f575f5ffd5b80636339734d116102f35780636339734d1461067f57806369721d41146106925780636e899550146106a55780636fae54f0146106c55780637026d42c146106d8575f5ffd5b80634a4a7b04146106125780634e91db08146106395780635948f7331461064c5780635eb07dbd1461066c575f5ffd5b806332f85bbf116103a45780633dbacd1a116103745780633dbacd1a146105a45780633e49bed0146105b757806342c3bd96146105ca57806344a242b1146105dd578063499ea50e146105ff575f5ffd5b806332f85bbf14610558578063340dbab31461056b57806335d4d4071461057e57806335ea805914610591575f5ffd5b806322538dae116103ea57806322538dae146104c557806322f87464146104ed57806326004846146105005780632d2899b614610515578063310b888214610535575f5ffd5b806301677da21461041b578063065f21a714610444578063116bb9291461046557806321f8a72114610485575b5f5ffd5b61042e610429366004611f6a565b610a86565b60405161043b9190611faf565b60405180910390f35b610457610452366004611f6a565b610b6b565b60405190815260200161043b565b610478610473366004611f6a565b610b87565b60405161043b9190612012565b6104ad610493366004611f6a565b5f908152600260205260409020546001600160a01b031690565b6040516001600160a01b03909116815260200161043b565b6104ad6104d3366004611f6a565b60026020525f90815260409020546001600160a01b031681565b6104ad6104fb366004612056565b610c05565b61051361050e3660046120dc565b610c39565b005b610528610523366004611f6a565b610cac565b60405161043b919061217d565b610548610543366004612056565b610d0a565b604051901515815260200161043b565b61045761056636600461221f565b610d28565b610457610579366004612056565b610db5565b61051361058c366004612277565b610dfa565b61045761059f366004611f6a565b610e2a565b6104576105b2366004612056565b610e40565b6104576105c5366004612056565b610e86565b6105136105d8366004611f6a565b610eae565b6105486105eb366004611f6a565b60036020525f908152604090205460ff1681565b61051361060d366004611f6a565b610ed0565b6104ad7f000000000000000000000000000000000000000000000000000000000000000081565b610457610647366004612056565b610efb565b61065f61065a366004611f6a565b610f23565b60405161043b919061230e565b61051361067a3660046120dc565b610f8b565b61045761068d366004612056565b610fbb565b6105136106a0366004612369565b610fe6565b6106b86106b3366004612393565b61100f565b60405161043b91906123d6565b6104576106d3366004612056565b611042565b6105286106e63660046123e8565b611087565b6104576106f9366004611f6a565b60016020525f908152604090205481565b610548610718366004611f6a565b5f9081526003602052604090205460ff1690565b61054861073a366004612056565b6110aa565b61052861074d366004611f6a565b6110e8565b610513610760366004612411565b611145565b610457610773366004612056565b611175565b610548610786366004612056565b6111d6565b610513610799366004612056565b6111ed565b6106b86107ac366004611f6a565b611216565b6105136107bf366004612056565b6112ab565b6105136107d2366004611f6a565b6112d4565b6105136107e5366004611f6a565b611303565b6104576107f8366004611f6a565b5f9081526005602052604090205490565b6105136108173660046120dc565b61132c565b61054861082a3660046124cc565b61135c565b61051361083d366004612056565b61138d565b610513610850366004612369565b6113b6565b6106b8610863366004612056565b6113df565b610457610876366004611f6a565b5f9081526020819052604090205490565b610513610895366004611f6a565b611490565b6104576108a8366004612056565b6114b8565b6105136108bb366004611f6a565b6114d1565b6105136108ce366004611f6a565b6114f9565b6104576108e1366004612056565b611521565b6105486108f4366004612369565b61153a565b610513610907366004612056565b611551565b6104ad61091a366004612369565b61157a565b61045761092d366004612056565b6115b8565b610513610940366004611f6a565b6115e4565b610513610953366004611f6a565b61160c565b610457610966366004611f6a565b5f6020819052908152604090205481565b610457610985366004611f6a565b60056020525f908152604090205481565b6104576109a4366004611f6a565b5f9081526001602052604090205490565b6105286109c3366004611f6a565b61162e565b6105136109d6366004611f6a565b61168b565b6104576109e9366004612056565b6116b3565b6105136109fc366004611f6a565b6116db565b61065f610a0f3660046123e8565b6116fd565b610457610a22366004612056565b611718565b610513610a353660046124fa565b611744565b610528610a483660046123e8565b611774565b6106b8610a5b366004611f6a565b61178f565b610457610a6e366004611f6a565b6117a7565b610513610a81366004611f6a565b6117bd565b6060600a5f8381526020019081526020015f20805480602002602001604051908101604052809291908181526020015f905b82821015610b60578382905f5260205f20018054610ad59061258f565b80601f0160208091040260200160405190810160405280929190818152602001828054610b019061258f565b8015610b4c5780601f10610b2357610100808354040283529160200191610b4c565b820191905f5260205f20905b815481529060010190602001808311610b2f57829003601f168201915b505050505081526020019060010190610ab8565b505050509050919050565b5f818152600e60205260408120610b81906117e5565b92915050565b5f81815260096020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f20905f905b825461010083900a900460ff161515815260206001928301818104948501949093039092029101808411610bc85790505b50505050509050919050565b6008602052815f5260405f208181548110610c1e575f80fd5b5f918252602090912001546001600160a01b03169150829050565b610c89604051602001610c4b906125c7565b604051602081830303815290604052805190602001206040518060400160405280600a81526020016921a7a72a2927a62622a960b11b8152506117ee565b5f828152600b602090815260409091208251610ca792840190611d2c565b505050565b5f81815260076020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f20905b815481526020019060010190808311610ceb5750505050509050919050565b5f828152600e60205260408120610d2190836118a0565b9392505050565b5f610d3b604051602001610c4b906125c7565b5f848152602081905260408120549084128015610d67575080610d65610d60866125ff565b6118b7565b115b15610d8f578260405162461bcd60e51b8152600401610d8691906123d6565b60405180910390fd5b5f610d9a82866118e0565b5f878152602081905260409020819055925050509392505050565b5f610dc8604051602001610c4b906125c7565b5f83815260208190526040812054610de1908490612619565b5f85815260208190526040902081905591505092915050565b610e0c604051602001610c4b906125c7565b5f8281526009602090815260409091208251610ca792840190611d71565b5f818152600d60205260408120610b81906117e5565b5f610e53604051602001610c4b906125c7565b5f8381526020819052604081205490610e6c8483612619565b5f8681526020819052604090208190559250505092915050565b5f610e99604051602001610c4b906125c7565b505f9182526001602052604090912081905590565b610ec0604051602001610c4b906125c7565b5f90815260208190526040812055565b610ee2604051602001610c4b906125c7565b5f818152600760205260408120610ef891611e0c565b50565b5f610f0e604051602001610c4b906125c7565b505f9182526005602052604090912081905590565b5f81815260086020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f20905b81546001600160a01b03168152600190910190602001808311610f625750505050509050919050565b610f9d604051602001610c4b906125c7565b5f8281526006602090815260409091208251610ca792840190611d2c565b6007602052815f5260405f208181548110610fd4575f80fd5b905f5260205f20015f91509150505481565b610ff8604051602001610c4b906125c7565b5f828152600d60205260409020610ca79082611916565b6060611023604051602001610c4b906125c7565b5f83815260046020526040902061103a8382612677565b509092915050565b5f611055604051602001610c4b906125c7565b5f8381526001602052604081205461106e908490612731565b5f85815260016020526040902081905591505092915050565b5f838152600e602052604090206060906110a290848461192a565b949350505050565b6009602052815f5260405f2081815481106110c3575f80fd5b905f5260205f209060209182820401919006915091509054906101000a900460ff1681565b5f81815260066020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f2090815481526020019060010190808311610ceb5750505050509050919050565b611157604051602001610c4b906125c7565b5f828152600a602090815260409091208251610ca792840190611e27565b5f611188604051602001610c4b906125c7565b5f8381526020819052604081205490831280156111af5750806111ad610d60856125ff565b115b156111cb5750505f828152602081905260408120819055610b81565b5f610e6c82856118e0565b5f828152600c60205260408120610d2190836118a0565b6111ff604051602001610c4b906125c7565b5f828152600e60205260409020610ca79082611a01565b5f8181526004602052604090208054606091906112329061258f565b80601f016020809104026020016040519081016040528092919081815260200182805461125e9061258f565b8015610bf95780601f1061128057610100808354040283529160200191610bf9565b820191905f5260205f20905b81548152906001019060200180831161128c5750939695505050505050565b6112bd604051602001610c4b906125c7565b5f828152600c60205260409020610ca79082611a01565b6112e6604051602001610c4b906125c7565b5f90815260026020526040902080546001600160a01b0319169055565b611315604051602001610c4b906125c7565b5f908152600360205260409020805460ff19169055565b61133e604051602001610c4b906125c7565b5f8281526007602090815260409091208251610ca792840190611d2c565b5f61136f604051602001610c4b906125c7565b505f91825260036020526040909120805460ff191682151517905590565b61139f604051602001610c4b906125c7565b5f828152600e60205260409020610ca79082611a0c565b6113c8604051602001610c4b906125c7565b5f828152600d60205260409020610ca79082611a17565b600a602052815f5260405f2081815481106113f8575f80fd5b905f5260205f20015f915091505080546114119061258f565b80601f016020809104026020016040519081016040528092919081815260200182805461143d9061258f565b80156114885780601f1061145f57610100808354040283529160200191611488565b820191905f5260205f20905b81548152906001019060200180831161146b57829003601f168201915b505050505081565b6114a2604051602001610c4b906125c7565b5f818152600660205260408120610ef891611e0c565b600b602052815f5260405f208181548110610fd4575f80fd5b6114e3604051602001610c4b906125c7565b5f818152600b60205260408120610ef891611e0c565b61150b604051602001610c4b906125c7565b5f818152600860205260408120610ef891611e0c565b6006602052815f5260405f208181548110610fd4575f80fd5b5f828152600d60205260408120610d219083611a2b565b611563604051602001610c4b906125c7565b5f828152600c60205260409020610ca79082611a0c565b5f61158d604051602001610c4b906125c7565b505f9182526002602052604090912080546001600160a01b0319166001600160a01b03831617905590565b5f6115cb604051602001610c4b906125c7565b5f8381526001602052604081205461106e908490612750565b6115f6604051602001610c4b906125c7565b5f818152600460205260408120610ef891611e77565b61161e604051602001610c4b906125c7565b5f90815260056020526040812055565b5f818152600b6020908152604091829020805483518184028101840190945280845260609392830182828015610bf957602002820191905f5260205f2090815481526020019060010190808311610ceb5750505050509050919050565b61169d604051602001610c4b906125c7565b5f818152600a60205260408120610ef891611eae565b5f6116c6604051602001610c4b906125c7565b505f9182526020829052604090912081905590565b6116ed604051602001610c4b906125c7565b5f90815260016020526040812055565b5f838152600d602052604090206060906110a2908484611a4c565b5f61172b604051602001610c4b906125c7565b5f83815260208190526040812054610de1908490612777565b611756604051602001610c4b906125c7565b5f8281526008602090815260409091208251610ca792840190611ec9565b5f838152600c602052604090206060906110a2908484611b03565b60046020525f9081526040902080546114119061258f565b5f818152600c60205260408120610b81906117e5565b6117cf604051602001610c4b906125c7565b5f818152600960205260408120610ef891611f1c565b5f610b81825490565b60405163ac4ab3fb60e01b8152336004820152602481018390527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063ac4ab3fb90604401602060405180830381865afa158015611857573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061187b919061278a565b61189c57338160405163a35b150b60e01b8152600401610d869291906127a5565b5050565b5f8181526001830160205260408120541515610d21565b5f5f8212156118dc57604051635467221960e11b815260048101839052602401610d86565b5090565b5f5f821315611903576118f282611bad565b6118fc9084612619565b9050610b81565b61190c82611bad565b610d219084612777565b5f610d21836001600160a01b038416611bbe565b6060611935846117e5565b831061194f5750604080515f815260208101909152610d21565b5f611959856117e5565b905080831115611967578092505b5f6119728585612777565b6001600160401b0381111561198957611989612076565b6040519080825280602002602001820160405280156119b2578160200160208202803683370190505b509050845b848110156119f7576119c98782611ca8565b826119d48884612777565b815181106119e4576119e46127c8565b60209081029190910101526001016119b7565b5095945050505050565b5f610d218383611bbe565b5f610d218383611cb3565b5f610d21836001600160a01b038416611cb3565b6001600160a01b0381165f9081526001830160205260408120541515610d21565b60605f611a58856117e5565b905080831115611a66578092505b5f611a718585612777565b6001600160401b03811115611a8857611a88612076565b604051908082528060200260200182016040528015611ab1578160200160208202803683370190505b509050845b848110156119f757611ac88782611ca8565b82611ad38884612777565b81518110611ae357611ae36127c8565b6001600160a01b0390921660209283029190910190910152600101611ab6565b60605f611b0f856117e5565b905080831115611b1d578092505b5f611b288585612777565b6001600160401b03811115611b3f57611b3f612076565b604051908082528060200260200182016040528015611b68578160200160208202803683370190505b509050845b848110156119f757611b7f8782611cff565b82611b8a8884612777565b81518110611b9a57611b9a6127c8565b6020908102919091010152600101611b6d565b5f5f8212156118dc57815f03610b81565b5f8181526001830160205260408120548015611c98575f611be0600183612777565b85549091505f90611bf390600190612777565b9050808214611c52575f865f018281548110611c1157611c116127c8565b905f5260205f200154905080875f018481548110611c3157611c316127c8565b5f918252602080832090910192909255918252600188019052604090208390555b8554869080611c6357611c636127dc565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f905560019350505050610b81565b5f915050610b81565b5092915050565b5f610d218383611d06565b5f818152600183016020526040812054611cf857508154600181810184555f848152602080822090930184905584548482528286019093526040902091909155610b81565b505f610b81565b5f610d2183835b5f825f018281548110611d1b57611d1b6127c8565b905f5260205f200154905092915050565b828054828255905f5260205f20908101928215611d65579160200282015b82811115611d65578251825591602001919060010190611d4a565b506118dc929150611f3a565b828054828255905f5260205f2090601f01602090048101928215611d65579160200282015f5b83821115611dd357835183826101000a81548160ff02191690831515021790555092602001926001016020815f01049283019260010302611d97565b8015611dff5782816101000a81549060ff02191690556001016020815f01049283019260010302611dd3565b50506118dc929150611f3a565b5080545f8255905f5260205f2090810190610ef89190611f3a565b828054828255905f5260205f20908101928215611e6b579160200282015b82811115611e6b5782518290611e5b9082612677565b5091602001919060010190611e45565b506118dc929150611f4e565b508054611e839061258f565b5f825580601f10611e92575050565b601f0160209004905f5260205f2090810190610ef89190611f3a565b5080545f8255905f5260205f2090810190610ef89190611f4e565b828054828255905f5260205f20908101928215611d65579160200282015b82811115611d6557825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190611ee7565b5080545f8255601f0160209004905f5260205f2090810190610ef891905b5b808211156118dc575f8155600101611f3b565b808211156118dc575f611f618282611e77565b50600101611f4e565b5f60208284031215611f7a575f5ffd5b5035919050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b5f602082016020835280845180835260408501915060408160051b8601019250602086015f5b8281101561200657603f19878603018452611ff1858351611f81565b94506020938401939190910190600101611fd5565b50929695505050505050565b602080825282518282018190525f918401906040840190835b8181101561204b578351151583526020938401939092019160010161202b565b509095945050505050565b5f5f60408385031215612067575f5ffd5b50508035926020909101359150565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b03811182821017156120b2576120b2612076565b604052919050565b5f6001600160401b038211156120d2576120d2612076565b5060051b60200190565b5f5f604083850312156120ed575f5ffd5b8235915060208301356001600160401b03811115612109575f5ffd5b8301601f81018513612119575f5ffd5b803561212c612127826120ba565b61208a565b8082825260208201915060208360051b85010192508783111561214d575f5ffd5b6020840193505b8284101561216f578335825260209384019390910190612154565b809450505050509250929050565b602080825282518282018190525f918401906040840190835b8181101561204b578351835260209384019390920191600101612196565b5f82601f8301126121c3575f5ffd5b81356001600160401b038111156121dc576121dc612076565b6121ef601f8201601f191660200161208a565b818152846020838601011115612203575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f5f5f60608486031215612231575f5ffd5b833592506020840135915060408401356001600160401b03811115612254575f5ffd5b612260868287016121b4565b9150509250925092565b8015158114610ef8575f5ffd5b5f5f60408385031215612288575f5ffd5b8235915060208301356001600160401b038111156122a4575f5ffd5b8301601f810185136122b4575f5ffd5b80356122c2612127826120ba565b8082825260208201915060208360051b8501019250878311156122e3575f5ffd5b6020840193505b8284101561216f5783356122fd8161226a565b8252602093840193909101906122ea565b602080825282518282018190525f918401906040840190835b8181101561204b5783516001600160a01b0316835260209384019390920191600101612327565b80356001600160a01b0381168114612364575f5ffd5b919050565b5f5f6040838503121561237a575f5ffd5b8235915061238a6020840161234e565b90509250929050565b5f5f604083850312156123a4575f5ffd5b8235915060208301356001600160401b038111156123c0575f5ffd5b6123cc858286016121b4565b9150509250929050565b602081525f610d216020830184611f81565b5f5f5f606084860312156123fa575f5ffd5b505081359360208301359350604090920135919050565b5f5f60408385031215612422575f5ffd5b8235915060208301356001600160401b0381111561243e575f5ffd5b8301601f8101851361244e575f5ffd5b803561245c612127826120ba565b8082825260208201915060208360051b85010192508783111561247d575f5ffd5b602084015b838110156124bd5780356001600160401b0381111561249f575f5ffd5b6124ae8a6020838901016121b4565b84525060209283019201612482565b50809450505050509250929050565b5f5f604083850312156124dd575f5ffd5b8235915060208301356124ef8161226a565b809150509250929050565b5f5f6040838503121561250b575f5ffd5b8235915060208301356001600160401b03811115612527575f5ffd5b8301601f81018513612537575f5ffd5b8035612545612127826120ba565b8082825260208201915060208360051b850101925087831115612566575f5ffd5b6020840193505b8284101561216f5761257e8461234e565b82526020938401939091019061256d565b600181811c908216806125a357607f821691505b6020821081036125c157634e487b7160e01b5f52602260045260245ffd5b50919050565b6020808252600a908201526921a7a72a2927a62622a960b11b604082015260600190565b634e487b7160e01b5f52601160045260245ffd5b5f600160ff1b8201612613576126136125eb565b505f0390565b80820180821115610b8157610b816125eb565b601f821115610ca757805f5260205f20601f840160051c810160208510156126515750805b601f840160051c820191505b81811015612670575f815560010161265d565b5050505050565b81516001600160401b0381111561269057612690612076565b6126a48161269e845461258f565b8461262c565b6020601f8211600181146126d6575f83156126bf5750848201515b5f19600385901b1c1916600184901b178455612670565b5f84815260208120601f198516915b8281101561270557878501518255602094850194600190920191016126e5565b508482101561272257868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b8181035f831280158383131683831282161715611ca157611ca16125eb565b8082018281125f83128015821682158216171561276f5761276f6125eb565b505092915050565b81810381811115610b8157610b816125eb565b5f6020828403121561279a575f5ffd5b8151610d218161226a565b6001600160a01b03831681526040602082018190525f906110a290830184611f81565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52603160045260245ffdfea264697066735822122044f84de08dbe23ac2069566d437f01a2296818acc38b3d48ba480c04f7ec144164736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x04\x17W_5`\xE0\x1C\x80c\x99!\xC3\xCC\x11a\x02!W\x80c\xCB\xB0\x93\xDD\x11a\x01*W\x80c\xE4\xE3lN\x11a\0\xB4W\x80c\xECg,\xF6\x11a\0\x84W\x80c\xECg,\xF6\x14a\n'W\x80c\xF0i\x05*\x14a\n:W\x80c\xF1\\\xAE\xAC\x14a\nMW\x80c\xF3\x90;\x9F\x14a\n`W\x80c\xF5\x1F\xC0\xD9\x14a\nsW__\xFD[\x80c\xE4\xE3lN\x14a\t\x1FW\x80c\xE6$a\xCE\x14a\t\xEEW\x80c\xE7\xE4\x14\x8E\x14a\n\x01W\x80c\xE9\x8A\xAB\xC1\x14a\n\x14W__\xFD[\x80c\xD5(R\xAF\x11a\0\xFAW\x80c\xD5(R\xAF\x14a\twW\x80c\xDC\x97\xD9b\x14a\t\x96W\x80c\xDD\x03\x19\x97\x14a\t\xB5W\x80c\xE2\x08\xA7\r\x14a\t\xC8W\x80c\xE2\xA4\x85:\x14a\t\xDBW__\xFD[\x80c\xCB\xB0\x93\xDD\x14a\t\x1FW\x80c\xCCP\xEA\xDD\x14a\t2W\x80c\xCFj\x87\"\x14a\tEW\x80c\xD3\x8E\xEB\xC7\x14a\tXW__\xFD[\x80c\xBD\x02\xD0\xF5\x11a\x01\xABW\x80c\xC1\xDC\x91\x82\x11a\x01{W\x80c\xC1\xDC\x91\x82\x14a\x08\xC0W\x80c\xC4\xF0\x0F\xDE\x14a\x08\xD3W\x80c\xC7i\xD1\xA1\x14a\x08\xE6W\x80c\xC8\x0FLb\x14a\x08\xF9W\x80c\xCADm\xD9\x14a\t\x0CW__\xFD[\x80c\xBD\x02\xD0\xF5\x14a\x08hW\x80c\xBEC\xCA\xA3\x14a\x08\x87W\x80c\xBFI\x8D\xD3\x14a\x08\x9AW\x80c\xBF\x7F\x03Z\x14a\x08\xADW__\xFD[\x80c\xA9\xFC\xF7k\x11a\x01\xF1W\x80c\xA9\xFC\xF7k\x14a\x08\tW\x80c\xAB\xFD\xCC\xED\x14a\x08\x1CW\x80c\xAD\xB3S\xDC\x14a\x08/W\x80c\xB3H\xE69\x14a\x08BW\x80c\xB82\n\x08\x14a\x08UW__\xFD[\x80c\x99!\xC3\xCC\x14a\x07\xB1W\x80c\x9F\xAFo\xB6\x14a\x07\xC4W\x80c\x9F\xE7\xAC\x12\x14a\x07\xD7W\x80c\xA6\xEDV>\x14a\x07\xEAW__\xFD[\x80cJJ{\x04\x11a\x03#W\x80ct=\xF3%\x11a\x02\xADW\x80c\x88\x02\x1Ar\x11a\x02}W\x80c\x88\x02\x1Ar\x14a\x07RW\x80c\x8C\xA4\x98\xB0\x14a\x07eW\x80c\x91\xD4@<\x14a\x07xW\x80c\x93&o\x9A\x14a\x07\x8BW\x80c\x98ny\x1A\x14a\x07\x9EW__\xFD[\x80ct=\xF3%\x14a\x06\xEBW\x80cz\xE1\xCF\xCA\x14a\x07\nW\x80c\x80\xAA\xCD\xCD\x14a\x07,W\x80c\x86\xACk\xDF\x14a\x07?W__\xFD[\x80cc9sM\x11a\x02\xF3W\x80cc9sM\x14a\x06\x7FW\x80cir\x1DA\x14a\x06\x92W\x80cn\x89\x95P\x14a\x06\xA5W\x80co\xAET\xF0\x14a\x06\xC5W\x80cp&\xD4,\x14a\x06\xD8W__\xFD[\x80cJJ{\x04\x14a\x06\x12W\x80cN\x91\xDB\x08\x14a\x069W\x80cYH\xF73\x14a\x06LW\x80c^\xB0}\xBD\x14a\x06lW__\xFD[\x80c2\xF8[\xBF\x11a\x03\xA4W\x80c=\xBA\xCD\x1A\x11a\x03tW\x80c=\xBA\xCD\x1A\x14a\x05\xA4W\x80c>I\xBE\xD0\x14a\x05\xB7W\x80cB\xC3\xBD\x96\x14a\x05\xCAW\x80cD\xA2B\xB1\x14a\x05\xDDW\x80cI\x9E\xA5\x0E\x14a\x05\xFFW__\xFD[\x80c2\xF8[\xBF\x14a\x05XW\x80c4\r\xBA\xB3\x14a\x05kW\x80c5\xD4\xD4\x07\x14a\x05~W\x80c5\xEA\x80Y\x14a\x05\x91W__\xFD[\x80c\"S\x8D\xAE\x11a\x03\xEAW\x80c\"S\x8D\xAE\x14a\x04\xC5W\x80c\"\xF8td\x14a\x04\xEDW\x80c&\0HF\x14a\x05\0W\x80c-(\x99\xB6\x14a\x05\x15W\x80c1\x0B\x88\x82\x14a\x055W__\xFD[\x80c\x01g}\xA2\x14a\x04\x1BW\x80c\x06_!\xA7\x14a\x04DW\x80c\x11k\xB9)\x14a\x04eW\x80c!\xF8\xA7!\x14a\x04\x85W[__\xFD[a\x04.a\x04)6`\x04a\x1FjV[a\n\x86V[`@Qa\x04;\x91\x90a\x1F\xAFV[`@Q\x80\x91\x03\x90\xF3[a\x04Wa\x04R6`\x04a\x1FjV[a\x0BkV[`@Q\x90\x81R` \x01a\x04;V[a\x04xa\x04s6`\x04a\x1FjV[a\x0B\x87V[`@Qa\x04;\x91\x90a \x12V[a\x04\xADa\x04\x936`\x04a\x1FjV[_\x90\x81R`\x02` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x04;V[a\x04\xADa\x04\xD36`\x04a\x1FjV[`\x02` R_\x90\x81R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x04\xADa\x04\xFB6`\x04a VV[a\x0C\x05V[a\x05\x13a\x05\x0E6`\x04a \xDCV[a\x0C9V[\0[a\x05(a\x05#6`\x04a\x1FjV[a\x0C\xACV[`@Qa\x04;\x91\x90a!}V[a\x05Ha\x05C6`\x04a VV[a\r\nV[`@Q\x90\x15\x15\x81R` \x01a\x04;V[a\x04Wa\x05f6`\x04a\"\x1FV[a\r(V[a\x04Wa\x05y6`\x04a VV[a\r\xB5V[a\x05\x13a\x05\x8C6`\x04a\"wV[a\r\xFAV[a\x04Wa\x05\x9F6`\x04a\x1FjV[a\x0E*V[a\x04Wa\x05\xB26`\x04a VV[a\x0E@V[a\x04Wa\x05\xC56`\x04a VV[a\x0E\x86V[a\x05\x13a\x05\xD86`\x04a\x1FjV[a\x0E\xAEV[a\x05Ha\x05\xEB6`\x04a\x1FjV[`\x03` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[a\x05\x13a\x06\r6`\x04a\x1FjV[a\x0E\xD0V[a\x04\xAD\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x04Wa\x06G6`\x04a VV[a\x0E\xFBV[a\x06_a\x06Z6`\x04a\x1FjV[a\x0F#V[`@Qa\x04;\x91\x90a#\x0EV[a\x05\x13a\x06z6`\x04a \xDCV[a\x0F\x8BV[a\x04Wa\x06\x8D6`\x04a VV[a\x0F\xBBV[a\x05\x13a\x06\xA06`\x04a#iV[a\x0F\xE6V[a\x06\xB8a\x06\xB36`\x04a#\x93V[a\x10\x0FV[`@Qa\x04;\x91\x90a#\xD6V[a\x04Wa\x06\xD36`\x04a VV[a\x10BV[a\x05(a\x06\xE66`\x04a#\xE8V[a\x10\x87V[a\x04Wa\x06\xF96`\x04a\x1FjV[`\x01` R_\x90\x81R`@\x90 T\x81V[a\x05Ha\x07\x186`\x04a\x1FjV[_\x90\x81R`\x03` R`@\x90 T`\xFF\x16\x90V[a\x05Ha\x07:6`\x04a VV[a\x10\xAAV[a\x05(a\x07M6`\x04a\x1FjV[a\x10\xE8V[a\x05\x13a\x07`6`\x04a$\x11V[a\x11EV[a\x04Wa\x07s6`\x04a VV[a\x11uV[a\x05Ha\x07\x866`\x04a VV[a\x11\xD6V[a\x05\x13a\x07\x996`\x04a VV[a\x11\xEDV[a\x06\xB8a\x07\xAC6`\x04a\x1FjV[a\x12\x16V[a\x05\x13a\x07\xBF6`\x04a VV[a\x12\xABV[a\x05\x13a\x07\xD26`\x04a\x1FjV[a\x12\xD4V[a\x05\x13a\x07\xE56`\x04a\x1FjV[a\x13\x03V[a\x04Wa\x07\xF86`\x04a\x1FjV[_\x90\x81R`\x05` R`@\x90 T\x90V[a\x05\x13a\x08\x176`\x04a \xDCV[a\x13,V[a\x05Ha\x08*6`\x04a$\xCCV[a\x13\\V[a\x05\x13a\x08=6`\x04a VV[a\x13\x8DV[a\x05\x13a\x08P6`\x04a#iV[a\x13\xB6V[a\x06\xB8a\x08c6`\x04a VV[a\x13\xDFV[a\x04Wa\x08v6`\x04a\x1FjV[_\x90\x81R` \x81\x90R`@\x90 T\x90V[a\x05\x13a\x08\x956`\x04a\x1FjV[a\x14\x90V[a\x04Wa\x08\xA86`\x04a VV[a\x14\xB8V[a\x05\x13a\x08\xBB6`\x04a\x1FjV[a\x14\xD1V[a\x05\x13a\x08\xCE6`\x04a\x1FjV[a\x14\xF9V[a\x04Wa\x08\xE16`\x04a VV[a\x15!V[a\x05Ha\x08\xF46`\x04a#iV[a\x15:V[a\x05\x13a\t\x076`\x04a VV[a\x15QV[a\x04\xADa\t\x1A6`\x04a#iV[a\x15zV[a\x04Wa\t-6`\x04a VV[a\x15\xB8V[a\x05\x13a\t@6`\x04a\x1FjV[a\x15\xE4V[a\x05\x13a\tS6`\x04a\x1FjV[a\x16\x0CV[a\x04Wa\tf6`\x04a\x1FjV[_` \x81\x90R\x90\x81R`@\x90 T\x81V[a\x04Wa\t\x856`\x04a\x1FjV[`\x05` R_\x90\x81R`@\x90 T\x81V[a\x04Wa\t\xA46`\x04a\x1FjV[_\x90\x81R`\x01` R`@\x90 T\x90V[a\x05(a\t\xC36`\x04a\x1FjV[a\x16.V[a\x05\x13a\t\xD66`\x04a\x1FjV[a\x16\x8BV[a\x04Wa\t\xE96`\x04a VV[a\x16\xB3V[a\x05\x13a\t\xFC6`\x04a\x1FjV[a\x16\xDBV[a\x06_a\n\x0F6`\x04a#\xE8V[a\x16\xFDV[a\x04Wa\n\"6`\x04a VV[a\x17\x18V[a\x05\x13a\n56`\x04a$\xFAV[a\x17DV[a\x05(a\nH6`\x04a#\xE8V[a\x17tV[a\x06\xB8a\n[6`\x04a\x1FjV[a\x17\x8FV[a\x04Wa\nn6`\x04a\x1FjV[a\x17\xA7V[a\x05\x13a\n\x816`\x04a\x1FjV[a\x17\xBDV[```\n_\x83\x81R` \x01\x90\x81R` \x01_ \x80T\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01_\x90[\x82\x82\x10\x15a\x0B`W\x83\x82\x90_R` _ \x01\x80Ta\n\xD5\x90a%\x8FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x0B\x01\x90a%\x8FV[\x80\x15a\x0BLW\x80`\x1F\x10a\x0B#Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0BLV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x0B/W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81R` \x01\x90`\x01\x01\x90a\n\xB8V[PPPP\x90P\x91\x90PV[_\x81\x81R`\x0E` R`@\x81 a\x0B\x81\x90a\x17\xE5V[\x92\x91PPV[_\x81\x81R`\t` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90_\x90[\x82Ta\x01\0\x83\x90\n\x90\x04`\xFF\x16\x15\x15\x81R` `\x01\x92\x83\x01\x81\x81\x04\x94\x85\x01\x94\x90\x93\x03\x90\x92\x02\x91\x01\x80\x84\x11a\x0B\xC8W\x90P[PPPPP\x90P\x91\x90PV[`\x08` R\x81_R`@_ \x81\x81T\x81\x10a\x0C\x1EW_\x80\xFD[_\x91\x82R` \x90\x91 \x01T`\x01`\x01`\xA0\x1B\x03\x16\x91P\x82\x90PV[a\x0C\x89`@Q` \x01a\x0CK\x90a%\xC7V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `@Q\x80`@\x01`@R\x80`\n\x81R` \x01i!\xA7\xA7*)'\xA6&\"\xA9`\xB1\x1B\x81RPa\x17\xEEV[_\x82\x81R`\x0B` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1D,V[PPPV[_\x81\x81R`\x07` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x0C\xEBWPPPPP\x90P\x91\x90PV[_\x82\x81R`\x0E` R`@\x81 a\r!\x90\x83a\x18\xA0V[\x93\x92PPPV[_a\r;`@Q` \x01a\x0CK\x90a%\xC7V[_\x84\x81R` \x81\x90R`@\x81 T\x90\x84\x12\x80\x15a\rgWP\x80a\rea\r`\x86a%\xFFV[a\x18\xB7V[\x11[\x15a\r\x8FW\x82`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\r\x86\x91\x90a#\xD6V[`@Q\x80\x91\x03\x90\xFD[_a\r\x9A\x82\x86a\x18\xE0V[_\x87\x81R` \x81\x90R`@\x90 \x81\x90U\x92PPP\x93\x92PPPV[_a\r\xC8`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R` \x81\x90R`@\x81 Ta\r\xE1\x90\x84\x90a&\x19V[_\x85\x81R` \x81\x90R`@\x90 \x81\x90U\x91PP\x92\x91PPV[a\x0E\x0C`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\t` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1DqV[_\x81\x81R`\r` R`@\x81 a\x0B\x81\x90a\x17\xE5V[_a\x0ES`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R` \x81\x90R`@\x81 T\x90a\x0El\x84\x83a&\x19V[_\x86\x81R` \x81\x90R`@\x90 \x81\x90U\x92PPP\x92\x91PPV[_a\x0E\x99`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R`\x01` R`@\x90\x91 \x81\x90U\x90V[a\x0E\xC0`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R` \x81\x90R`@\x81 UV[a\x0E\xE2`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x07` R`@\x81 a\x0E\xF8\x91a\x1E\x0CV[PV[_a\x0F\x0E`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R`\x05` R`@\x90\x91 \x81\x90U\x90V[_\x81\x81R`\x08` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90[\x81T`\x01`\x01`\xA0\x1B\x03\x16\x81R`\x01\x90\x91\x01\x90` \x01\x80\x83\x11a\x0FbWPPPPP\x90P\x91\x90PV[a\x0F\x9D`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x06` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1D,V[`\x07` R\x81_R`@_ \x81\x81T\x81\x10a\x0F\xD4W_\x80\xFD[\x90_R` _ \x01_\x91P\x91PPT\x81V[a\x0F\xF8`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\r` R`@\x90 a\x0C\xA7\x90\x82a\x19\x16V[``a\x10#`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R`\x04` R`@\x90 a\x10:\x83\x82a&wV[P\x90\x92\x91PPV[_a\x10U`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R`\x01` R`@\x81 Ta\x10n\x90\x84\x90a'1V[_\x85\x81R`\x01` R`@\x90 \x81\x90U\x91PP\x92\x91PPV[_\x83\x81R`\x0E` R`@\x90 ``\x90a\x10\xA2\x90\x84\x84a\x19*V[\x94\x93PPPPV[`\t` R\x81_R`@_ \x81\x81T\x81\x10a\x10\xC3W_\x80\xFD[\x90_R` _ \x90` \x91\x82\x82\x04\x01\x91\x90\x06\x91P\x91P\x90T\x90a\x01\0\n\x90\x04`\xFF\x16\x81V[_\x81\x81R`\x06` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x0C\xEBWPPPPP\x90P\x91\x90PV[a\x11W`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\n` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1E'V[_a\x11\x88`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R` \x81\x90R`@\x81 T\x90\x83\x12\x80\x15a\x11\xAFWP\x80a\x11\xADa\r`\x85a%\xFFV[\x11[\x15a\x11\xCBWPP_\x82\x81R` \x81\x90R`@\x81 \x81\x90Ua\x0B\x81V[_a\x0El\x82\x85a\x18\xE0V[_\x82\x81R`\x0C` R`@\x81 a\r!\x90\x83a\x18\xA0V[a\x11\xFF`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x0E` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x01V[_\x81\x81R`\x04` R`@\x90 \x80T``\x91\x90a\x122\x90a%\x8FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x12^\x90a%\x8FV[\x80\x15a\x0B\xF9W\x80`\x1F\x10a\x12\x80Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x0B\xF9V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x12\x8CWP\x93\x96\x95PPPPPPV[a\x12\xBD`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x0C` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x01V[a\x12\xE6`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R`\x02` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90UV[a\x13\x15`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R`\x03` R`@\x90 \x80T`\xFF\x19\x16\x90UV[a\x13>`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x07` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1D,V[_a\x13o`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R`\x03` R`@\x90\x91 \x80T`\xFF\x19\x16\x82\x15\x15\x17\x90U\x90V[a\x13\x9F`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x0E` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x0CV[a\x13\xC8`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\r` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x17V[`\n` R\x81_R`@_ \x81\x81T\x81\x10a\x13\xF8W_\x80\xFD[\x90_R` _ \x01_\x91P\x91PP\x80Ta\x14\x11\x90a%\x8FV[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x14=\x90a%\x8FV[\x80\x15a\x14\x88W\x80`\x1F\x10a\x14_Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x14\x88V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x14kW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x81V[a\x14\xA2`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x06` R`@\x81 a\x0E\xF8\x91a\x1E\x0CV[`\x0B` R\x81_R`@_ \x81\x81T\x81\x10a\x0F\xD4W_\x80\xFD[a\x14\xE3`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x0B` R`@\x81 a\x0E\xF8\x91a\x1E\x0CV[a\x15\x0B`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x08` R`@\x81 a\x0E\xF8\x91a\x1E\x0CV[`\x06` R\x81_R`@_ \x81\x81T\x81\x10a\x0F\xD4W_\x80\xFD[_\x82\x81R`\r` R`@\x81 a\r!\x90\x83a\x1A+V[a\x15c`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x0C` R`@\x90 a\x0C\xA7\x90\x82a\x1A\x0CV[_a\x15\x8D`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R`\x02` R`@\x90\x91 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x17\x90U\x90V[_a\x15\xCB`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R`\x01` R`@\x81 Ta\x10n\x90\x84\x90a'PV[a\x15\xF6`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\x04` R`@\x81 a\x0E\xF8\x91a\x1EwV[a\x16\x1E`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R`\x05` R`@\x81 UV[_\x81\x81R`\x0B` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a\x0B\xF9W` \x02\x82\x01\x91\x90_R` _ \x90\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a\x0C\xEBWPPPPP\x90P\x91\x90PV[a\x16\x9D`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\n` R`@\x81 a\x0E\xF8\x91a\x1E\xAEV[_a\x16\xC6`@Q` \x01a\x0CK\x90a%\xC7V[P_\x91\x82R` \x82\x90R`@\x90\x91 \x81\x90U\x90V[a\x16\xED`@Q` \x01a\x0CK\x90a%\xC7V[_\x90\x81R`\x01` R`@\x81 UV[_\x83\x81R`\r` R`@\x90 ``\x90a\x10\xA2\x90\x84\x84a\x1ALV[_a\x17+`@Q` \x01a\x0CK\x90a%\xC7V[_\x83\x81R` \x81\x90R`@\x81 Ta\r\xE1\x90\x84\x90a'wV[a\x17V`@Q` \x01a\x0CK\x90a%\xC7V[_\x82\x81R`\x08` \x90\x81R`@\x90\x91 \x82Qa\x0C\xA7\x92\x84\x01\x90a\x1E\xC9V[_\x83\x81R`\x0C` R`@\x90 ``\x90a\x10\xA2\x90\x84\x84a\x1B\x03V[`\x04` R_\x90\x81R`@\x90 \x80Ta\x14\x11\x90a%\x8FV[_\x81\x81R`\x0C` R`@\x81 a\x0B\x81\x90a\x17\xE5V[a\x17\xCF`@Q` \x01a\x0CK\x90a%\xC7V[_\x81\x81R`\t` R`@\x81 a\x0E\xF8\x91a\x1F\x1CV[_a\x0B\x81\x82T\x90V[`@Qc\xACJ\xB3\xFB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x83\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90c\xACJ\xB3\xFB\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x18WW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18{\x91\x90a'\x8AV[a\x18\x9CW3\x81`@Qc\xA3[\x15\x0B`\xE0\x1B\x81R`\x04\x01a\r\x86\x92\x91\x90a'\xA5V[PPV[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x15\x15a\r!V[__\x82\x12\x15a\x18\xDCW`@QcTg\"\x19`\xE1\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\r\x86V[P\x90V[__\x82\x13\x15a\x19\x03Wa\x18\xF2\x82a\x1B\xADV[a\x18\xFC\x90\x84a&\x19V[\x90Pa\x0B\x81V[a\x19\x0C\x82a\x1B\xADV[a\r!\x90\x84a'wV[_a\r!\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x1B\xBEV[``a\x195\x84a\x17\xE5V[\x83\x10a\x19OWP`@\x80Q_\x81R` \x81\x01\x90\x91Ra\r!V[_a\x19Y\x85a\x17\xE5V[\x90P\x80\x83\x11\x15a\x19gW\x80\x92P[_a\x19r\x85\x85a'wV[`\x01`\x01`@\x1B\x03\x81\x11\x15a\x19\x89Wa\x19\x89a vV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x19\xB2W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x84[\x84\x81\x10\x15a\x19\xF7Wa\x19\xC9\x87\x82a\x1C\xA8V[\x82a\x19\xD4\x88\x84a'wV[\x81Q\x81\x10a\x19\xE4Wa\x19\xE4a'\xC8V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x19\xB7V[P\x95\x94PPPPPV[_a\r!\x83\x83a\x1B\xBEV[_a\r!\x83\x83a\x1C\xB3V[_a\r!\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a\x1C\xB3V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x01\x83\x01` R`@\x81 T\x15\x15a\r!V[``_a\x1AX\x85a\x17\xE5V[\x90P\x80\x83\x11\x15a\x1AfW\x80\x92P[_a\x1Aq\x85\x85a'wV[`\x01`\x01`@\x1B\x03\x81\x11\x15a\x1A\x88Wa\x1A\x88a vV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1A\xB1W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x84[\x84\x81\x10\x15a\x19\xF7Wa\x1A\xC8\x87\x82a\x1C\xA8V[\x82a\x1A\xD3\x88\x84a'wV[\x81Q\x81\x10a\x1A\xE3Wa\x1A\xE3a'\xC8V[`\x01`\x01`\xA0\x1B\x03\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\x1A\xB6V[``_a\x1B\x0F\x85a\x17\xE5V[\x90P\x80\x83\x11\x15a\x1B\x1DW\x80\x92P[_a\x1B(\x85\x85a'wV[`\x01`\x01`@\x1B\x03\x81\x11\x15a\x1B?Wa\x1B?a vV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1BhW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x84[\x84\x81\x10\x15a\x19\xF7Wa\x1B\x7F\x87\x82a\x1C\xFFV[\x82a\x1B\x8A\x88\x84a'wV[\x81Q\x81\x10a\x1B\x9AWa\x1B\x9Aa'\xC8V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x1BmV[__\x82\x12\x15a\x18\xDCW\x81_\x03a\x0B\x81V[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a\x1C\x98W_a\x1B\xE0`\x01\x83a'wV[\x85T\x90\x91P_\x90a\x1B\xF3\x90`\x01\x90a'wV[\x90P\x80\x82\x14a\x1CRW_\x86_\x01\x82\x81T\x81\x10a\x1C\x11Wa\x1C\x11a'\xC8V[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10a\x1C1Wa\x1C1a'\xC8V[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a\x1CcWa\x1Cca'\xDCV[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\x0B\x81V[_\x91PPa\x0B\x81V[P\x92\x91PPV[_a\r!\x83\x83a\x1D\x06V[_\x81\x81R`\x01\x83\x01` R`@\x81 Ta\x1C\xF8WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\x0B\x81V[P_a\x0B\x81V[_a\r!\x83\x83[_\x82_\x01\x82\x81T\x81\x10a\x1D\x1BWa\x1D\x1Ba'\xC8V[\x90_R` _ \x01T\x90P\x92\x91PPV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\x1DeW\x91` \x02\x82\x01[\x82\x81\x11\x15a\x1DeW\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90a\x1DJV[Pa\x18\xDC\x92\x91Pa\x1F:V[\x82\x80T\x82\x82U\x90_R` _ \x90`\x1F\x01` \x90\x04\x81\x01\x92\x82\x15a\x1DeW\x91` \x02\x82\x01_[\x83\x82\x11\x15a\x1D\xD3W\x83Q\x83\x82a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x92` \x01\x92`\x01\x01` \x81_\x01\x04\x92\x83\x01\x92`\x01\x03\x02a\x1D\x97V[\x80\x15a\x1D\xFFW\x82\x81a\x01\0\n\x81T\x90`\xFF\x02\x19\x16\x90U`\x01\x01` \x81_\x01\x04\x92\x83\x01\x92`\x01\x03\x02a\x1D\xD3V[PPa\x18\xDC\x92\x91Pa\x1F:V[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x0E\xF8\x91\x90a\x1F:V[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\x1EkW\x91` \x02\x82\x01[\x82\x81\x11\x15a\x1EkW\x82Q\x82\x90a\x1E[\x90\x82a&wV[P\x91` \x01\x91\x90`\x01\x01\x90a\x1EEV[Pa\x18\xDC\x92\x91Pa\x1FNV[P\x80Ta\x1E\x83\x90a%\x8FV[_\x82U\x80`\x1F\x10a\x1E\x92WPPV[`\x1F\x01` \x90\x04\x90_R` _ \x90\x81\x01\x90a\x0E\xF8\x91\x90a\x1F:V[P\x80T_\x82U\x90_R` _ \x90\x81\x01\x90a\x0E\xF8\x91\x90a\x1FNV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a\x1DeW\x91` \x02\x82\x01[\x82\x81\x11\x15a\x1DeW\x82Q\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x17\x82U` \x90\x92\x01\x91`\x01\x90\x91\x01\x90a\x1E\xE7V[P\x80T_\x82U`\x1F\x01` \x90\x04\x90_R` _ \x90\x81\x01\x90a\x0E\xF8\x91\x90[[\x80\x82\x11\x15a\x18\xDCW_\x81U`\x01\x01a\x1F;V[\x80\x82\x11\x15a\x18\xDCW_a\x1Fa\x82\x82a\x1EwV[P`\x01\x01a\x1FNV[_` \x82\x84\x03\x12\x15a\x1FzW__\xFD[P5\x91\x90PV[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[_` \x82\x01` \x83R\x80\x84Q\x80\x83R`@\x85\x01\x91P`@\x81`\x05\x1B\x86\x01\x01\x92P` \x86\x01_[\x82\x81\x10\x15a \x06W`?\x19\x87\x86\x03\x01\x84Ra\x1F\xF1\x85\x83Qa\x1F\x81V[\x94P` \x93\x84\x01\x93\x91\x90\x91\x01\x90`\x01\x01a\x1F\xD5V[P\x92\x96\x95PPPPPPV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a KW\x83Q\x15\x15\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a +V[P\x90\x95\x94PPPPPV[__`@\x83\x85\x03\x12\x15a gW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a \xB2Wa \xB2a vV[`@R\x91\x90PV[_`\x01`\x01`@\x1B\x03\x82\x11\x15a \xD2Wa \xD2a vV[P`\x05\x1B` \x01\x90V[__`@\x83\x85\x03\x12\x15a \xEDW__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a!\tW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a!\x19W__\xFD[\x805a!,a!'\x82a \xBAV[a \x8AV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a!MW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a!oW\x835\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a!TV[\x80\x94PPPPP\x92P\x92\x90PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a KW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a!\x96V[_\x82`\x1F\x83\x01\x12a!\xC3W__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a!\xDCWa!\xDCa vV[a!\xEF`\x1F\x82\x01`\x1F\x19\x16` \x01a \x8AV[\x81\x81R\x84` \x83\x86\x01\x01\x11\x15a\"\x03W__\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[___``\x84\x86\x03\x12\x15a\"1W__\xFD[\x835\x92P` \x84\x015\x91P`@\x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\"TW__\xFD[a\"`\x86\x82\x87\x01a!\xB4V[\x91PP\x92P\x92P\x92V[\x80\x15\x15\x81\x14a\x0E\xF8W__\xFD[__`@\x83\x85\x03\x12\x15a\"\x88W__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\"\xA4W__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a\"\xB4W__\xFD[\x805a\"\xC2a!'\x82a \xBAV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a\"\xE3W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a!oW\x835a\"\xFD\x81a\"jV[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a\"\xEAV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a KW\x83Q`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a#'V[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a#dW__\xFD[\x91\x90PV[__`@\x83\x85\x03\x12\x15a#zW__\xFD[\x825\x91Pa#\x8A` \x84\x01a#NV[\x90P\x92P\x92\x90PV[__`@\x83\x85\x03\x12\x15a#\xA4W__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a#\xC0W__\xFD[a#\xCC\x85\x82\x86\x01a!\xB4V[\x91PP\x92P\x92\x90PV[` \x81R_a\r!` \x83\x01\x84a\x1F\x81V[___``\x84\x86\x03\x12\x15a#\xFAW__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[__`@\x83\x85\x03\x12\x15a$\"W__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a$>W__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a$NW__\xFD[\x805a$\\a!'\x82a \xBAV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a$}W__\xFD[` \x84\x01[\x83\x81\x10\x15a$\xBDW\x805`\x01`\x01`@\x1B\x03\x81\x11\x15a$\x9FW__\xFD[a$\xAE\x8A` \x83\x89\x01\x01a!\xB4V[\x84RP` \x92\x83\x01\x92\x01a$\x82V[P\x80\x94PPPPP\x92P\x92\x90PV[__`@\x83\x85\x03\x12\x15a$\xDDW__\xFD[\x825\x91P` \x83\x015a$\xEF\x81a\"jV[\x80\x91PP\x92P\x92\x90PV[__`@\x83\x85\x03\x12\x15a%\x0BW__\xFD[\x825\x91P` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a%'W__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a%7W__\xFD[\x805a%Ea!'\x82a \xBAV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a%fW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a!oWa%~\x84a#NV[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a%mV[`\x01\x81\x81\x1C\x90\x82\x16\x80a%\xA3W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a%\xC1WcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[` \x80\x82R`\n\x90\x82\x01Ri!\xA7\xA7*)'\xA6&\"\xA9`\xB1\x1B`@\x82\x01R``\x01\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_`\x01`\xFF\x1B\x82\x01a&\x13Wa&\x13a%\xEBV[P_\x03\x90V[\x80\x82\x01\x80\x82\x11\x15a\x0B\x81Wa\x0B\x81a%\xEBV[`\x1F\x82\x11\x15a\x0C\xA7W\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a&QWP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a&pW_\x81U`\x01\x01a&]V[PPPPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a&\x90Wa&\x90a vV[a&\xA4\x81a&\x9E\x84Ta%\x8FV[\x84a&,V[` `\x1F\x82\x11`\x01\x81\x14a&\xD6W_\x83\x15a&\xBFWP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua&pV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a'\x05W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a&\xE5V[P\x84\x82\x10\x15a'\"W\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[\x81\x81\x03_\x83\x12\x80\x15\x83\x83\x13\x16\x83\x83\x12\x82\x16\x17\x15a\x1C\xA1Wa\x1C\xA1a%\xEBV[\x80\x82\x01\x82\x81\x12_\x83\x12\x80\x15\x82\x16\x82\x15\x82\x16\x17\x15a'oWa'oa%\xEBV[PP\x92\x91PPV[\x81\x81\x03\x81\x81\x11\x15a\x0B\x81Wa\x0B\x81a%\xEBV[_` \x82\x84\x03\x12\x15a'\x9AW__\xFD[\x81Qa\r!\x81a\"jV[`\x01`\x01`\xA0\x1B\x03\x83\x16\x81R`@` \x82\x01\x81\x90R_\x90a\x10\xA2\x90\x83\x01\x84a\x1F\x81V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD\xFE\xA2dipfsX\"\x12 D\xF8M\xE0\x8D\xBE#\xAC iVmC\x7F\x01\xA2)h\x18\xAC\xC3\x8B=H\xBAH\x0C\x04\xF7\xEC\x14AdsolcC\0\x08\x1C\x003",
    );
    /**Custom error with signature `SafeCastOverflowedIntToUint(int256)` and selector `0xa8ce4432`.
```solidity
error SafeCastOverflowedIntToUint(int256 value);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeCastOverflowedIntToUint {
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::I256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeCastOverflowedIntToUint>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeCastOverflowedIntToUint) -> Self {
                (value.value,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeCastOverflowedIntToUint {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { value: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeCastOverflowedIntToUint {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeCastOverflowedIntToUint(int256)";
            const SELECTOR: [u8; 4] = [168u8, 206u8, 68u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
        }
    };
    /**Custom error with signature `Unauthorized(address,string)` and selector `0xa35b150b`.
```solidity
error Unauthorized(address msgSender, string role);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Unauthorized {
        pub msgSender: alloy::sol_types::private::Address,
        pub role: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Unauthorized> for UnderlyingRustTuple<'_> {
            fn from(value: Unauthorized) -> Self {
                (value.msgSender, value.role)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Unauthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    msgSender: tuple.0,
                    role: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Unauthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Unauthorized(address,string)";
            const SELECTOR: [u8; 4] = [163u8, 91u8, 21u8, 11u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.msgSender,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.role,
                    ),
                )
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _roleStore);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub _roleStore: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._roleStore,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _roleStore: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._roleStore,
                    ),
                )
            }
        }
    };
    /**Function with signature `addAddress(bytes32,address)` and selector `0xb348e639`.
```solidity
function addAddress(bytes32 setKey, address value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addAddressCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`addAddress(bytes32,address)`](addAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addAddressReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: addAddressCall) -> Self {
                    (value.setKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addAddressReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addAddressReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addAddress(bytes32,address)";
            const SELECTOR: [u8; 4] = [179u8, 72u8, 230u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addBytes32(bytes32,bytes32)` and selector `0xc80f4c62`.
```solidity
function addBytes32(bytes32 setKey, bytes32 value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addBytes32Call {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`addBytes32(bytes32,bytes32)`](addBytes32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addBytes32Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addBytes32Call> for UnderlyingRustTuple<'_> {
                fn from(value: addBytes32Call) -> Self {
                    (value.setKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addBytes32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addBytes32Return> for UnderlyingRustTuple<'_> {
                fn from(value: addBytes32Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addBytes32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addBytes32Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addBytes32Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addBytes32(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [200u8, 15u8, 76u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addUint(bytes32,uint256)` and selector `0xadb353dc`.
```solidity
function addUint(bytes32 setKey, uint256 value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addUintCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`addUint(bytes32,uint256)`](addUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addUintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: addUintCall) -> Self {
                    (value.setKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addUintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addUintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addUintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addUint(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [173u8, 179u8, 83u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addressArrayValues(bytes32,uint256)` and selector `0x22f87464`.
```solidity
function addressArrayValues(bytes32, uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addressArrayValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`addressArrayValues(bytes32,uint256)`](addressArrayValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addressArrayValuesReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addressArrayValuesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: addressArrayValuesCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addressArrayValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addressArrayValuesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: addressArrayValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addressArrayValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addressArrayValuesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addressArrayValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addressArrayValues(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [34u8, 248u8, 116u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addressValues(bytes32)` and selector `0x22538dae`.
```solidity
function addressValues(bytes32) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addressValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`addressValues(bytes32)`](addressValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addressValuesReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addressValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: addressValuesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addressValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addressValuesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addressValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addressValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addressValuesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addressValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addressValues(bytes32)";
            const SELECTOR: [u8; 4] = [34u8, 83u8, 141u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `applyBoundedDeltaToUint(bytes32,int256)` and selector `0x8ca498b0`.
```solidity
function applyBoundedDeltaToUint(bytes32 key, int256 value) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct applyBoundedDeltaToUintCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`applyBoundedDeltaToUint(bytes32,int256)`](applyBoundedDeltaToUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct applyBoundedDeltaToUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<applyBoundedDeltaToUintCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: applyBoundedDeltaToUintCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for applyBoundedDeltaToUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<applyBoundedDeltaToUintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: applyBoundedDeltaToUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for applyBoundedDeltaToUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for applyBoundedDeltaToUintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = applyBoundedDeltaToUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "applyBoundedDeltaToUint(bytes32,int256)";
            const SELECTOR: [u8; 4] = [140u8, 164u8, 152u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `applyDeltaToInt(bytes32,int256)` and selector `0xe4e36c4e`.
```solidity
function applyDeltaToInt(bytes32 key, int256 value) external returns (int256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct applyDeltaToIntCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`applyDeltaToInt(bytes32,int256)`](applyDeltaToIntCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct applyDeltaToIntReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<applyDeltaToIntCall> for UnderlyingRustTuple<'_> {
                fn from(value: applyDeltaToIntCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for applyDeltaToIntCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<applyDeltaToIntReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: applyDeltaToIntReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for applyDeltaToIntReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for applyDeltaToIntCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = applyDeltaToIntReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "applyDeltaToInt(bytes32,int256)";
            const SELECTOR: [u8; 4] = [228u8, 227u8, 108u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `applyDeltaToUint(bytes32,int256,string)` and selector `0x32f85bbf`.
```solidity
function applyDeltaToUint(bytes32 key, int256 value, string memory errorMessage) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct applyDeltaToUint_0Call {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::I256,
        pub errorMessage: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`applyDeltaToUint(bytes32,int256,string)`](applyDeltaToUint_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct applyDeltaToUint_0Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<applyDeltaToUint_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: applyDeltaToUint_0Call) -> Self {
                    (value.key, value.value, value.errorMessage)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for applyDeltaToUint_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                        errorMessage: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<applyDeltaToUint_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: applyDeltaToUint_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for applyDeltaToUint_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for applyDeltaToUint_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = applyDeltaToUint_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "applyDeltaToUint(bytes32,int256,string)";
            const SELECTOR: [u8; 4] = [50u8, 248u8, 91u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.errorMessage,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `applyDeltaToUint(bytes32,uint256)` and selector `0x3dbacd1a`.
```solidity
function applyDeltaToUint(bytes32 key, uint256 value) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct applyDeltaToUint_1Call {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`applyDeltaToUint(bytes32,uint256)`](applyDeltaToUint_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct applyDeltaToUint_1Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<applyDeltaToUint_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: applyDeltaToUint_1Call) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for applyDeltaToUint_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<applyDeltaToUint_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: applyDeltaToUint_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for applyDeltaToUint_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for applyDeltaToUint_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = applyDeltaToUint_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "applyDeltaToUint(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [61u8, 186u8, 205u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `boolArrayValues(bytes32,uint256)` and selector `0x80aacdcd`.
```solidity
function boolArrayValues(bytes32, uint256) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct boolArrayValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`boolArrayValues(bytes32,uint256)`](boolArrayValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct boolArrayValuesReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<boolArrayValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: boolArrayValuesCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for boolArrayValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<boolArrayValuesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: boolArrayValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for boolArrayValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for boolArrayValuesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = boolArrayValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "boolArrayValues(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [128u8, 170u8, 205u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `boolValues(bytes32)` and selector `0x44a242b1`.
```solidity
function boolValues(bytes32) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct boolValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`boolValues(bytes32)`](boolValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct boolValuesReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<boolValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: boolValuesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for boolValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<boolValuesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: boolValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for boolValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for boolValuesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = boolValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "boolValues(bytes32)";
            const SELECTOR: [u8; 4] = [68u8, 162u8, 66u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bytes32ArrayValues(bytes32,uint256)` and selector `0xbf498dd3`.
```solidity
function bytes32ArrayValues(bytes32, uint256) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bytes32ArrayValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`bytes32ArrayValues(bytes32,uint256)`](bytes32ArrayValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bytes32ArrayValuesReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bytes32ArrayValuesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: bytes32ArrayValuesCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bytes32ArrayValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bytes32ArrayValuesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bytes32ArrayValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bytes32ArrayValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bytes32ArrayValuesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bytes32ArrayValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bytes32ArrayValues(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [191u8, 73u8, 141u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bytes32Values(bytes32)` and selector `0xd52852af`.
```solidity
function bytes32Values(bytes32) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bytes32ValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`bytes32Values(bytes32)`](bytes32ValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bytes32ValuesReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bytes32ValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: bytes32ValuesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bytes32ValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bytes32ValuesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bytes32ValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bytes32ValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bytes32ValuesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bytes32ValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bytes32Values(bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 40u8, 82u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `containsAddress(bytes32,address)` and selector `0xc769d1a1`.
```solidity
function containsAddress(bytes32 setKey, address value) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct containsAddressCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`containsAddress(bytes32,address)`](containsAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct containsAddressReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<containsAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: containsAddressCall) -> Self {
                    (value.setKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for containsAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<containsAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: containsAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for containsAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for containsAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = containsAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "containsAddress(bytes32,address)";
            const SELECTOR: [u8; 4] = [199u8, 105u8, 209u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `containsBytes32(bytes32,bytes32)` and selector `0x91d4403c`.
```solidity
function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct containsBytes32Call {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`containsBytes32(bytes32,bytes32)`](containsBytes32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct containsBytes32Return {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<containsBytes32Call> for UnderlyingRustTuple<'_> {
                fn from(value: containsBytes32Call) -> Self {
                    (value.setKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for containsBytes32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<containsBytes32Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: containsBytes32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for containsBytes32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for containsBytes32Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = containsBytes32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "containsBytes32(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [145u8, 212u8, 64u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `containsUint(bytes32,uint256)` and selector `0x310b8882`.
```solidity
function containsUint(bytes32 setKey, uint256 value) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct containsUintCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`containsUint(bytes32,uint256)`](containsUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct containsUintReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<containsUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: containsUintCall) -> Self {
                    (value.setKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for containsUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<containsUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: containsUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for containsUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for containsUintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = containsUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "containsUint(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [49u8, 11u8, 136u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decrementInt(bytes32,int256)` and selector `0x6fae54f0`.
```solidity
function decrementInt(bytes32 key, int256 value) external returns (int256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decrementIntCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`decrementInt(bytes32,int256)`](decrementIntCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decrementIntReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decrementIntCall> for UnderlyingRustTuple<'_> {
                fn from(value: decrementIntCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decrementIntCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decrementIntReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decrementIntReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decrementIntReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decrementIntCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decrementIntReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decrementInt(bytes32,int256)";
            const SELECTOR: [u8; 4] = [111u8, 174u8, 84u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decrementUint(bytes32,uint256)` and selector `0xe98aabc1`.
```solidity
function decrementUint(bytes32 key, uint256 value) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decrementUintCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`decrementUint(bytes32,uint256)`](decrementUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decrementUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decrementUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: decrementUintCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decrementUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decrementUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decrementUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decrementUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decrementUintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decrementUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decrementUint(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [233u8, 138u8, 171u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAddress(bytes32)` and selector `0x21f8a721`.
```solidity
function getAddress(bytes32 key) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAddressCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getAddress(bytes32)`](getAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAddressReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAddressCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAddressCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAddress(bytes32)";
            const SELECTOR: [u8; 4] = [33u8, 248u8, 167u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAddressArray(bytes32)` and selector `0x5948f733`.
```solidity
function getAddressArray(bytes32 key) external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAddressArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getAddressArray(bytes32)`](getAddressArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAddressArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAddressArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAddressArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAddressArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAddressArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAddressArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAddressArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAddressArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAddressArrayReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAddressArray(bytes32)";
            const SELECTOR: [u8; 4] = [89u8, 72u8, 247u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAddressCount(bytes32)` and selector `0x35ea8059`.
```solidity
function getAddressCount(bytes32 setKey) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAddressCountCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getAddressCount(bytes32)`](getAddressCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAddressCountReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAddressCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAddressCountCall) -> Self {
                    (value.setKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAddressCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { setKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAddressCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAddressCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAddressCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAddressCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAddressCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAddressCount(bytes32)";
            const SELECTOR: [u8; 4] = [53u8, 234u8, 128u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAddressValuesAt(bytes32,uint256,uint256)` and selector `0xe7e4148e`.
```solidity
function getAddressValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAddressValuesAtCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub start: alloy::sol_types::private::primitives::aliases::U256,
        pub end: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getAddressValuesAt(bytes32,uint256,uint256)`](getAddressValuesAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAddressValuesAtReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAddressValuesAtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAddressValuesAtCall) -> Self {
                    (value.setKey, value.start, value.end)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAddressValuesAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        start: tuple.1,
                        end: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAddressValuesAtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAddressValuesAtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAddressValuesAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAddressValuesAtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAddressValuesAtReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAddressValuesAt(bytes32,uint256,uint256)";
            const SELECTOR: [u8; 4] = [231u8, 228u8, 20u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.start),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.end),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBool(bytes32)` and selector `0x7ae1cfca`.
```solidity
function getBool(bytes32 key) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBoolCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getBool(bytes32)`](getBoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBoolReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBoolCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBoolCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBoolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBoolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBoolCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBoolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBool(bytes32)";
            const SELECTOR: [u8; 4] = [122u8, 225u8, 207u8, 202u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBoolArray(bytes32)` and selector `0x116bb929`.
```solidity
function getBoolArray(bytes32 key) external view returns (bool[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBoolArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getBoolArray(bytes32)`](getBoolArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBoolArrayReturn {
        pub _0: alloy::sol_types::private::Vec<bool>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBoolArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBoolArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBoolArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<bool>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBoolArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBoolArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBoolArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBoolArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBoolArrayReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBoolArray(bytes32)";
            const SELECTOR: [u8; 4] = [17u8, 107u8, 185u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBytes32(bytes32)` and selector `0xa6ed563e`.
```solidity
function getBytes32(bytes32 key) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBytes32Call {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getBytes32(bytes32)`](getBytes32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBytes32Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBytes32Call> for UnderlyingRustTuple<'_> {
                fn from(value: getBytes32Call) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBytes32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBytes32Return> for UnderlyingRustTuple<'_> {
                fn from(value: getBytes32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBytes32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBytes32Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBytes32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBytes32(bytes32)";
            const SELECTOR: [u8; 4] = [166u8, 237u8, 86u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBytes32Array(bytes32)` and selector `0xdd031997`.
```solidity
function getBytes32Array(bytes32 key) external view returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBytes32ArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getBytes32Array(bytes32)`](getBytes32ArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBytes32ArrayReturn {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBytes32ArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBytes32ArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBytes32ArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBytes32ArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBytes32ArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBytes32ArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBytes32ArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBytes32ArrayReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBytes32Array(bytes32)";
            const SELECTOR: [u8; 4] = [221u8, 3u8, 25u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBytes32Count(bytes32)` and selector `0xf3903b9f`.
```solidity
function getBytes32Count(bytes32 setKey) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBytes32CountCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getBytes32Count(bytes32)`](getBytes32CountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBytes32CountReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBytes32CountCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBytes32CountCall) -> Self {
                    (value.setKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBytes32CountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { setKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBytes32CountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBytes32CountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBytes32CountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBytes32CountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBytes32CountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBytes32Count(bytes32)";
            const SELECTOR: [u8; 4] = [243u8, 144u8, 59u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBytes32ValuesAt(bytes32,uint256,uint256)` and selector `0xf069052a`.
```solidity
function getBytes32ValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBytes32ValuesAtCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub start: alloy::sol_types::private::primitives::aliases::U256,
        pub end: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getBytes32ValuesAt(bytes32,uint256,uint256)`](getBytes32ValuesAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBytes32ValuesAtReturn {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBytes32ValuesAtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBytes32ValuesAtCall) -> Self {
                    (value.setKey, value.start, value.end)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBytes32ValuesAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        start: tuple.1,
                        end: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBytes32ValuesAtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBytes32ValuesAtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBytes32ValuesAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBytes32ValuesAtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBytes32ValuesAtReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBytes32ValuesAt(bytes32,uint256,uint256)";
            const SELECTOR: [u8; 4] = [240u8, 105u8, 5u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.start),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.end),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getInt(bytes32)` and selector `0xdc97d962`.
```solidity
function getInt(bytes32 key) external view returns (int256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getIntCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getInt(bytes32)`](getIntCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getIntReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getIntCall> for UnderlyingRustTuple<'_> {
                fn from(value: getIntCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getIntCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getIntReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getIntReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getIntReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getIntCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getIntReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getInt(bytes32)";
            const SELECTOR: [u8; 4] = [220u8, 151u8, 217u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getIntArray(bytes32)` and selector `0x2d2899b6`.
```solidity
function getIntArray(bytes32 key) external view returns (int256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getIntArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getIntArray(bytes32)`](getIntArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getIntArrayReturn {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::I256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getIntArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: getIntArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getIntArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getIntArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getIntArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getIntArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getIntArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getIntArrayReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getIntArray(bytes32)";
            const SELECTOR: [u8; 4] = [45u8, 40u8, 153u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getString(bytes32)` and selector `0x986e791a`.
```solidity
function getString(bytes32 key) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getStringCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getString(bytes32)`](getStringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getStringReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getStringCall> for UnderlyingRustTuple<'_> {
                fn from(value: getStringCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getStringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getStringReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getStringReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getStringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getStringCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getStringReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getString(bytes32)";
            const SELECTOR: [u8; 4] = [152u8, 110u8, 121u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getStringArray(bytes32)` and selector `0x01677da2`.
```solidity
function getStringArray(bytes32 key) external view returns (string[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getStringArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getStringArray(bytes32)`](getStringArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getStringArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getStringArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: getStringArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getStringArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getStringArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getStringArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getStringArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getStringArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getStringArrayReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getStringArray(bytes32)";
            const SELECTOR: [u8; 4] = [1u8, 103u8, 125u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getUint(bytes32)` and selector `0xbd02d0f5`.
```solidity
function getUint(bytes32 key) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUintCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getUint(bytes32)`](getUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: getUintCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUintCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUint(bytes32)";
            const SELECTOR: [u8; 4] = [189u8, 2u8, 208u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getUintArray(bytes32)` and selector `0x86ac6bdf`.
```solidity
function getUintArray(bytes32 key) external view returns (uint256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUintArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getUintArray(bytes32)`](getUintArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUintArrayReturn {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUintArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: getUintArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUintArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUintArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getUintArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUintArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUintArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getUintArrayReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUintArray(bytes32)";
            const SELECTOR: [u8; 4] = [134u8, 172u8, 107u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getUintCount(bytes32)` and selector `0x065f21a7`.
```solidity
function getUintCount(bytes32 setKey) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUintCountCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getUintCount(bytes32)`](getUintCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUintCountReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUintCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: getUintCountCall) -> Self {
                    (value.setKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUintCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { setKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUintCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getUintCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUintCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUintCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getUintCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUintCount(bytes32)";
            const SELECTOR: [u8; 4] = [6u8, 95u8, 33u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getUintValuesAt(bytes32,uint256,uint256)` and selector `0x7026d42c`.
```solidity
function getUintValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (uint256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUintValuesAtCall {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub start: alloy::sol_types::private::primitives::aliases::U256,
        pub end: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getUintValuesAt(bytes32,uint256,uint256)`](getUintValuesAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getUintValuesAtReturn {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUintValuesAtCall> for UnderlyingRustTuple<'_> {
                fn from(value: getUintValuesAtCall) -> Self {
                    (value.setKey, value.start, value.end)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getUintValuesAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        start: tuple.1,
                        end: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getUintValuesAtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getUintValuesAtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getUintValuesAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getUintValuesAtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getUintValuesAtReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getUintValuesAt(bytes32,uint256,uint256)";
            const SELECTOR: [u8; 4] = [112u8, 38u8, 212u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.start),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.end),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `incrementInt(bytes32,int256)` and selector `0xcbb093dd`.
```solidity
function incrementInt(bytes32 key, int256 value) external returns (int256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementIntCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`incrementInt(bytes32,int256)`](incrementIntCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementIntReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementIntCall> for UnderlyingRustTuple<'_> {
                fn from(value: incrementIntCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementIntCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementIntReturn> for UnderlyingRustTuple<'_> {
                fn from(value: incrementIntReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementIntReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for incrementIntCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = incrementIntReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "incrementInt(bytes32,int256)";
            const SELECTOR: [u8; 4] = [203u8, 176u8, 147u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `incrementUint(bytes32,uint256)` and selector `0x340dbab3`.
```solidity
function incrementUint(bytes32 key, uint256 value) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementUintCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`incrementUint(bytes32,uint256)`](incrementUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct incrementUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: incrementUintCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<incrementUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: incrementUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for incrementUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for incrementUintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = incrementUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "incrementUint(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [52u8, 13u8, 186u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `intArrayValues(bytes32,uint256)` and selector `0x6339734d`.
```solidity
function intArrayValues(bytes32, uint256) external view returns (int256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct intArrayValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`intArrayValues(bytes32,uint256)`](intArrayValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct intArrayValuesReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<intArrayValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: intArrayValuesCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for intArrayValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<intArrayValuesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: intArrayValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for intArrayValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for intArrayValuesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = intArrayValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "intArrayValues(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [99u8, 57u8, 115u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `intValues(bytes32)` and selector `0x743df325`.
```solidity
function intValues(bytes32) external view returns (int256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct intValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`intValues(bytes32)`](intValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct intValuesReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<intValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: intValuesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for intValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<intValuesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: intValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for intValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for intValuesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = intValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "intValues(bytes32)";
            const SELECTOR: [u8; 4] = [116u8, 61u8, 243u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeAddress(bytes32,address)` and selector `0x69721d41`.
```solidity
function removeAddress(bytes32 setKey, address value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAddress_0Call {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeAddress(bytes32,address)`](removeAddress_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAddress_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAddress_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: removeAddress_0Call) -> Self {
                    (value.setKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeAddress_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAddress_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeAddress_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeAddress_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeAddress_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeAddress_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeAddress(bytes32,address)";
            const SELECTOR: [u8; 4] = [105u8, 114u8, 29u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeAddress(bytes32)` and selector `0x9faf6fb6`.
```solidity
function removeAddress(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAddress_1Call {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeAddress(bytes32)`](removeAddress_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAddress_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAddress_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: removeAddress_1Call) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeAddress_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAddress_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeAddress_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeAddress_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeAddress_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeAddress_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeAddress(bytes32)";
            const SELECTOR: [u8; 4] = [159u8, 175u8, 111u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeAddressArray(bytes32)` and selector `0xc1dc9182`.
```solidity
function removeAddressArray(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAddressArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeAddressArray(bytes32)`](removeAddressArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAddressArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAddressArrayCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeAddressArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeAddressArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAddressArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeAddressArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeAddressArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeAddressArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeAddressArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeAddressArray(bytes32)";
            const SELECTOR: [u8; 4] = [193u8, 220u8, 145u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeBool(bytes32)` and selector `0x9fe7ac12`.
```solidity
function removeBool(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBoolCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeBool(bytes32)`](removeBoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBoolReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBoolCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeBoolCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBoolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeBoolReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeBoolCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeBoolReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeBool(bytes32)";
            const SELECTOR: [u8; 4] = [159u8, 231u8, 172u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeBoolArray(bytes32)` and selector `0xf51fc0d9`.
```solidity
function removeBoolArray(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBoolArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeBoolArray(bytes32)`](removeBoolArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBoolArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBoolArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeBoolArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBoolArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBoolArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeBoolArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeBoolArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeBoolArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeBoolArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeBoolArray(bytes32)";
            const SELECTOR: [u8; 4] = [245u8, 31u8, 192u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeBytes32(bytes32,bytes32)` and selector `0x9921c3cc`.
```solidity
function removeBytes32(bytes32 setKey, bytes32 value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBytes32_0Call {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeBytes32(bytes32,bytes32)`](removeBytes32_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBytes32_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBytes32_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: removeBytes32_0Call) -> Self {
                    (value.setKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBytes32_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBytes32_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeBytes32_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeBytes32_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeBytes32_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeBytes32_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeBytes32(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [153u8, 33u8, 195u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeBytes32(bytes32)` and selector `0xcf6a8722`.
```solidity
function removeBytes32(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBytes32_1Call {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeBytes32(bytes32)`](removeBytes32_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBytes32_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBytes32_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: removeBytes32_1Call) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBytes32_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBytes32_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeBytes32_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeBytes32_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeBytes32_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeBytes32_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeBytes32(bytes32)";
            const SELECTOR: [u8; 4] = [207u8, 106u8, 135u8, 34u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeBytes32Array(bytes32)` and selector `0xbf7f035a`.
```solidity
function removeBytes32Array(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBytes32ArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeBytes32Array(bytes32)`](removeBytes32ArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBytes32ArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBytes32ArrayCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeBytes32ArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeBytes32ArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBytes32ArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeBytes32ArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeBytes32ArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeBytes32ArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeBytes32ArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeBytes32Array(bytes32)";
            const SELECTOR: [u8; 4] = [191u8, 127u8, 3u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeInt(bytes32)` and selector `0xe62461ce`.
```solidity
function removeInt(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeIntCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeInt(bytes32)`](removeIntCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeIntReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeIntCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeIntCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeIntCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeIntReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeIntReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeIntReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeIntCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeIntReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeInt(bytes32)";
            const SELECTOR: [u8; 4] = [230u8, 36u8, 97u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeIntArray(bytes32)` and selector `0x499ea50e`.
```solidity
function removeIntArray(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeIntArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeIntArray(bytes32)`](removeIntArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeIntArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeIntArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeIntArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeIntArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeIntArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeIntArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeIntArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeIntArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeIntArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeIntArray(bytes32)";
            const SELECTOR: [u8; 4] = [73u8, 158u8, 165u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeString(bytes32)` and selector `0xcc50eadd`.
```solidity
function removeString(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeStringCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeString(bytes32)`](removeStringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeStringReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeStringCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeStringCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeStringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeStringReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeStringReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeStringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeStringCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeStringReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeString(bytes32)";
            const SELECTOR: [u8; 4] = [204u8, 80u8, 234u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeStringArray(bytes32)` and selector `0xe208a70d`.
```solidity
function removeStringArray(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeStringArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeStringArray(bytes32)`](removeStringArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeStringArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeStringArrayCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeStringArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeStringArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeStringArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeStringArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeStringArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeStringArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeStringArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeStringArray(bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 8u8, 167u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeUint(bytes32)` and selector `0x42c3bd96`.
```solidity
function removeUint(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeUint_0Call {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeUint(bytes32)`](removeUint_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeUint_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeUint_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: removeUint_0Call) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeUint_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeUint_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: removeUint_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeUint_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeUint_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeUint_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeUint(bytes32)";
            const SELECTOR: [u8; 4] = [66u8, 195u8, 189u8, 150u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeUint(bytes32,uint256)` and selector `0x93266f9a`.
```solidity
function removeUint(bytes32 setKey, uint256 value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeUint_1Call {
        pub setKey: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`removeUint(bytes32,uint256)`](removeUint_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeUint_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeUint_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: removeUint_1Call) -> Self {
                    (value.setKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeUint_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        setKey: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeUint_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: removeUint_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeUint_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeUint_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeUint_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeUint(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [147u8, 38u8, 111u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.setKey),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeUintArray(bytes32)` and selector `0xbe43caa3`.
```solidity
function removeUintArray(bytes32 key) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeUintArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`removeUintArray(bytes32)`](removeUintArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeUintArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeUintArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeUintArrayCall) -> Self {
                    (value.key,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeUintArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { key: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeUintArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeUintArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeUintArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeUintArrayCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeUintArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeUintArray(bytes32)";
            const SELECTOR: [u8; 4] = [190u8, 67u8, 202u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `roleStore()` and selector `0x4a4a7b04`.
```solidity
function roleStore() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct roleStoreCall {}
    ///Container type for the return parameters of the [`roleStore()`](roleStoreCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct roleStoreReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<roleStoreCall> for UnderlyingRustTuple<'_> {
                fn from(value: roleStoreCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for roleStoreCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<roleStoreReturn> for UnderlyingRustTuple<'_> {
                fn from(value: roleStoreReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for roleStoreReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for roleStoreCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = roleStoreReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "roleStore()";
            const SELECTOR: [u8; 4] = [74u8, 74u8, 123u8, 4u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAddress(bytes32,address)` and selector `0xca446dd9`.
```solidity
function setAddress(bytes32 key, address value) external returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAddressCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setAddress(bytes32,address)`](setAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAddressReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: setAddressCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAddress(bytes32,address)";
            const SELECTOR: [u8; 4] = [202u8, 68u8, 109u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAddressArray(bytes32,address[])` and selector `0xec672cf6`.
```solidity
function setAddressArray(bytes32 key, address[] memory value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAddressArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    ///Container type for the return parameters of the [`setAddressArray(bytes32,address[])`](setAddressArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAddressArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAddressArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: setAddressArrayCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setAddressArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAddressArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAddressArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAddressArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAddressArrayCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAddressArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAddressArray(bytes32,address[])";
            const SELECTOR: [u8; 4] = [236u8, 103u8, 44u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBool(bytes32,bool)` and selector `0xabfdcced`.
```solidity
function setBool(bytes32 key, bool value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBoolCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: bool,
    }
    ///Container type for the return parameters of the [`setBool(bytes32,bool)`](setBoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBoolReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBoolCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBoolCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBoolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBoolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBoolCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBoolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBool(bytes32,bool)";
            const SELECTOR: [u8; 4] = [171u8, 253u8, 204u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBoolArray(bytes32,bool[])` and selector `0x35d4d407`.
```solidity
function setBoolArray(bytes32 key, bool[] memory value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBoolArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`setBoolArray(bytes32,bool[])`](setBoolArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBoolArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<bool>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBoolArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBoolArrayCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBoolArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBoolArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBoolArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBoolArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBoolArrayCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBoolArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBoolArray(bytes32,bool[])";
            const SELECTOR: [u8; 4] = [53u8, 212u8, 212u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBytes32(bytes32,bytes32)` and selector `0x4e91db08`.
```solidity
function setBytes32(bytes32 key, bytes32 value) external returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBytes32Call {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`setBytes32(bytes32,bytes32)`](setBytes32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBytes32Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBytes32Call> for UnderlyingRustTuple<'_> {
                fn from(value: setBytes32Call) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBytes32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBytes32Return> for UnderlyingRustTuple<'_> {
                fn from(value: setBytes32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBytes32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBytes32Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBytes32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBytes32(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [78u8, 145u8, 219u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBytes32Array(bytes32,bytes32[])` and selector `0x26004846`.
```solidity
function setBytes32Array(bytes32 key, bytes32[] memory value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBytes32ArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`setBytes32Array(bytes32,bytes32[])`](setBytes32ArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBytes32ArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBytes32ArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBytes32ArrayCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBytes32ArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBytes32ArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBytes32ArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBytes32ArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBytes32ArrayCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBytes32ArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBytes32Array(bytes32,bytes32[])";
            const SELECTOR: [u8; 4] = [38u8, 0u8, 72u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setInt(bytes32,int256)` and selector `0x3e49bed0`.
```solidity
function setInt(bytes32 key, int256 value) external returns (int256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setIntCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`setInt(bytes32,int256)`](setIntCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setIntReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setIntCall> for UnderlyingRustTuple<'_> {
                fn from(value: setIntCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setIntCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setIntReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setIntReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setIntReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setIntCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Int<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setIntReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setInt(bytes32,int256)";
            const SELECTOR: [u8; 4] = [62u8, 73u8, 190u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setIntArray(bytes32,int256[])` and selector `0xa9fcf76b`.
```solidity
function setIntArray(bytes32 key, int256[] memory value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setIntArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::I256,
        >,
    }
    ///Container type for the return parameters of the [`setIntArray(bytes32,int256[])`](setIntArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setIntArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setIntArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: setIntArrayCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setIntArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setIntArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setIntArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setIntArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setIntArrayCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setIntArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setIntArray(bytes32,int256[])";
            const SELECTOR: [u8; 4] = [169u8, 252u8, 247u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setString(bytes32,string)` and selector `0x6e899550`.
```solidity
function setString(bytes32 key, string memory value) external returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setStringCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`setString(bytes32,string)`](setStringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setStringReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setStringCall> for UnderlyingRustTuple<'_> {
                fn from(value: setStringCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setStringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setStringReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setStringReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setStringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setStringCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setStringReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setString(bytes32,string)";
            const SELECTOR: [u8; 4] = [110u8, 137u8, 149u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setStringArray(bytes32,string[])` and selector `0x88021a72`.
```solidity
function setStringArray(bytes32 key, string[] memory value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setStringArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    ///Container type for the return parameters of the [`setStringArray(bytes32,string[])`](setStringArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setStringArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setStringArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: setStringArrayCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setStringArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setStringArrayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setStringArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setStringArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setStringArrayCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setStringArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setStringArray(bytes32,string[])";
            const SELECTOR: [u8; 4] = [136u8, 2u8, 26u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setUint(bytes32,uint256)` and selector `0xe2a4853a`.
```solidity
function setUint(bytes32 key, uint256 value) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUintCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setUint(bytes32,uint256)`](setUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: setUintCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setUintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setUint(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [226u8, 164u8, 133u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setUintArray(bytes32,uint256[])` and selector `0x5eb07dbd`.
```solidity
function setUintArray(bytes32 key, uint256[] memory value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUintArrayCall {
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub value: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    ///Container type for the return parameters of the [`setUintArray(bytes32,uint256[])`](setUintArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUintArrayReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUintArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: setUintArrayCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setUintArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUintArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setUintArrayReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setUintArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setUintArrayCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setUintArrayReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setUintArray(bytes32,uint256[])";
            const SELECTOR: [u8; 4] = [94u8, 176u8, 125u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `stringArrayValues(bytes32,uint256)` and selector `0xb8320a08`.
```solidity
function stringArrayValues(bytes32, uint256) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stringArrayValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`stringArrayValues(bytes32,uint256)`](stringArrayValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stringArrayValuesReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stringArrayValuesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: stringArrayValuesCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stringArrayValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stringArrayValuesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: stringArrayValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stringArrayValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stringArrayValuesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stringArrayValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stringArrayValues(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [184u8, 50u8, 10u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `stringValues(bytes32)` and selector `0xf15caeac`.
```solidity
function stringValues(bytes32) external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stringValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`stringValues(bytes32)`](stringValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stringValuesReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stringValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: stringValuesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stringValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stringValuesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stringValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stringValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stringValuesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = stringValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stringValues(bytes32)";
            const SELECTOR: [u8; 4] = [241u8, 92u8, 174u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `uintArrayValues(bytes32,uint256)` and selector `0xc4f00fde`.
```solidity
function uintArrayValues(bytes32, uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct uintArrayValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`uintArrayValues(bytes32,uint256)`](uintArrayValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct uintArrayValuesReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<uintArrayValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: uintArrayValuesCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for uintArrayValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<uintArrayValuesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: uintArrayValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for uintArrayValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for uintArrayValuesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = uintArrayValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "uintArrayValues(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [196u8, 240u8, 15u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `uintValues(bytes32)` and selector `0xd38eebc7`.
```solidity
function uintValues(bytes32) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct uintValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`uintValues(bytes32)`](uintValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct uintValuesReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<uintValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: uintValuesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for uintValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<uintValuesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: uintValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for uintValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for uintValuesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = uintValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "uintValues(bytes32)";
            const SELECTOR: [u8; 4] = [211u8, 142u8, 235u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`DataStore`](self) function calls.
    pub enum DataStoreCalls {
        addAddress(addAddressCall),
        addBytes32(addBytes32Call),
        addUint(addUintCall),
        addressArrayValues(addressArrayValuesCall),
        addressValues(addressValuesCall),
        applyBoundedDeltaToUint(applyBoundedDeltaToUintCall),
        applyDeltaToInt(applyDeltaToIntCall),
        applyDeltaToUint_0(applyDeltaToUint_0Call),
        applyDeltaToUint_1(applyDeltaToUint_1Call),
        boolArrayValues(boolArrayValuesCall),
        boolValues(boolValuesCall),
        bytes32ArrayValues(bytes32ArrayValuesCall),
        bytes32Values(bytes32ValuesCall),
        containsAddress(containsAddressCall),
        containsBytes32(containsBytes32Call),
        containsUint(containsUintCall),
        decrementInt(decrementIntCall),
        decrementUint(decrementUintCall),
        getAddress(getAddressCall),
        getAddressArray(getAddressArrayCall),
        getAddressCount(getAddressCountCall),
        getAddressValuesAt(getAddressValuesAtCall),
        getBool(getBoolCall),
        getBoolArray(getBoolArrayCall),
        getBytes32(getBytes32Call),
        getBytes32Array(getBytes32ArrayCall),
        getBytes32Count(getBytes32CountCall),
        getBytes32ValuesAt(getBytes32ValuesAtCall),
        getInt(getIntCall),
        getIntArray(getIntArrayCall),
        getString(getStringCall),
        getStringArray(getStringArrayCall),
        getUint(getUintCall),
        getUintArray(getUintArrayCall),
        getUintCount(getUintCountCall),
        getUintValuesAt(getUintValuesAtCall),
        incrementInt(incrementIntCall),
        incrementUint(incrementUintCall),
        intArrayValues(intArrayValuesCall),
        intValues(intValuesCall),
        removeAddress_0(removeAddress_0Call),
        removeAddress_1(removeAddress_1Call),
        removeAddressArray(removeAddressArrayCall),
        removeBool(removeBoolCall),
        removeBoolArray(removeBoolArrayCall),
        removeBytes32_0(removeBytes32_0Call),
        removeBytes32_1(removeBytes32_1Call),
        removeBytes32Array(removeBytes32ArrayCall),
        removeInt(removeIntCall),
        removeIntArray(removeIntArrayCall),
        removeString(removeStringCall),
        removeStringArray(removeStringArrayCall),
        removeUint_0(removeUint_0Call),
        removeUint_1(removeUint_1Call),
        removeUintArray(removeUintArrayCall),
        roleStore(roleStoreCall),
        setAddress(setAddressCall),
        setAddressArray(setAddressArrayCall),
        setBool(setBoolCall),
        setBoolArray(setBoolArrayCall),
        setBytes32(setBytes32Call),
        setBytes32Array(setBytes32ArrayCall),
        setInt(setIntCall),
        setIntArray(setIntArrayCall),
        setString(setStringCall),
        setStringArray(setStringArrayCall),
        setUint(setUintCall),
        setUintArray(setUintArrayCall),
        stringArrayValues(stringArrayValuesCall),
        stringValues(stringValuesCall),
        uintArrayValues(uintArrayValuesCall),
        uintValues(uintValuesCall),
    }
    #[automatically_derived]
    impl DataStoreCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 103u8, 125u8, 162u8],
            [6u8, 95u8, 33u8, 167u8],
            [17u8, 107u8, 185u8, 41u8],
            [33u8, 248u8, 167u8, 33u8],
            [34u8, 83u8, 141u8, 174u8],
            [34u8, 248u8, 116u8, 100u8],
            [38u8, 0u8, 72u8, 70u8],
            [45u8, 40u8, 153u8, 182u8],
            [49u8, 11u8, 136u8, 130u8],
            [50u8, 248u8, 91u8, 191u8],
            [52u8, 13u8, 186u8, 179u8],
            [53u8, 212u8, 212u8, 7u8],
            [53u8, 234u8, 128u8, 89u8],
            [61u8, 186u8, 205u8, 26u8],
            [62u8, 73u8, 190u8, 208u8],
            [66u8, 195u8, 189u8, 150u8],
            [68u8, 162u8, 66u8, 177u8],
            [73u8, 158u8, 165u8, 14u8],
            [74u8, 74u8, 123u8, 4u8],
            [78u8, 145u8, 219u8, 8u8],
            [89u8, 72u8, 247u8, 51u8],
            [94u8, 176u8, 125u8, 189u8],
            [99u8, 57u8, 115u8, 77u8],
            [105u8, 114u8, 29u8, 65u8],
            [110u8, 137u8, 149u8, 80u8],
            [111u8, 174u8, 84u8, 240u8],
            [112u8, 38u8, 212u8, 44u8],
            [116u8, 61u8, 243u8, 37u8],
            [122u8, 225u8, 207u8, 202u8],
            [128u8, 170u8, 205u8, 205u8],
            [134u8, 172u8, 107u8, 223u8],
            [136u8, 2u8, 26u8, 114u8],
            [140u8, 164u8, 152u8, 176u8],
            [145u8, 212u8, 64u8, 60u8],
            [147u8, 38u8, 111u8, 154u8],
            [152u8, 110u8, 121u8, 26u8],
            [153u8, 33u8, 195u8, 204u8],
            [159u8, 175u8, 111u8, 182u8],
            [159u8, 231u8, 172u8, 18u8],
            [166u8, 237u8, 86u8, 62u8],
            [169u8, 252u8, 247u8, 107u8],
            [171u8, 253u8, 204u8, 237u8],
            [173u8, 179u8, 83u8, 220u8],
            [179u8, 72u8, 230u8, 57u8],
            [184u8, 50u8, 10u8, 8u8],
            [189u8, 2u8, 208u8, 245u8],
            [190u8, 67u8, 202u8, 163u8],
            [191u8, 73u8, 141u8, 211u8],
            [191u8, 127u8, 3u8, 90u8],
            [193u8, 220u8, 145u8, 130u8],
            [196u8, 240u8, 15u8, 222u8],
            [199u8, 105u8, 209u8, 161u8],
            [200u8, 15u8, 76u8, 98u8],
            [202u8, 68u8, 109u8, 217u8],
            [203u8, 176u8, 147u8, 221u8],
            [204u8, 80u8, 234u8, 221u8],
            [207u8, 106u8, 135u8, 34u8],
            [211u8, 142u8, 235u8, 199u8],
            [213u8, 40u8, 82u8, 175u8],
            [220u8, 151u8, 217u8, 98u8],
            [221u8, 3u8, 25u8, 151u8],
            [226u8, 8u8, 167u8, 13u8],
            [226u8, 164u8, 133u8, 58u8],
            [228u8, 227u8, 108u8, 78u8],
            [230u8, 36u8, 97u8, 206u8],
            [231u8, 228u8, 20u8, 142u8],
            [233u8, 138u8, 171u8, 193u8],
            [236u8, 103u8, 44u8, 246u8],
            [240u8, 105u8, 5u8, 42u8],
            [241u8, 92u8, 174u8, 172u8],
            [243u8, 144u8, 59u8, 159u8],
            [245u8, 31u8, 192u8, 217u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for DataStoreCalls {
        const NAME: &'static str = "DataStoreCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 72usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::addAddress(_) => {
                    <addAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addBytes32(_) => {
                    <addBytes32Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addUint(_) => <addUintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::addressArrayValues(_) => {
                    <addressArrayValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addressValues(_) => {
                    <addressValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::applyBoundedDeltaToUint(_) => {
                    <applyBoundedDeltaToUintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::applyDeltaToInt(_) => {
                    <applyDeltaToIntCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::applyDeltaToUint_0(_) => {
                    <applyDeltaToUint_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::applyDeltaToUint_1(_) => {
                    <applyDeltaToUint_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::boolArrayValues(_) => {
                    <boolArrayValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::boolValues(_) => {
                    <boolValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bytes32ArrayValues(_) => {
                    <bytes32ArrayValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bytes32Values(_) => {
                    <bytes32ValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::containsAddress(_) => {
                    <containsAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::containsBytes32(_) => {
                    <containsBytes32Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::containsUint(_) => {
                    <containsUintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decrementInt(_) => {
                    <decrementIntCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decrementUint(_) => {
                    <decrementUintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAddress(_) => {
                    <getAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAddressArray(_) => {
                    <getAddressArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAddressCount(_) => {
                    <getAddressCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAddressValuesAt(_) => {
                    <getAddressValuesAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBool(_) => <getBoolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getBoolArray(_) => {
                    <getBoolArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBytes32(_) => {
                    <getBytes32Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBytes32Array(_) => {
                    <getBytes32ArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBytes32Count(_) => {
                    <getBytes32CountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBytes32ValuesAt(_) => {
                    <getBytes32ValuesAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getInt(_) => <getIntCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getIntArray(_) => {
                    <getIntArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getString(_) => {
                    <getStringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getStringArray(_) => {
                    <getStringArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUint(_) => <getUintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getUintArray(_) => {
                    <getUintArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUintCount(_) => {
                    <getUintCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getUintValuesAt(_) => {
                    <getUintValuesAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::incrementInt(_) => {
                    <incrementIntCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::incrementUint(_) => {
                    <incrementUintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::intArrayValues(_) => {
                    <intArrayValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::intValues(_) => {
                    <intValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeAddress_0(_) => {
                    <removeAddress_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeAddress_1(_) => {
                    <removeAddress_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeAddressArray(_) => {
                    <removeAddressArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeBool(_) => {
                    <removeBoolCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeBoolArray(_) => {
                    <removeBoolArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeBytes32_0(_) => {
                    <removeBytes32_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeBytes32_1(_) => {
                    <removeBytes32_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeBytes32Array(_) => {
                    <removeBytes32ArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeInt(_) => {
                    <removeIntCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeIntArray(_) => {
                    <removeIntArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeString(_) => {
                    <removeStringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeStringArray(_) => {
                    <removeStringArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeUint_0(_) => {
                    <removeUint_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeUint_1(_) => {
                    <removeUint_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeUintArray(_) => {
                    <removeUintArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::roleStore(_) => {
                    <roleStoreCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAddress(_) => {
                    <setAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAddressArray(_) => {
                    <setAddressArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBool(_) => <setBoolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setBoolArray(_) => {
                    <setBoolArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBytes32(_) => {
                    <setBytes32Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBytes32Array(_) => {
                    <setBytes32ArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setInt(_) => <setIntCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setIntArray(_) => {
                    <setIntArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setString(_) => {
                    <setStringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setStringArray(_) => {
                    <setStringArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setUint(_) => <setUintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setUintArray(_) => {
                    <setUintArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stringArrayValues(_) => {
                    <stringArrayValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stringValues(_) => {
                    <stringValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::uintArrayValues(_) => {
                    <uintArrayValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::uintValues(_) => {
                    <uintValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<DataStoreCalls>] = &[
                {
                    fn getStringArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getStringArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getStringArray)
                    }
                    getStringArray
                },
                {
                    fn getUintCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getUintCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getUintCount)
                    }
                    getUintCount
                },
                {
                    fn getBoolArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getBoolArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getBoolArray)
                    }
                    getBoolArray
                },
                {
                    fn getAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getAddress)
                    }
                    getAddress
                },
                {
                    fn addressValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <addressValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::addressValues)
                    }
                    addressValues
                },
                {
                    fn addressArrayValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <addressArrayValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::addressArrayValues)
                    }
                    addressArrayValues
                },
                {
                    fn setBytes32Array(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setBytes32ArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setBytes32Array)
                    }
                    setBytes32Array
                },
                {
                    fn getIntArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getIntArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getIntArray)
                    }
                    getIntArray
                },
                {
                    fn containsUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <containsUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::containsUint)
                    }
                    containsUint
                },
                {
                    fn applyDeltaToUint_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <applyDeltaToUint_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::applyDeltaToUint_0)
                    }
                    applyDeltaToUint_0
                },
                {
                    fn incrementUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <incrementUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::incrementUint)
                    }
                    incrementUint
                },
                {
                    fn setBoolArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setBoolArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setBoolArray)
                    }
                    setBoolArray
                },
                {
                    fn getAddressCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getAddressCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getAddressCount)
                    }
                    getAddressCount
                },
                {
                    fn applyDeltaToUint_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <applyDeltaToUint_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::applyDeltaToUint_1)
                    }
                    applyDeltaToUint_1
                },
                {
                    fn setInt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setIntCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setInt)
                    }
                    setInt
                },
                {
                    fn removeUint_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeUint_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeUint_0)
                    }
                    removeUint_0
                },
                {
                    fn boolValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <boolValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::boolValues)
                    }
                    boolValues
                },
                {
                    fn removeIntArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeIntArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeIntArray)
                    }
                    removeIntArray
                },
                {
                    fn roleStore(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <roleStoreCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::roleStore)
                    }
                    roleStore
                },
                {
                    fn setBytes32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setBytes32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setBytes32)
                    }
                    setBytes32
                },
                {
                    fn getAddressArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getAddressArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getAddressArray)
                    }
                    getAddressArray
                },
                {
                    fn setUintArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setUintArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setUintArray)
                    }
                    setUintArray
                },
                {
                    fn intArrayValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <intArrayValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::intArrayValues)
                    }
                    intArrayValues
                },
                {
                    fn removeAddress_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeAddress_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeAddress_0)
                    }
                    removeAddress_0
                },
                {
                    fn setString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setStringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setString)
                    }
                    setString
                },
                {
                    fn decrementInt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <decrementIntCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::decrementInt)
                    }
                    decrementInt
                },
                {
                    fn getUintValuesAt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getUintValuesAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getUintValuesAt)
                    }
                    getUintValuesAt
                },
                {
                    fn intValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <intValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::intValues)
                    }
                    intValues
                },
                {
                    fn getBool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getBoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getBool)
                    }
                    getBool
                },
                {
                    fn boolArrayValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <boolArrayValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::boolArrayValues)
                    }
                    boolArrayValues
                },
                {
                    fn getUintArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getUintArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getUintArray)
                    }
                    getUintArray
                },
                {
                    fn setStringArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setStringArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setStringArray)
                    }
                    setStringArray
                },
                {
                    fn applyBoundedDeltaToUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <applyBoundedDeltaToUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::applyBoundedDeltaToUint)
                    }
                    applyBoundedDeltaToUint
                },
                {
                    fn containsBytes32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <containsBytes32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::containsBytes32)
                    }
                    containsBytes32
                },
                {
                    fn removeUint_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeUint_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeUint_1)
                    }
                    removeUint_1
                },
                {
                    fn getString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getStringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getString)
                    }
                    getString
                },
                {
                    fn removeBytes32_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeBytes32_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeBytes32_0)
                    }
                    removeBytes32_0
                },
                {
                    fn removeAddress_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeAddress_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeAddress_1)
                    }
                    removeAddress_1
                },
                {
                    fn removeBool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeBoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeBool)
                    }
                    removeBool
                },
                {
                    fn getBytes32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getBytes32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getBytes32)
                    }
                    getBytes32
                },
                {
                    fn setIntArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setIntArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setIntArray)
                    }
                    setIntArray
                },
                {
                    fn setBool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setBoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setBool)
                    }
                    setBool
                },
                {
                    fn addUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <addUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::addUint)
                    }
                    addUint
                },
                {
                    fn addAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <addAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::addAddress)
                    }
                    addAddress
                },
                {
                    fn stringArrayValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <stringArrayValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::stringArrayValues)
                    }
                    stringArrayValues
                },
                {
                    fn getUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getUint)
                    }
                    getUint
                },
                {
                    fn removeUintArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeUintArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeUintArray)
                    }
                    removeUintArray
                },
                {
                    fn bytes32ArrayValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <bytes32ArrayValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::bytes32ArrayValues)
                    }
                    bytes32ArrayValues
                },
                {
                    fn removeBytes32Array(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeBytes32ArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeBytes32Array)
                    }
                    removeBytes32Array
                },
                {
                    fn removeAddressArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeAddressArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeAddressArray)
                    }
                    removeAddressArray
                },
                {
                    fn uintArrayValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <uintArrayValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::uintArrayValues)
                    }
                    uintArrayValues
                },
                {
                    fn containsAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <containsAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::containsAddress)
                    }
                    containsAddress
                },
                {
                    fn addBytes32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <addBytes32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::addBytes32)
                    }
                    addBytes32
                },
                {
                    fn setAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setAddress)
                    }
                    setAddress
                },
                {
                    fn incrementInt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <incrementIntCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::incrementInt)
                    }
                    incrementInt
                },
                {
                    fn removeString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeStringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeString)
                    }
                    removeString
                },
                {
                    fn removeBytes32_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeBytes32_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeBytes32_1)
                    }
                    removeBytes32_1
                },
                {
                    fn uintValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <uintValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::uintValues)
                    }
                    uintValues
                },
                {
                    fn bytes32Values(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <bytes32ValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::bytes32Values)
                    }
                    bytes32Values
                },
                {
                    fn getInt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getIntCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getInt)
                    }
                    getInt
                },
                {
                    fn getBytes32Array(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getBytes32ArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getBytes32Array)
                    }
                    getBytes32Array
                },
                {
                    fn removeStringArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeStringArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeStringArray)
                    }
                    removeStringArray
                },
                {
                    fn setUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setUint)
                    }
                    setUint
                },
                {
                    fn applyDeltaToInt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <applyDeltaToIntCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::applyDeltaToInt)
                    }
                    applyDeltaToInt
                },
                {
                    fn removeInt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeIntCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeInt)
                    }
                    removeInt
                },
                {
                    fn getAddressValuesAt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getAddressValuesAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getAddressValuesAt)
                    }
                    getAddressValuesAt
                },
                {
                    fn decrementUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <decrementUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::decrementUint)
                    }
                    decrementUint
                },
                {
                    fn setAddressArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <setAddressArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::setAddressArray)
                    }
                    setAddressArray
                },
                {
                    fn getBytes32ValuesAt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getBytes32ValuesAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getBytes32ValuesAt)
                    }
                    getBytes32ValuesAt
                },
                {
                    fn stringValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <stringValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::stringValues)
                    }
                    stringValues
                },
                {
                    fn getBytes32Count(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <getBytes32CountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::getBytes32Count)
                    }
                    getBytes32Count
                },
                {
                    fn removeBoolArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreCalls> {
                        <removeBoolArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreCalls::removeBoolArray)
                    }
                    removeBoolArray
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::addAddress(inner) => {
                    <addAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::addBytes32(inner) => {
                    <addBytes32Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::addUint(inner) => {
                    <addUintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::addressArrayValues(inner) => {
                    <addressArrayValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addressValues(inner) => {
                    <addressValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::applyBoundedDeltaToUint(inner) => {
                    <applyBoundedDeltaToUintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::applyDeltaToInt(inner) => {
                    <applyDeltaToIntCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::applyDeltaToUint_0(inner) => {
                    <applyDeltaToUint_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::applyDeltaToUint_1(inner) => {
                    <applyDeltaToUint_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::boolArrayValues(inner) => {
                    <boolArrayValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::boolValues(inner) => {
                    <boolValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bytes32ArrayValues(inner) => {
                    <bytes32ArrayValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bytes32Values(inner) => {
                    <bytes32ValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::containsAddress(inner) => {
                    <containsAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::containsBytes32(inner) => {
                    <containsBytes32Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::containsUint(inner) => {
                    <containsUintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decrementInt(inner) => {
                    <decrementIntCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decrementUint(inner) => {
                    <decrementUintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAddress(inner) => {
                    <getAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getAddressArray(inner) => {
                    <getAddressArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAddressCount(inner) => {
                    <getAddressCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAddressValuesAt(inner) => {
                    <getAddressValuesAtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBool(inner) => {
                    <getBoolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getBoolArray(inner) => {
                    <getBoolArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBytes32(inner) => {
                    <getBytes32Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getBytes32Array(inner) => {
                    <getBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBytes32Count(inner) => {
                    <getBytes32CountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBytes32ValuesAt(inner) => {
                    <getBytes32ValuesAtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getInt(inner) => {
                    <getIntCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getIntArray(inner) => {
                    <getIntArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getString(inner) => {
                    <getStringCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getStringArray(inner) => {
                    <getStringArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUint(inner) => {
                    <getUintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getUintArray(inner) => {
                    <getUintArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUintCount(inner) => {
                    <getUintCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getUintValuesAt(inner) => {
                    <getUintValuesAtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::incrementInt(inner) => {
                    <incrementIntCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::incrementUint(inner) => {
                    <incrementUintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::intArrayValues(inner) => {
                    <intArrayValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::intValues(inner) => {
                    <intValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeAddress_0(inner) => {
                    <removeAddress_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeAddress_1(inner) => {
                    <removeAddress_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeAddressArray(inner) => {
                    <removeAddressArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeBool(inner) => {
                    <removeBoolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeBoolArray(inner) => {
                    <removeBoolArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeBytes32_0(inner) => {
                    <removeBytes32_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeBytes32_1(inner) => {
                    <removeBytes32_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeBytes32Array(inner) => {
                    <removeBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeInt(inner) => {
                    <removeIntCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeIntArray(inner) => {
                    <removeIntArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeString(inner) => {
                    <removeStringCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeStringArray(inner) => {
                    <removeStringArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeUint_0(inner) => {
                    <removeUint_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeUint_1(inner) => {
                    <removeUint_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeUintArray(inner) => {
                    <removeUintArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::roleStore(inner) => {
                    <roleStoreCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setAddress(inner) => {
                    <setAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setAddressArray(inner) => {
                    <setAddressArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBool(inner) => {
                    <setBoolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBoolArray(inner) => {
                    <setBoolArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBytes32(inner) => {
                    <setBytes32Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBytes32Array(inner) => {
                    <setBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setInt(inner) => {
                    <setIntCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setIntArray(inner) => {
                    <setIntArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setString(inner) => {
                    <setStringCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setStringArray(inner) => {
                    <setStringArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setUint(inner) => {
                    <setUintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setUintArray(inner) => {
                    <setUintArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stringArrayValues(inner) => {
                    <stringArrayValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stringValues(inner) => {
                    <stringValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::uintArrayValues(inner) => {
                    <uintArrayValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::uintValues(inner) => {
                    <uintValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::addAddress(inner) => {
                    <addAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addBytes32(inner) => {
                    <addBytes32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addUint(inner) => {
                    <addUintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::addressArrayValues(inner) => {
                    <addressArrayValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addressValues(inner) => {
                    <addressValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::applyBoundedDeltaToUint(inner) => {
                    <applyBoundedDeltaToUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::applyDeltaToInt(inner) => {
                    <applyDeltaToIntCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::applyDeltaToUint_0(inner) => {
                    <applyDeltaToUint_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::applyDeltaToUint_1(inner) => {
                    <applyDeltaToUint_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::boolArrayValues(inner) => {
                    <boolArrayValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::boolValues(inner) => {
                    <boolValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bytes32ArrayValues(inner) => {
                    <bytes32ArrayValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bytes32Values(inner) => {
                    <bytes32ValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::containsAddress(inner) => {
                    <containsAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::containsBytes32(inner) => {
                    <containsBytes32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::containsUint(inner) => {
                    <containsUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decrementInt(inner) => {
                    <decrementIntCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decrementUint(inner) => {
                    <decrementUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAddress(inner) => {
                    <getAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAddressArray(inner) => {
                    <getAddressArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAddressCount(inner) => {
                    <getAddressCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAddressValuesAt(inner) => {
                    <getAddressValuesAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBool(inner) => {
                    <getBoolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getBoolArray(inner) => {
                    <getBoolArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBytes32(inner) => {
                    <getBytes32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBytes32Array(inner) => {
                    <getBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBytes32Count(inner) => {
                    <getBytes32CountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBytes32ValuesAt(inner) => {
                    <getBytes32ValuesAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getInt(inner) => {
                    <getIntCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getIntArray(inner) => {
                    <getIntArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getString(inner) => {
                    <getStringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getStringArray(inner) => {
                    <getStringArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUint(inner) => {
                    <getUintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getUintArray(inner) => {
                    <getUintArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUintCount(inner) => {
                    <getUintCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getUintValuesAt(inner) => {
                    <getUintValuesAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::incrementInt(inner) => {
                    <incrementIntCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::incrementUint(inner) => {
                    <incrementUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::intArrayValues(inner) => {
                    <intArrayValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::intValues(inner) => {
                    <intValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeAddress_0(inner) => {
                    <removeAddress_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeAddress_1(inner) => {
                    <removeAddress_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeAddressArray(inner) => {
                    <removeAddressArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeBool(inner) => {
                    <removeBoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeBoolArray(inner) => {
                    <removeBoolArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeBytes32_0(inner) => {
                    <removeBytes32_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeBytes32_1(inner) => {
                    <removeBytes32_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeBytes32Array(inner) => {
                    <removeBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeInt(inner) => {
                    <removeIntCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeIntArray(inner) => {
                    <removeIntArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeString(inner) => {
                    <removeStringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeStringArray(inner) => {
                    <removeStringArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeUint_0(inner) => {
                    <removeUint_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeUint_1(inner) => {
                    <removeUint_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeUintArray(inner) => {
                    <removeUintArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::roleStore(inner) => {
                    <roleStoreCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAddress(inner) => {
                    <setAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAddressArray(inner) => {
                    <setAddressArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBool(inner) => {
                    <setBoolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setBoolArray(inner) => {
                    <setBoolArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBytes32(inner) => {
                    <setBytes32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBytes32Array(inner) => {
                    <setBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setInt(inner) => {
                    <setIntCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setIntArray(inner) => {
                    <setIntArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setString(inner) => {
                    <setStringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setStringArray(inner) => {
                    <setStringArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setUint(inner) => {
                    <setUintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setUintArray(inner) => {
                    <setUintArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stringArrayValues(inner) => {
                    <stringArrayValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stringValues(inner) => {
                    <stringValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::uintArrayValues(inner) => {
                    <uintArrayValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::uintValues(inner) => {
                    <uintValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`DataStore`](self) custom errors.
    pub enum DataStoreErrors {
        SafeCastOverflowedIntToUint(SafeCastOverflowedIntToUint),
        Unauthorized(Unauthorized),
    }
    #[automatically_derived]
    impl DataStoreErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [163u8, 91u8, 21u8, 11u8],
            [168u8, 206u8, 68u8, 50u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for DataStoreErrors {
        const NAME: &'static str = "DataStoreErrors";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 2usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::SafeCastOverflowedIntToUint(_) => {
                    <SafeCastOverflowedIntToUint as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Unauthorized(_) => {
                    <Unauthorized as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<DataStoreErrors>] = &[
                {
                    fn Unauthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn SafeCastOverflowedIntToUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<DataStoreErrors> {
                        <SafeCastOverflowedIntToUint as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(DataStoreErrors::SafeCastOverflowedIntToUint)
                    }
                    SafeCastOverflowedIntToUint
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::SafeCastOverflowedIntToUint(inner) => {
                    <SafeCastOverflowedIntToUint as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::SafeCastOverflowedIntToUint(inner) => {
                    <SafeCastOverflowedIntToUint as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`DataStore`](self) contract instance.

See the [wrapper's documentation](`DataStoreInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> DataStoreInstance<T, P, N> {
        DataStoreInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _roleStore: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<DataStoreInstance<T, P, N>>,
    > {
        DataStoreInstance::<T, P, N>::deploy(provider, _roleStore)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _roleStore: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        DataStoreInstance::<T, P, N>::deploy_builder(provider, _roleStore)
    }
    /**A [`DataStore`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`DataStore`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct DataStoreInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for DataStoreInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("DataStoreInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > DataStoreInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`DataStore`](self) contract instance.

See the [wrapper's documentation](`DataStoreInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _roleStore: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<DataStoreInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider, _roleStore);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _roleStore: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { _roleStore },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> DataStoreInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> DataStoreInstance<T, P, N> {
            DataStoreInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > DataStoreInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`addAddress`] function.
        pub fn addAddress(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, addAddressCall, N> {
            self.call_builder(&addAddressCall { setKey, value })
        }
        ///Creates a new call builder for the [`addBytes32`] function.
        pub fn addBytes32(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, addBytes32Call, N> {
            self.call_builder(&addBytes32Call { setKey, value })
        }
        ///Creates a new call builder for the [`addUint`] function.
        pub fn addUint(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, addUintCall, N> {
            self.call_builder(&addUintCall { setKey, value })
        }
        ///Creates a new call builder for the [`addressArrayValues`] function.
        pub fn addressArrayValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, addressArrayValuesCall, N> {
            self.call_builder(&addressArrayValuesCall { _0, _1 })
        }
        ///Creates a new call builder for the [`addressValues`] function.
        pub fn addressValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, addressValuesCall, N> {
            self.call_builder(&addressValuesCall { _0 })
        }
        ///Creates a new call builder for the [`applyBoundedDeltaToUint`] function.
        pub fn applyBoundedDeltaToUint(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, applyBoundedDeltaToUintCall, N> {
            self.call_builder(
                &applyBoundedDeltaToUintCall {
                    key,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`applyDeltaToInt`] function.
        pub fn applyDeltaToInt(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, applyDeltaToIntCall, N> {
            self.call_builder(&applyDeltaToIntCall { key, value })
        }
        ///Creates a new call builder for the [`applyDeltaToUint_0`] function.
        pub fn applyDeltaToUint_0(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::I256,
            errorMessage: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, applyDeltaToUint_0Call, N> {
            self.call_builder(
                &applyDeltaToUint_0Call {
                    key,
                    value,
                    errorMessage,
                },
            )
        }
        ///Creates a new call builder for the [`applyDeltaToUint_1`] function.
        pub fn applyDeltaToUint_1(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, applyDeltaToUint_1Call, N> {
            self.call_builder(
                &applyDeltaToUint_1Call {
                    key,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`boolArrayValues`] function.
        pub fn boolArrayValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, boolArrayValuesCall, N> {
            self.call_builder(&boolArrayValuesCall { _0, _1 })
        }
        ///Creates a new call builder for the [`boolValues`] function.
        pub fn boolValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, boolValuesCall, N> {
            self.call_builder(&boolValuesCall { _0 })
        }
        ///Creates a new call builder for the [`bytes32ArrayValues`] function.
        pub fn bytes32ArrayValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, bytes32ArrayValuesCall, N> {
            self.call_builder(&bytes32ArrayValuesCall { _0, _1 })
        }
        ///Creates a new call builder for the [`bytes32Values`] function.
        pub fn bytes32Values(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, bytes32ValuesCall, N> {
            self.call_builder(&bytes32ValuesCall { _0 })
        }
        ///Creates a new call builder for the [`containsAddress`] function.
        pub fn containsAddress(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, containsAddressCall, N> {
            self.call_builder(
                &containsAddressCall {
                    setKey,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`containsBytes32`] function.
        pub fn containsBytes32(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, containsBytes32Call, N> {
            self.call_builder(
                &containsBytes32Call {
                    setKey,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`containsUint`] function.
        pub fn containsUint(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, containsUintCall, N> {
            self.call_builder(&containsUintCall { setKey, value })
        }
        ///Creates a new call builder for the [`decrementInt`] function.
        pub fn decrementInt(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, decrementIntCall, N> {
            self.call_builder(&decrementIntCall { key, value })
        }
        ///Creates a new call builder for the [`decrementUint`] function.
        pub fn decrementUint(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, decrementUintCall, N> {
            self.call_builder(&decrementUintCall { key, value })
        }
        ///Creates a new call builder for the [`getAddress`] function.
        pub fn getAddress(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAddressCall, N> {
            self.call_builder(&getAddressCall { key })
        }
        ///Creates a new call builder for the [`getAddressArray`] function.
        pub fn getAddressArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAddressArrayCall, N> {
            self.call_builder(&getAddressArrayCall { key })
        }
        ///Creates a new call builder for the [`getAddressCount`] function.
        pub fn getAddressCount(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAddressCountCall, N> {
            self.call_builder(&getAddressCountCall { setKey })
        }
        ///Creates a new call builder for the [`getAddressValuesAt`] function.
        pub fn getAddressValuesAt(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            start: alloy::sol_types::private::primitives::aliases::U256,
            end: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAddressValuesAtCall, N> {
            self.call_builder(
                &getAddressValuesAtCall {
                    setKey,
                    start,
                    end,
                },
            )
        }
        ///Creates a new call builder for the [`getBool`] function.
        pub fn getBool(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBoolCall, N> {
            self.call_builder(&getBoolCall { key })
        }
        ///Creates a new call builder for the [`getBoolArray`] function.
        pub fn getBoolArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBoolArrayCall, N> {
            self.call_builder(&getBoolArrayCall { key })
        }
        ///Creates a new call builder for the [`getBytes32`] function.
        pub fn getBytes32(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBytes32Call, N> {
            self.call_builder(&getBytes32Call { key })
        }
        ///Creates a new call builder for the [`getBytes32Array`] function.
        pub fn getBytes32Array(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBytes32ArrayCall, N> {
            self.call_builder(&getBytes32ArrayCall { key })
        }
        ///Creates a new call builder for the [`getBytes32Count`] function.
        pub fn getBytes32Count(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBytes32CountCall, N> {
            self.call_builder(&getBytes32CountCall { setKey })
        }
        ///Creates a new call builder for the [`getBytes32ValuesAt`] function.
        pub fn getBytes32ValuesAt(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            start: alloy::sol_types::private::primitives::aliases::U256,
            end: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBytes32ValuesAtCall, N> {
            self.call_builder(
                &getBytes32ValuesAtCall {
                    setKey,
                    start,
                    end,
                },
            )
        }
        ///Creates a new call builder for the [`getInt`] function.
        pub fn getInt(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getIntCall, N> {
            self.call_builder(&getIntCall { key })
        }
        ///Creates a new call builder for the [`getIntArray`] function.
        pub fn getIntArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getIntArrayCall, N> {
            self.call_builder(&getIntArrayCall { key })
        }
        ///Creates a new call builder for the [`getString`] function.
        pub fn getString(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getStringCall, N> {
            self.call_builder(&getStringCall { key })
        }
        ///Creates a new call builder for the [`getStringArray`] function.
        pub fn getStringArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getStringArrayCall, N> {
            self.call_builder(&getStringArrayCall { key })
        }
        ///Creates a new call builder for the [`getUint`] function.
        pub fn getUint(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getUintCall, N> {
            self.call_builder(&getUintCall { key })
        }
        ///Creates a new call builder for the [`getUintArray`] function.
        pub fn getUintArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getUintArrayCall, N> {
            self.call_builder(&getUintArrayCall { key })
        }
        ///Creates a new call builder for the [`getUintCount`] function.
        pub fn getUintCount(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getUintCountCall, N> {
            self.call_builder(&getUintCountCall { setKey })
        }
        ///Creates a new call builder for the [`getUintValuesAt`] function.
        pub fn getUintValuesAt(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            start: alloy::sol_types::private::primitives::aliases::U256,
            end: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getUintValuesAtCall, N> {
            self.call_builder(
                &getUintValuesAtCall {
                    setKey,
                    start,
                    end,
                },
            )
        }
        ///Creates a new call builder for the [`incrementInt`] function.
        pub fn incrementInt(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, incrementIntCall, N> {
            self.call_builder(&incrementIntCall { key, value })
        }
        ///Creates a new call builder for the [`incrementUint`] function.
        pub fn incrementUint(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, incrementUintCall, N> {
            self.call_builder(&incrementUintCall { key, value })
        }
        ///Creates a new call builder for the [`intArrayValues`] function.
        pub fn intArrayValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, intArrayValuesCall, N> {
            self.call_builder(&intArrayValuesCall { _0, _1 })
        }
        ///Creates a new call builder for the [`intValues`] function.
        pub fn intValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, intValuesCall, N> {
            self.call_builder(&intValuesCall { _0 })
        }
        ///Creates a new call builder for the [`removeAddress_0`] function.
        pub fn removeAddress_0(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeAddress_0Call, N> {
            self.call_builder(
                &removeAddress_0Call {
                    setKey,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`removeAddress_1`] function.
        pub fn removeAddress_1(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeAddress_1Call, N> {
            self.call_builder(&removeAddress_1Call { key })
        }
        ///Creates a new call builder for the [`removeAddressArray`] function.
        pub fn removeAddressArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeAddressArrayCall, N> {
            self.call_builder(&removeAddressArrayCall { key })
        }
        ///Creates a new call builder for the [`removeBool`] function.
        pub fn removeBool(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeBoolCall, N> {
            self.call_builder(&removeBoolCall { key })
        }
        ///Creates a new call builder for the [`removeBoolArray`] function.
        pub fn removeBoolArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeBoolArrayCall, N> {
            self.call_builder(&removeBoolArrayCall { key })
        }
        ///Creates a new call builder for the [`removeBytes32_0`] function.
        pub fn removeBytes32_0(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeBytes32_0Call, N> {
            self.call_builder(
                &removeBytes32_0Call {
                    setKey,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`removeBytes32_1`] function.
        pub fn removeBytes32_1(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeBytes32_1Call, N> {
            self.call_builder(&removeBytes32_1Call { key })
        }
        ///Creates a new call builder for the [`removeBytes32Array`] function.
        pub fn removeBytes32Array(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeBytes32ArrayCall, N> {
            self.call_builder(&removeBytes32ArrayCall { key })
        }
        ///Creates a new call builder for the [`removeInt`] function.
        pub fn removeInt(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeIntCall, N> {
            self.call_builder(&removeIntCall { key })
        }
        ///Creates a new call builder for the [`removeIntArray`] function.
        pub fn removeIntArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeIntArrayCall, N> {
            self.call_builder(&removeIntArrayCall { key })
        }
        ///Creates a new call builder for the [`removeString`] function.
        pub fn removeString(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeStringCall, N> {
            self.call_builder(&removeStringCall { key })
        }
        ///Creates a new call builder for the [`removeStringArray`] function.
        pub fn removeStringArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeStringArrayCall, N> {
            self.call_builder(&removeStringArrayCall { key })
        }
        ///Creates a new call builder for the [`removeUint_0`] function.
        pub fn removeUint_0(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeUint_0Call, N> {
            self.call_builder(&removeUint_0Call { key })
        }
        ///Creates a new call builder for the [`removeUint_1`] function.
        pub fn removeUint_1(
            &self,
            setKey: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeUint_1Call, N> {
            self.call_builder(&removeUint_1Call { setKey, value })
        }
        ///Creates a new call builder for the [`removeUintArray`] function.
        pub fn removeUintArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeUintArrayCall, N> {
            self.call_builder(&removeUintArrayCall { key })
        }
        ///Creates a new call builder for the [`roleStore`] function.
        pub fn roleStore(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, roleStoreCall, N> {
            self.call_builder(&roleStoreCall {})
        }
        ///Creates a new call builder for the [`setAddress`] function.
        pub fn setAddress(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAddressCall, N> {
            self.call_builder(&setAddressCall { key, value })
        }
        ///Creates a new call builder for the [`setAddressArray`] function.
        pub fn setAddressArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAddressArrayCall, N> {
            self.call_builder(&setAddressArrayCall { key, value })
        }
        ///Creates a new call builder for the [`setBool`] function.
        pub fn setBool(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBoolCall, N> {
            self.call_builder(&setBoolCall { key, value })
        }
        ///Creates a new call builder for the [`setBoolArray`] function.
        pub fn setBoolArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBoolArrayCall, N> {
            self.call_builder(&setBoolArrayCall { key, value })
        }
        ///Creates a new call builder for the [`setBytes32`] function.
        pub fn setBytes32(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBytes32Call, N> {
            self.call_builder(&setBytes32Call { key, value })
        }
        ///Creates a new call builder for the [`setBytes32Array`] function.
        pub fn setBytes32Array(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBytes32ArrayCall, N> {
            self.call_builder(&setBytes32ArrayCall { key, value })
        }
        ///Creates a new call builder for the [`setInt`] function.
        pub fn setInt(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setIntCall, N> {
            self.call_builder(&setIntCall { key, value })
        }
        ///Creates a new call builder for the [`setIntArray`] function.
        pub fn setIntArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, setIntArrayCall, N> {
            self.call_builder(&setIntArrayCall { key, value })
        }
        ///Creates a new call builder for the [`setString`] function.
        pub fn setString(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, setStringCall, N> {
            self.call_builder(&setStringCall { key, value })
        }
        ///Creates a new call builder for the [`setStringArray`] function.
        pub fn setStringArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setStringArrayCall, N> {
            self.call_builder(&setStringArrayCall { key, value })
        }
        ///Creates a new call builder for the [`setUint`] function.
        pub fn setUint(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setUintCall, N> {
            self.call_builder(&setUintCall { key, value })
        }
        ///Creates a new call builder for the [`setUintArray`] function.
        pub fn setUintArray(
            &self,
            key: alloy::sol_types::private::FixedBytes<32>,
            value: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, setUintArrayCall, N> {
            self.call_builder(&setUintArrayCall { key, value })
        }
        ///Creates a new call builder for the [`stringArrayValues`] function.
        pub fn stringArrayValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, stringArrayValuesCall, N> {
            self.call_builder(&stringArrayValuesCall { _0, _1 })
        }
        ///Creates a new call builder for the [`stringValues`] function.
        pub fn stringValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, stringValuesCall, N> {
            self.call_builder(&stringValuesCall { _0 })
        }
        ///Creates a new call builder for the [`uintArrayValues`] function.
        pub fn uintArrayValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, uintArrayValuesCall, N> {
            self.call_builder(&uintArrayValuesCall { _0, _1 })
        }
        ///Creates a new call builder for the [`uintValues`] function.
        pub fn uintValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, uintValuesCall, N> {
            self.call_builder(&uintValuesCall { _0 })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > DataStoreInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
