/**

Generated by the following Solidity interface...
```solidity
interface PoolStoreUtils {
    function POOL_BANK() external view returns (bytes32);
    function POOL_BORROW_INDEX_0() external view returns (bytes32);
    function POOL_BORROW_INDEX_1() external view returns (bytes32);
    function POOL_BORROW_RATE_0() external view returns (bytes32);
    function POOL_BORROW_RATE_1() external view returns (bytes32);
    function POOL_CONFIGURATION() external view returns (bytes32);
    function POOL_CREATED_TIME_STAMP() external view returns (bytes32);
    function POOL_INTEREST_RATE_STRATEGY() external view returns (bytes32);
    function POOL_LAST_UPDATE_TIME_STAMP() external view returns (bytes32);
    function POOL_SOURCE() external view returns (bytes32);
    function POOL_TOKEN_0() external view returns (bytes32);
    function POOL_TOKEN_1() external view returns (bytes32);
    function POOL_TOTAL_COLLATERAL_0() external view returns (bytes32);
    function POOL_TOTAL_COLLATERAL_1() external view returns (bytes32);
    function POOL_TOTAL_COLLATERAL_WITH_DEBT_0() external view returns (bytes32);
    function POOL_TOTAL_COLLATERAL_WITH_DEBT_1() external view returns (bytes32);
    function POOL_TOTAL_SCALED_DEBT_0() external view returns (bytes32);
    function POOL_TOTAL_SCALED_DEBT_1() external view returns (bytes32);
    function POOL_UNCLAIMED_FEE_0() external view returns (bytes32);
    function POOL_UNCLAIMED_FEE_1() external view returns (bytes32);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "POOL_BANK",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_BORROW_INDEX_0",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_BORROW_INDEX_1",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_BORROW_RATE_0",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_BORROW_RATE_1",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_CONFIGURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_CREATED_TIME_STAMP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_INTEREST_RATE_STRATEGY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_LAST_UPDATE_TIME_STAMP",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_SOURCE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_TOKEN_0",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_TOKEN_1",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_TOTAL_COLLATERAL_0",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_TOTAL_COLLATERAL_1",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_TOTAL_COLLATERAL_WITH_DEBT_0",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_TOTAL_COLLATERAL_WITH_DEBT_1",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_TOTAL_SCALED_DEBT_0",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_TOTAL_SCALED_DEBT_1",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_UNCLAIMED_FEE_0",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "POOL_UNCLAIMED_FEE_1",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod PoolStoreUtils {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6106d0610034600b8282823980515f1a607314602857634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610610132575f3560e01c806367828979116100b4578063d03aa08911610079578063d03aa089146101c0578063daac4cd9146101c8578063e7856ed4146101d0578063f136c395146101d8578063f5db41ee146101e0575f5ffd5b80636782897914610198578063ab234814146101a0578063b7c3c3e2146101a8578063bd35984b146101b0578063cafe8f10146101b8575f5ffd5b8063496bdfbc116100fa578063496bdfbc1461017057806353cdd8ee146101785780635d8b3aaf146101805780635f91ff1014610188578063644c50fe14610190575f5ffd5b80630702316b14610136578063288b33d1146101505780632a04cf47146101585780633082efcb1461016057806345df019114610168575b5f5ffd5b61013e6101e8565b60405190815260200160405180910390f35b61013e610242565b61013e610271565b61013e6102bc565b61013e6102e9565b61013e610320565b61013e610350565b61013e610391565b61013e6103c8565b61013e610400565b61013e61044b565b61013e61048c565b61013e6104cd565b61013e610505565b61013e610546565b61013e61057c565b61013e6105b2565b61013e6105f3565b61013e610629565b61013e610659565b6040516020016102299060208082526017908201527f504f4f4c5f544f54414c5f434f4c4c41544552414c5f30000000000000000000604082015260600190565b6040516020818303038152906040528051906020012081565b604051602001610229906020808252600b908201526a504f4f4c5f534f5552434560a81b604082015260600190565b6040516020016102299060208082526021908201527f504f4f4c5f544f54414c5f434f4c4c41544552414c5f574954485f444542545f6040820152600360fc1b606082015260800190565b60405160200161022990602080825260099082015268504f4f4c5f42414e4b60b81b604082015260600190565b604051602001610229906020808252601390820152720504f4f4c5f424f52524f575f494e4445585f3606c1b604082015260600190565b604051602001610229906020808252600c908201526b504f4f4c5f544f4b454e5f3160a01b604082015260600190565b6040516020016102299060208082526018908201527f504f4f4c5f544f54414c5f5343414c45445f444542545f310000000000000000604082015260600190565b60405160200161022990602080825260139082015272504f4f4c5f424f52524f575f494e4445585f3160681b604082015260600190565b604051602001610229906020808252601490820152730504f4f4c5f554e434c41494d45445f4645455f360641b604082015260600190565b6040516020016102299060208082526021908201527f504f4f4c5f544f54414c5f434f4c4c41544552414c5f574954485f444542545f6040820152603160f81b606082015260800190565b6040516020016102299060208082526017908201527f504f4f4c5f544f54414c5f434f4c4c41544552414c5f31000000000000000000604082015260600190565b604051602001610229906020808252601b908201527f504f4f4c5f494e5445524553545f524154455f53545241544547590000000000604082015260600190565b60405160200161022990602080825260149082015273504f4f4c5f554e434c41494d45445f4645455f3160601b604082015260600190565b6040516020016102299060208082526017908201527f504f4f4c5f435245415445445f54494d455f5354414d50000000000000000000604082015260600190565b60405160200161022990602080825260129082015271504f4f4c5f424f52524f575f524154455f3160701b604082015260600190565b604051602001610229906020808252601290820152712827a7a62fa1a7a72324a3aaa920aa24a7a760711b604082015260600190565b6040516020016102299060208082526018908201527f504f4f4c5f544f54414c5f5343414c45445f444542545f300000000000000000604082015260600190565b604051602001610229906020808252601290820152710504f4f4c5f424f52524f575f524154455f360741b604082015260600190565b604051602001610229906020808252600c908201526b0504f4f4c5f544f4b454e5f360a41b604082015260600190565b604051602001610229906020808252601b908201527f504f4f4c5f4c4153545f5550444154455f54494d455f5354414d50000000000060408201526060019056fea2646970667358221220afbf2eddabf8de48d021e1f6aca4a3e43bf8ab49cbd5b3ce708b010b3495914064736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x06\xD0a\x004`\x0B\x82\x82\x829\x80Q_\x1A`s\x14`(WcNH{q`\xE0\x1B_R_`\x04R`$_\xFD[0_R`s\x81S\x82\x81\xF3\xFEs\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R`\x046\x10a\x012W_5`\xE0\x1C\x80cg\x82\x89y\x11a\0\xB4W\x80c\xD0:\xA0\x89\x11a\0yW\x80c\xD0:\xA0\x89\x14a\x01\xC0W\x80c\xDA\xACL\xD9\x14a\x01\xC8W\x80c\xE7\x85n\xD4\x14a\x01\xD0W\x80c\xF16\xC3\x95\x14a\x01\xD8W\x80c\xF5\xDBA\xEE\x14a\x01\xE0W__\xFD[\x80cg\x82\x89y\x14a\x01\x98W\x80c\xAB#H\x14\x14a\x01\xA0W\x80c\xB7\xC3\xC3\xE2\x14a\x01\xA8W\x80c\xBD5\x98K\x14a\x01\xB0W\x80c\xCA\xFE\x8F\x10\x14a\x01\xB8W__\xFD[\x80cIk\xDF\xBC\x11a\0\xFAW\x80cIk\xDF\xBC\x14a\x01pW\x80cS\xCD\xD8\xEE\x14a\x01xW\x80c]\x8B:\xAF\x14a\x01\x80W\x80c_\x91\xFF\x10\x14a\x01\x88W\x80cdLP\xFE\x14a\x01\x90W__\xFD[\x80c\x07\x021k\x14a\x016W\x80c(\x8B3\xD1\x14a\x01PW\x80c*\x04\xCFG\x14a\x01XW\x80c0\x82\xEF\xCB\x14a\x01`W\x80cE\xDF\x01\x91\x14a\x01hW[__\xFD[a\x01>a\x01\xE8V[`@Q\x90\x81R` \x01`@Q\x80\x91\x03\x90\xF3[a\x01>a\x02BV[a\x01>a\x02qV[a\x01>a\x02\xBCV[a\x01>a\x02\xE9V[a\x01>a\x03 V[a\x01>a\x03PV[a\x01>a\x03\x91V[a\x01>a\x03\xC8V[a\x01>a\x04\0V[a\x01>a\x04KV[a\x01>a\x04\x8CV[a\x01>a\x04\xCDV[a\x01>a\x05\x05V[a\x01>a\x05FV[a\x01>a\x05|V[a\x01>a\x05\xB2V[a\x01>a\x05\xF3V[a\x01>a\x06)V[a\x01>a\x06YV[`@Q` \x01a\x02)\x90` \x80\x82R`\x17\x90\x82\x01R\x7FPOOL_TOTAL_COLLATERAL_0\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81V[`@Q` \x01a\x02)\x90` \x80\x82R`\x0B\x90\x82\x01RjPOOL_SOURCE`\xA8\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`!\x90\x82\x01R\x7FPOOL_TOTAL_COLLATERAL_WITH_DEBT_`@\x82\x01R`\x03`\xFC\x1B``\x82\x01R`\x80\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\t\x90\x82\x01RhPOOL_BANK`\xB8\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x13\x90\x82\x01Rr\x05\x04\xF4\xF4\xC5\xF4$\xF5%$\xF5u\xF4\x94\xE4DU\x85\xF3`l\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x0C\x90\x82\x01RkPOOL_TOKEN_1`\xA0\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x18\x90\x82\x01R\x7FPOOL_TOTAL_SCALED_DEBT_1\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x13\x90\x82\x01RrPOOL_BORROW_INDEX_1`h\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x14\x90\x82\x01Rs\x05\x04\xF4\xF4\xC5\xF5T\xE44\xC4\x14\x94\xD4TE\xF4dTU\xF3`d\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`!\x90\x82\x01R\x7FPOOL_TOTAL_COLLATERAL_WITH_DEBT_`@\x82\x01R`1`\xF8\x1B``\x82\x01R`\x80\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x17\x90\x82\x01R\x7FPOOL_TOTAL_COLLATERAL_1\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x1B\x90\x82\x01R\x7FPOOL_INTEREST_RATE_STRATEGY\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x14\x90\x82\x01RsPOOL_UNCLAIMED_FEE_1``\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x17\x90\x82\x01R\x7FPOOL_CREATED_TIME_STAMP\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x12\x90\x82\x01RqPOOL_BORROW_RATE_1`p\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x12\x90\x82\x01Rq('\xA7\xA6/\xA1\xA7\xA7#$\xA3\xAA\xA9 \xAA$\xA7\xA7`q\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x18\x90\x82\x01R\x7FPOOL_TOTAL_SCALED_DEBT_0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x12\x90\x82\x01Rq\x05\x04\xF4\xF4\xC5\xF4$\xF5%$\xF5u\xF5$\x15DU\xF3`t\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x0C\x90\x82\x01Rk\x05\x04\xF4\xF4\xC5\xF5D\xF4\xB4T\xE5\xF3`\xA4\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x1B\x90\x82\x01R\x7FPOOL_LAST_UPDATE_TIME_STAMP\0\0\0\0\0`@\x82\x01R``\x01\x90V\xFE\xA2dipfsX\"\x12 \xAF\xBF.\xDD\xAB\xF8\xDEH\xD0!\xE1\xF6\xAC\xA4\xA3\xE4;\xF8\xABI\xCB\xD5\xB3\xCEp\x8B\x01\x0B4\x95\x91@dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x7300000000000000000000000000000000000000003014608060405260043610610132575f3560e01c806367828979116100b4578063d03aa08911610079578063d03aa089146101c0578063daac4cd9146101c8578063e7856ed4146101d0578063f136c395146101d8578063f5db41ee146101e0575f5ffd5b80636782897914610198578063ab234814146101a0578063b7c3c3e2146101a8578063bd35984b146101b0578063cafe8f10146101b8575f5ffd5b8063496bdfbc116100fa578063496bdfbc1461017057806353cdd8ee146101785780635d8b3aaf146101805780635f91ff1014610188578063644c50fe14610190575f5ffd5b80630702316b14610136578063288b33d1146101505780632a04cf47146101585780633082efcb1461016057806345df019114610168575b5f5ffd5b61013e6101e8565b60405190815260200160405180910390f35b61013e610242565b61013e610271565b61013e6102bc565b61013e6102e9565b61013e610320565b61013e610350565b61013e610391565b61013e6103c8565b61013e610400565b61013e61044b565b61013e61048c565b61013e6104cd565b61013e610505565b61013e610546565b61013e61057c565b61013e6105b2565b61013e6105f3565b61013e610629565b61013e610659565b6040516020016102299060208082526017908201527f504f4f4c5f544f54414c5f434f4c4c41544552414c5f30000000000000000000604082015260600190565b6040516020818303038152906040528051906020012081565b604051602001610229906020808252600b908201526a504f4f4c5f534f5552434560a81b604082015260600190565b6040516020016102299060208082526021908201527f504f4f4c5f544f54414c5f434f4c4c41544552414c5f574954485f444542545f6040820152600360fc1b606082015260800190565b60405160200161022990602080825260099082015268504f4f4c5f42414e4b60b81b604082015260600190565b604051602001610229906020808252601390820152720504f4f4c5f424f52524f575f494e4445585f3606c1b604082015260600190565b604051602001610229906020808252600c908201526b504f4f4c5f544f4b454e5f3160a01b604082015260600190565b6040516020016102299060208082526018908201527f504f4f4c5f544f54414c5f5343414c45445f444542545f310000000000000000604082015260600190565b60405160200161022990602080825260139082015272504f4f4c5f424f52524f575f494e4445585f3160681b604082015260600190565b604051602001610229906020808252601490820152730504f4f4c5f554e434c41494d45445f4645455f360641b604082015260600190565b6040516020016102299060208082526021908201527f504f4f4c5f544f54414c5f434f4c4c41544552414c5f574954485f444542545f6040820152603160f81b606082015260800190565b6040516020016102299060208082526017908201527f504f4f4c5f544f54414c5f434f4c4c41544552414c5f31000000000000000000604082015260600190565b604051602001610229906020808252601b908201527f504f4f4c5f494e5445524553545f524154455f53545241544547590000000000604082015260600190565b60405160200161022990602080825260149082015273504f4f4c5f554e434c41494d45445f4645455f3160601b604082015260600190565b6040516020016102299060208082526017908201527f504f4f4c5f435245415445445f54494d455f5354414d50000000000000000000604082015260600190565b60405160200161022990602080825260129082015271504f4f4c5f424f52524f575f524154455f3160701b604082015260600190565b604051602001610229906020808252601290820152712827a7a62fa1a7a72324a3aaa920aa24a7a760711b604082015260600190565b6040516020016102299060208082526018908201527f504f4f4c5f544f54414c5f5343414c45445f444542545f300000000000000000604082015260600190565b604051602001610229906020808252601290820152710504f4f4c5f424f52524f575f524154455f360741b604082015260600190565b604051602001610229906020808252600c908201526b0504f4f4c5f544f4b454e5f360a41b604082015260600190565b604051602001610229906020808252601b908201527f504f4f4c5f4c4153545f5550444154455f54494d455f5354414d50000000000060408201526060019056fea2646970667358221220afbf2eddabf8de48d021e1f6aca4a3e43bf8ab49cbd5b3ce708b010b3495914064736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"s\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R`\x046\x10a\x012W_5`\xE0\x1C\x80cg\x82\x89y\x11a\0\xB4W\x80c\xD0:\xA0\x89\x11a\0yW\x80c\xD0:\xA0\x89\x14a\x01\xC0W\x80c\xDA\xACL\xD9\x14a\x01\xC8W\x80c\xE7\x85n\xD4\x14a\x01\xD0W\x80c\xF16\xC3\x95\x14a\x01\xD8W\x80c\xF5\xDBA\xEE\x14a\x01\xE0W__\xFD[\x80cg\x82\x89y\x14a\x01\x98W\x80c\xAB#H\x14\x14a\x01\xA0W\x80c\xB7\xC3\xC3\xE2\x14a\x01\xA8W\x80c\xBD5\x98K\x14a\x01\xB0W\x80c\xCA\xFE\x8F\x10\x14a\x01\xB8W__\xFD[\x80cIk\xDF\xBC\x11a\0\xFAW\x80cIk\xDF\xBC\x14a\x01pW\x80cS\xCD\xD8\xEE\x14a\x01xW\x80c]\x8B:\xAF\x14a\x01\x80W\x80c_\x91\xFF\x10\x14a\x01\x88W\x80cdLP\xFE\x14a\x01\x90W__\xFD[\x80c\x07\x021k\x14a\x016W\x80c(\x8B3\xD1\x14a\x01PW\x80c*\x04\xCFG\x14a\x01XW\x80c0\x82\xEF\xCB\x14a\x01`W\x80cE\xDF\x01\x91\x14a\x01hW[__\xFD[a\x01>a\x01\xE8V[`@Q\x90\x81R` \x01`@Q\x80\x91\x03\x90\xF3[a\x01>a\x02BV[a\x01>a\x02qV[a\x01>a\x02\xBCV[a\x01>a\x02\xE9V[a\x01>a\x03 V[a\x01>a\x03PV[a\x01>a\x03\x91V[a\x01>a\x03\xC8V[a\x01>a\x04\0V[a\x01>a\x04KV[a\x01>a\x04\x8CV[a\x01>a\x04\xCDV[a\x01>a\x05\x05V[a\x01>a\x05FV[a\x01>a\x05|V[a\x01>a\x05\xB2V[a\x01>a\x05\xF3V[a\x01>a\x06)V[a\x01>a\x06YV[`@Q` \x01a\x02)\x90` \x80\x82R`\x17\x90\x82\x01R\x7FPOOL_TOTAL_COLLATERAL_0\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x81V[`@Q` \x01a\x02)\x90` \x80\x82R`\x0B\x90\x82\x01RjPOOL_SOURCE`\xA8\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`!\x90\x82\x01R\x7FPOOL_TOTAL_COLLATERAL_WITH_DEBT_`@\x82\x01R`\x03`\xFC\x1B``\x82\x01R`\x80\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\t\x90\x82\x01RhPOOL_BANK`\xB8\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x13\x90\x82\x01Rr\x05\x04\xF4\xF4\xC5\xF4$\xF5%$\xF5u\xF4\x94\xE4DU\x85\xF3`l\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x0C\x90\x82\x01RkPOOL_TOKEN_1`\xA0\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x18\x90\x82\x01R\x7FPOOL_TOTAL_SCALED_DEBT_1\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x13\x90\x82\x01RrPOOL_BORROW_INDEX_1`h\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x14\x90\x82\x01Rs\x05\x04\xF4\xF4\xC5\xF5T\xE44\xC4\x14\x94\xD4TE\xF4dTU\xF3`d\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`!\x90\x82\x01R\x7FPOOL_TOTAL_COLLATERAL_WITH_DEBT_`@\x82\x01R`1`\xF8\x1B``\x82\x01R`\x80\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x17\x90\x82\x01R\x7FPOOL_TOTAL_COLLATERAL_1\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x1B\x90\x82\x01R\x7FPOOL_INTEREST_RATE_STRATEGY\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x14\x90\x82\x01RsPOOL_UNCLAIMED_FEE_1``\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x17\x90\x82\x01R\x7FPOOL_CREATED_TIME_STAMP\0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x12\x90\x82\x01RqPOOL_BORROW_RATE_1`p\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x12\x90\x82\x01Rq('\xA7\xA6/\xA1\xA7\xA7#$\xA3\xAA\xA9 \xAA$\xA7\xA7`q\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x18\x90\x82\x01R\x7FPOOL_TOTAL_SCALED_DEBT_0\0\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x12\x90\x82\x01Rq\x05\x04\xF4\xF4\xC5\xF4$\xF5%$\xF5u\xF5$\x15DU\xF3`t\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x0C\x90\x82\x01Rk\x05\x04\xF4\xF4\xC5\xF5D\xF4\xB4T\xE5\xF3`\xA4\x1B`@\x82\x01R``\x01\x90V[`@Q` \x01a\x02)\x90` \x80\x82R`\x1B\x90\x82\x01R\x7FPOOL_LAST_UPDATE_TIME_STAMP\0\0\0\0\0`@\x82\x01R``\x01\x90V\xFE\xA2dipfsX\"\x12 \xAF\xBF.\xDD\xAB\xF8\xDEH\xD0!\xE1\xF6\xAC\xA4\xA3\xE4;\xF8\xABI\xCB\xD5\xB3\xCEp\x8B\x01\x0B4\x95\x91@dsolcC\0\x08\x1C\x003",
    );
    /**Function with signature `POOL_BANK()` and selector `0x3082efcb`.
```solidity
function POOL_BANK() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BANKCall {}
    ///Container type for the return parameters of the [`POOL_BANK()`](POOL_BANKCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BANKReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BANKCall> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BANKCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_BANKCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BANKReturn> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BANKReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_BANKReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_BANKCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_BANKReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_BANK()";
            const SELECTOR: [u8; 4] = [48u8, 130u8, 239u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_BORROW_INDEX_0()` and selector `0x45df0191`.
```solidity
function POOL_BORROW_INDEX_0() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BORROW_INDEX_0Call {}
    ///Container type for the return parameters of the [`POOL_BORROW_INDEX_0()`](POOL_BORROW_INDEX_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BORROW_INDEX_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BORROW_INDEX_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BORROW_INDEX_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_BORROW_INDEX_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BORROW_INDEX_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BORROW_INDEX_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_BORROW_INDEX_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_BORROW_INDEX_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_BORROW_INDEX_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_BORROW_INDEX_0()";
            const SELECTOR: [u8; 4] = [69u8, 223u8, 1u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_BORROW_INDEX_1()` and selector `0x5d8b3aaf`.
```solidity
function POOL_BORROW_INDEX_1() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BORROW_INDEX_1Call {}
    ///Container type for the return parameters of the [`POOL_BORROW_INDEX_1()`](POOL_BORROW_INDEX_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BORROW_INDEX_1Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BORROW_INDEX_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BORROW_INDEX_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_BORROW_INDEX_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BORROW_INDEX_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BORROW_INDEX_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_BORROW_INDEX_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_BORROW_INDEX_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_BORROW_INDEX_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_BORROW_INDEX_1()";
            const SELECTOR: [u8; 4] = [93u8, 139u8, 58u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_BORROW_RATE_0()` and selector `0xe7856ed4`.
```solidity
function POOL_BORROW_RATE_0() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BORROW_RATE_0Call {}
    ///Container type for the return parameters of the [`POOL_BORROW_RATE_0()`](POOL_BORROW_RATE_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BORROW_RATE_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BORROW_RATE_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BORROW_RATE_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_BORROW_RATE_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BORROW_RATE_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BORROW_RATE_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_BORROW_RATE_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_BORROW_RATE_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_BORROW_RATE_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_BORROW_RATE_0()";
            const SELECTOR: [u8; 4] = [231u8, 133u8, 110u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_BORROW_RATE_1()` and selector `0xcafe8f10`.
```solidity
function POOL_BORROW_RATE_1() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BORROW_RATE_1Call {}
    ///Container type for the return parameters of the [`POOL_BORROW_RATE_1()`](POOL_BORROW_RATE_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_BORROW_RATE_1Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BORROW_RATE_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BORROW_RATE_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_BORROW_RATE_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_BORROW_RATE_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_BORROW_RATE_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_BORROW_RATE_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_BORROW_RATE_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_BORROW_RATE_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_BORROW_RATE_1()";
            const SELECTOR: [u8; 4] = [202u8, 254u8, 143u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_CONFIGURATION()` and selector `0xd03aa089`.
```solidity
function POOL_CONFIGURATION() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_CONFIGURATIONCall {}
    ///Container type for the return parameters of the [`POOL_CONFIGURATION()`](POOL_CONFIGURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_CONFIGURATIONReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_CONFIGURATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_CONFIGURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_CONFIGURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_CONFIGURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_CONFIGURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_CONFIGURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_CONFIGURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_CONFIGURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_CONFIGURATION()";
            const SELECTOR: [u8; 4] = [208u8, 58u8, 160u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_CREATED_TIME_STAMP()` and selector `0xbd35984b`.
```solidity
function POOL_CREATED_TIME_STAMP() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_CREATED_TIME_STAMPCall {}
    ///Container type for the return parameters of the [`POOL_CREATED_TIME_STAMP()`](POOL_CREATED_TIME_STAMPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_CREATED_TIME_STAMPReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_CREATED_TIME_STAMPCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_CREATED_TIME_STAMPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_CREATED_TIME_STAMPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_CREATED_TIME_STAMPReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_CREATED_TIME_STAMPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_CREATED_TIME_STAMPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_CREATED_TIME_STAMPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_CREATED_TIME_STAMPReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_CREATED_TIME_STAMP()";
            const SELECTOR: [u8; 4] = [189u8, 53u8, 152u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_INTEREST_RATE_STRATEGY()` and selector `0xab234814`.
```solidity
function POOL_INTEREST_RATE_STRATEGY() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_INTEREST_RATE_STRATEGYCall {}
    ///Container type for the return parameters of the [`POOL_INTEREST_RATE_STRATEGY()`](POOL_INTEREST_RATE_STRATEGYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_INTEREST_RATE_STRATEGYReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_INTEREST_RATE_STRATEGYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_INTEREST_RATE_STRATEGYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_INTEREST_RATE_STRATEGYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_INTEREST_RATE_STRATEGYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_INTEREST_RATE_STRATEGYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_INTEREST_RATE_STRATEGYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_INTEREST_RATE_STRATEGYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_INTEREST_RATE_STRATEGYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_INTEREST_RATE_STRATEGY()";
            const SELECTOR: [u8; 4] = [171u8, 35u8, 72u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_LAST_UPDATE_TIME_STAMP()` and selector `0xf5db41ee`.
```solidity
function POOL_LAST_UPDATE_TIME_STAMP() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_LAST_UPDATE_TIME_STAMPCall {}
    ///Container type for the return parameters of the [`POOL_LAST_UPDATE_TIME_STAMP()`](POOL_LAST_UPDATE_TIME_STAMPCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_LAST_UPDATE_TIME_STAMPReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_LAST_UPDATE_TIME_STAMPCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_LAST_UPDATE_TIME_STAMPCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_LAST_UPDATE_TIME_STAMPCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_LAST_UPDATE_TIME_STAMPReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_LAST_UPDATE_TIME_STAMPReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_LAST_UPDATE_TIME_STAMPReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_LAST_UPDATE_TIME_STAMPCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_LAST_UPDATE_TIME_STAMPReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_LAST_UPDATE_TIME_STAMP()";
            const SELECTOR: [u8; 4] = [245u8, 219u8, 65u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_SOURCE()` and selector `0x288b33d1`.
```solidity
function POOL_SOURCE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_SOURCECall {}
    ///Container type for the return parameters of the [`POOL_SOURCE()`](POOL_SOURCECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_SOURCEReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_SOURCECall> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_SOURCECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_SOURCECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_SOURCEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_SOURCEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_SOURCEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_SOURCECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_SOURCEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_SOURCE()";
            const SELECTOR: [u8; 4] = [40u8, 139u8, 51u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_TOKEN_0()` and selector `0xf136c395`.
```solidity
function POOL_TOKEN_0() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOKEN_0Call {}
    ///Container type for the return parameters of the [`POOL_TOKEN_0()`](POOL_TOKEN_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOKEN_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOKEN_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOKEN_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_TOKEN_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOKEN_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOKEN_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_TOKEN_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_TOKEN_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_TOKEN_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_TOKEN_0()";
            const SELECTOR: [u8; 4] = [241u8, 54u8, 195u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_TOKEN_1()` and selector `0x496bdfbc`.
```solidity
function POOL_TOKEN_1() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOKEN_1Call {}
    ///Container type for the return parameters of the [`POOL_TOKEN_1()`](POOL_TOKEN_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOKEN_1Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOKEN_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOKEN_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_TOKEN_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOKEN_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOKEN_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for POOL_TOKEN_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_TOKEN_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_TOKEN_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_TOKEN_1()";
            const SELECTOR: [u8; 4] = [73u8, 107u8, 223u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_TOTAL_COLLATERAL_0()` and selector `0x0702316b`.
```solidity
function POOL_TOTAL_COLLATERAL_0() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_COLLATERAL_0Call {}
    ///Container type for the return parameters of the [`POOL_TOTAL_COLLATERAL_0()`](POOL_TOTAL_COLLATERAL_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_COLLATERAL_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_COLLATERAL_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_COLLATERAL_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_COLLATERAL_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_COLLATERAL_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_COLLATERAL_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_COLLATERAL_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_TOTAL_COLLATERAL_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_TOTAL_COLLATERAL_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_TOTAL_COLLATERAL_0()";
            const SELECTOR: [u8; 4] = [7u8, 2u8, 49u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_TOTAL_COLLATERAL_1()` and selector `0x67828979`.
```solidity
function POOL_TOTAL_COLLATERAL_1() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_COLLATERAL_1Call {}
    ///Container type for the return parameters of the [`POOL_TOTAL_COLLATERAL_1()`](POOL_TOTAL_COLLATERAL_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_COLLATERAL_1Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_COLLATERAL_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_COLLATERAL_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_COLLATERAL_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_COLLATERAL_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_COLLATERAL_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_COLLATERAL_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_TOTAL_COLLATERAL_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_TOTAL_COLLATERAL_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_TOTAL_COLLATERAL_1()";
            const SELECTOR: [u8; 4] = [103u8, 130u8, 137u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_TOTAL_COLLATERAL_WITH_DEBT_0()` and selector `0x2a04cf47`.
```solidity
function POOL_TOTAL_COLLATERAL_WITH_DEBT_0() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call {}
    ///Container type for the return parameters of the [`POOL_TOTAL_COLLATERAL_WITH_DEBT_0()`](POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_COLLATERAL_WITH_DEBT_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_COLLATERAL_WITH_DEBT_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_COLLATERAL_WITH_DEBT_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_COLLATERAL_WITH_DEBT_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_TOTAL_COLLATERAL_WITH_DEBT_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_TOTAL_COLLATERAL_WITH_DEBT_0()";
            const SELECTOR: [u8; 4] = [42u8, 4u8, 207u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_TOTAL_COLLATERAL_WITH_DEBT_1()` and selector `0x644c50fe`.
```solidity
function POOL_TOTAL_COLLATERAL_WITH_DEBT_1() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call {}
    ///Container type for the return parameters of the [`POOL_TOTAL_COLLATERAL_WITH_DEBT_1()`](POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_COLLATERAL_WITH_DEBT_1Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_COLLATERAL_WITH_DEBT_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_COLLATERAL_WITH_DEBT_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_COLLATERAL_WITH_DEBT_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_TOTAL_COLLATERAL_WITH_DEBT_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_TOTAL_COLLATERAL_WITH_DEBT_1()";
            const SELECTOR: [u8; 4] = [100u8, 76u8, 80u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_TOTAL_SCALED_DEBT_0()` and selector `0xdaac4cd9`.
```solidity
function POOL_TOTAL_SCALED_DEBT_0() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_SCALED_DEBT_0Call {}
    ///Container type for the return parameters of the [`POOL_TOTAL_SCALED_DEBT_0()`](POOL_TOTAL_SCALED_DEBT_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_SCALED_DEBT_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_SCALED_DEBT_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_SCALED_DEBT_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_SCALED_DEBT_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_SCALED_DEBT_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_SCALED_DEBT_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_SCALED_DEBT_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_TOTAL_SCALED_DEBT_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_TOTAL_SCALED_DEBT_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_TOTAL_SCALED_DEBT_0()";
            const SELECTOR: [u8; 4] = [218u8, 172u8, 76u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_TOTAL_SCALED_DEBT_1()` and selector `0x53cdd8ee`.
```solidity
function POOL_TOTAL_SCALED_DEBT_1() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_SCALED_DEBT_1Call {}
    ///Container type for the return parameters of the [`POOL_TOTAL_SCALED_DEBT_1()`](POOL_TOTAL_SCALED_DEBT_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_TOTAL_SCALED_DEBT_1Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_SCALED_DEBT_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_SCALED_DEBT_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_SCALED_DEBT_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_TOTAL_SCALED_DEBT_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_TOTAL_SCALED_DEBT_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_TOTAL_SCALED_DEBT_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_TOTAL_SCALED_DEBT_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_TOTAL_SCALED_DEBT_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_TOTAL_SCALED_DEBT_1()";
            const SELECTOR: [u8; 4] = [83u8, 205u8, 216u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_UNCLAIMED_FEE_0()` and selector `0x5f91ff10`.
```solidity
function POOL_UNCLAIMED_FEE_0() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_UNCLAIMED_FEE_0Call {}
    ///Container type for the return parameters of the [`POOL_UNCLAIMED_FEE_0()`](POOL_UNCLAIMED_FEE_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_UNCLAIMED_FEE_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_UNCLAIMED_FEE_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_UNCLAIMED_FEE_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_UNCLAIMED_FEE_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_UNCLAIMED_FEE_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_UNCLAIMED_FEE_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_UNCLAIMED_FEE_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_UNCLAIMED_FEE_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_UNCLAIMED_FEE_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_UNCLAIMED_FEE_0()";
            const SELECTOR: [u8; 4] = [95u8, 145u8, 255u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `POOL_UNCLAIMED_FEE_1()` and selector `0xb7c3c3e2`.
```solidity
function POOL_UNCLAIMED_FEE_1() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_UNCLAIMED_FEE_1Call {}
    ///Container type for the return parameters of the [`POOL_UNCLAIMED_FEE_1()`](POOL_UNCLAIMED_FEE_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct POOL_UNCLAIMED_FEE_1Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_UNCLAIMED_FEE_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_UNCLAIMED_FEE_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_UNCLAIMED_FEE_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<POOL_UNCLAIMED_FEE_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: POOL_UNCLAIMED_FEE_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for POOL_UNCLAIMED_FEE_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for POOL_UNCLAIMED_FEE_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = POOL_UNCLAIMED_FEE_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "POOL_UNCLAIMED_FEE_1()";
            const SELECTOR: [u8; 4] = [183u8, 195u8, 195u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`PoolStoreUtils`](self) function calls.
    pub enum PoolStoreUtilsCalls {
        POOL_BANK(POOL_BANKCall),
        POOL_BORROW_INDEX_0(POOL_BORROW_INDEX_0Call),
        POOL_BORROW_INDEX_1(POOL_BORROW_INDEX_1Call),
        POOL_BORROW_RATE_0(POOL_BORROW_RATE_0Call),
        POOL_BORROW_RATE_1(POOL_BORROW_RATE_1Call),
        POOL_CONFIGURATION(POOL_CONFIGURATIONCall),
        POOL_CREATED_TIME_STAMP(POOL_CREATED_TIME_STAMPCall),
        POOL_INTEREST_RATE_STRATEGY(POOL_INTEREST_RATE_STRATEGYCall),
        POOL_LAST_UPDATE_TIME_STAMP(POOL_LAST_UPDATE_TIME_STAMPCall),
        POOL_SOURCE(POOL_SOURCECall),
        POOL_TOKEN_0(POOL_TOKEN_0Call),
        POOL_TOKEN_1(POOL_TOKEN_1Call),
        POOL_TOTAL_COLLATERAL_0(POOL_TOTAL_COLLATERAL_0Call),
        POOL_TOTAL_COLLATERAL_1(POOL_TOTAL_COLLATERAL_1Call),
        POOL_TOTAL_COLLATERAL_WITH_DEBT_0(POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call),
        POOL_TOTAL_COLLATERAL_WITH_DEBT_1(POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call),
        POOL_TOTAL_SCALED_DEBT_0(POOL_TOTAL_SCALED_DEBT_0Call),
        POOL_TOTAL_SCALED_DEBT_1(POOL_TOTAL_SCALED_DEBT_1Call),
        POOL_UNCLAIMED_FEE_0(POOL_UNCLAIMED_FEE_0Call),
        POOL_UNCLAIMED_FEE_1(POOL_UNCLAIMED_FEE_1Call),
    }
    #[automatically_derived]
    impl PoolStoreUtilsCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [7u8, 2u8, 49u8, 107u8],
            [40u8, 139u8, 51u8, 209u8],
            [42u8, 4u8, 207u8, 71u8],
            [48u8, 130u8, 239u8, 203u8],
            [69u8, 223u8, 1u8, 145u8],
            [73u8, 107u8, 223u8, 188u8],
            [83u8, 205u8, 216u8, 238u8],
            [93u8, 139u8, 58u8, 175u8],
            [95u8, 145u8, 255u8, 16u8],
            [100u8, 76u8, 80u8, 254u8],
            [103u8, 130u8, 137u8, 121u8],
            [171u8, 35u8, 72u8, 20u8],
            [183u8, 195u8, 195u8, 226u8],
            [189u8, 53u8, 152u8, 75u8],
            [202u8, 254u8, 143u8, 16u8],
            [208u8, 58u8, 160u8, 137u8],
            [218u8, 172u8, 76u8, 217u8],
            [231u8, 133u8, 110u8, 212u8],
            [241u8, 54u8, 195u8, 149u8],
            [245u8, 219u8, 65u8, 238u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for PoolStoreUtilsCalls {
        const NAME: &'static str = "PoolStoreUtilsCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 20usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::POOL_BANK(_) => {
                    <POOL_BANKCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_BORROW_INDEX_0(_) => {
                    <POOL_BORROW_INDEX_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_BORROW_INDEX_1(_) => {
                    <POOL_BORROW_INDEX_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_BORROW_RATE_0(_) => {
                    <POOL_BORROW_RATE_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_BORROW_RATE_1(_) => {
                    <POOL_BORROW_RATE_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_CONFIGURATION(_) => {
                    <POOL_CONFIGURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_CREATED_TIME_STAMP(_) => {
                    <POOL_CREATED_TIME_STAMPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_INTEREST_RATE_STRATEGY(_) => {
                    <POOL_INTEREST_RATE_STRATEGYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_LAST_UPDATE_TIME_STAMP(_) => {
                    <POOL_LAST_UPDATE_TIME_STAMPCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_SOURCE(_) => {
                    <POOL_SOURCECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_TOKEN_0(_) => {
                    <POOL_TOKEN_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_TOKEN_1(_) => {
                    <POOL_TOKEN_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_TOTAL_COLLATERAL_0(_) => {
                    <POOL_TOTAL_COLLATERAL_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_TOTAL_COLLATERAL_1(_) => {
                    <POOL_TOTAL_COLLATERAL_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_TOTAL_COLLATERAL_WITH_DEBT_0(_) => {
                    <POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_TOTAL_COLLATERAL_WITH_DEBT_1(_) => {
                    <POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_TOTAL_SCALED_DEBT_0(_) => {
                    <POOL_TOTAL_SCALED_DEBT_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_TOTAL_SCALED_DEBT_1(_) => {
                    <POOL_TOTAL_SCALED_DEBT_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_UNCLAIMED_FEE_0(_) => {
                    <POOL_UNCLAIMED_FEE_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::POOL_UNCLAIMED_FEE_1(_) => {
                    <POOL_UNCLAIMED_FEE_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<PoolStoreUtilsCalls>] = &[
                {
                    fn POOL_TOTAL_COLLATERAL_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_TOTAL_COLLATERAL_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_TOTAL_COLLATERAL_0)
                    }
                    POOL_TOTAL_COLLATERAL_0
                },
                {
                    fn POOL_SOURCE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_SOURCECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_SOURCE)
                    }
                    POOL_SOURCE
                },
                {
                    fn POOL_TOTAL_COLLATERAL_WITH_DEBT_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_TOTAL_COLLATERAL_WITH_DEBT_0)
                    }
                    POOL_TOTAL_COLLATERAL_WITH_DEBT_0
                },
                {
                    fn POOL_BANK(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_BANKCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_BANK)
                    }
                    POOL_BANK
                },
                {
                    fn POOL_BORROW_INDEX_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_BORROW_INDEX_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_BORROW_INDEX_0)
                    }
                    POOL_BORROW_INDEX_0
                },
                {
                    fn POOL_TOKEN_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_TOKEN_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_TOKEN_1)
                    }
                    POOL_TOKEN_1
                },
                {
                    fn POOL_TOTAL_SCALED_DEBT_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_TOTAL_SCALED_DEBT_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_TOTAL_SCALED_DEBT_1)
                    }
                    POOL_TOTAL_SCALED_DEBT_1
                },
                {
                    fn POOL_BORROW_INDEX_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_BORROW_INDEX_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_BORROW_INDEX_1)
                    }
                    POOL_BORROW_INDEX_1
                },
                {
                    fn POOL_UNCLAIMED_FEE_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_UNCLAIMED_FEE_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_UNCLAIMED_FEE_0)
                    }
                    POOL_UNCLAIMED_FEE_0
                },
                {
                    fn POOL_TOTAL_COLLATERAL_WITH_DEBT_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_TOTAL_COLLATERAL_WITH_DEBT_1)
                    }
                    POOL_TOTAL_COLLATERAL_WITH_DEBT_1
                },
                {
                    fn POOL_TOTAL_COLLATERAL_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_TOTAL_COLLATERAL_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_TOTAL_COLLATERAL_1)
                    }
                    POOL_TOTAL_COLLATERAL_1
                },
                {
                    fn POOL_INTEREST_RATE_STRATEGY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_INTEREST_RATE_STRATEGYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_INTEREST_RATE_STRATEGY)
                    }
                    POOL_INTEREST_RATE_STRATEGY
                },
                {
                    fn POOL_UNCLAIMED_FEE_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_UNCLAIMED_FEE_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_UNCLAIMED_FEE_1)
                    }
                    POOL_UNCLAIMED_FEE_1
                },
                {
                    fn POOL_CREATED_TIME_STAMP(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_CREATED_TIME_STAMPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_CREATED_TIME_STAMP)
                    }
                    POOL_CREATED_TIME_STAMP
                },
                {
                    fn POOL_BORROW_RATE_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_BORROW_RATE_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_BORROW_RATE_1)
                    }
                    POOL_BORROW_RATE_1
                },
                {
                    fn POOL_CONFIGURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_CONFIGURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_CONFIGURATION)
                    }
                    POOL_CONFIGURATION
                },
                {
                    fn POOL_TOTAL_SCALED_DEBT_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_TOTAL_SCALED_DEBT_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_TOTAL_SCALED_DEBT_0)
                    }
                    POOL_TOTAL_SCALED_DEBT_0
                },
                {
                    fn POOL_BORROW_RATE_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_BORROW_RATE_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_BORROW_RATE_0)
                    }
                    POOL_BORROW_RATE_0
                },
                {
                    fn POOL_TOKEN_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_TOKEN_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_TOKEN_0)
                    }
                    POOL_TOKEN_0
                },
                {
                    fn POOL_LAST_UPDATE_TIME_STAMP(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolStoreUtilsCalls> {
                        <POOL_LAST_UPDATE_TIME_STAMPCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolStoreUtilsCalls::POOL_LAST_UPDATE_TIME_STAMP)
                    }
                    POOL_LAST_UPDATE_TIME_STAMP
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::POOL_BANK(inner) => {
                    <POOL_BANKCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::POOL_BORROW_INDEX_0(inner) => {
                    <POOL_BORROW_INDEX_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_BORROW_INDEX_1(inner) => {
                    <POOL_BORROW_INDEX_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_BORROW_RATE_0(inner) => {
                    <POOL_BORROW_RATE_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_BORROW_RATE_1(inner) => {
                    <POOL_BORROW_RATE_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_CONFIGURATION(inner) => {
                    <POOL_CONFIGURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_CREATED_TIME_STAMP(inner) => {
                    <POOL_CREATED_TIME_STAMPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_INTEREST_RATE_STRATEGY(inner) => {
                    <POOL_INTEREST_RATE_STRATEGYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_LAST_UPDATE_TIME_STAMP(inner) => {
                    <POOL_LAST_UPDATE_TIME_STAMPCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_SOURCE(inner) => {
                    <POOL_SOURCECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_TOKEN_0(inner) => {
                    <POOL_TOKEN_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_TOKEN_1(inner) => {
                    <POOL_TOKEN_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_TOTAL_COLLATERAL_0(inner) => {
                    <POOL_TOTAL_COLLATERAL_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_TOTAL_COLLATERAL_1(inner) => {
                    <POOL_TOTAL_COLLATERAL_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_TOTAL_COLLATERAL_WITH_DEBT_0(inner) => {
                    <POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_TOTAL_COLLATERAL_WITH_DEBT_1(inner) => {
                    <POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_TOTAL_SCALED_DEBT_0(inner) => {
                    <POOL_TOTAL_SCALED_DEBT_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_TOTAL_SCALED_DEBT_1(inner) => {
                    <POOL_TOTAL_SCALED_DEBT_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_UNCLAIMED_FEE_0(inner) => {
                    <POOL_UNCLAIMED_FEE_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::POOL_UNCLAIMED_FEE_1(inner) => {
                    <POOL_UNCLAIMED_FEE_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::POOL_BANK(inner) => {
                    <POOL_BANKCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_BORROW_INDEX_0(inner) => {
                    <POOL_BORROW_INDEX_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_BORROW_INDEX_1(inner) => {
                    <POOL_BORROW_INDEX_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_BORROW_RATE_0(inner) => {
                    <POOL_BORROW_RATE_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_BORROW_RATE_1(inner) => {
                    <POOL_BORROW_RATE_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_CONFIGURATION(inner) => {
                    <POOL_CONFIGURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_CREATED_TIME_STAMP(inner) => {
                    <POOL_CREATED_TIME_STAMPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_INTEREST_RATE_STRATEGY(inner) => {
                    <POOL_INTEREST_RATE_STRATEGYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_LAST_UPDATE_TIME_STAMP(inner) => {
                    <POOL_LAST_UPDATE_TIME_STAMPCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_SOURCE(inner) => {
                    <POOL_SOURCECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_TOKEN_0(inner) => {
                    <POOL_TOKEN_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_TOKEN_1(inner) => {
                    <POOL_TOKEN_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_TOTAL_COLLATERAL_0(inner) => {
                    <POOL_TOTAL_COLLATERAL_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_TOTAL_COLLATERAL_1(inner) => {
                    <POOL_TOTAL_COLLATERAL_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_TOTAL_COLLATERAL_WITH_DEBT_0(inner) => {
                    <POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_TOTAL_COLLATERAL_WITH_DEBT_1(inner) => {
                    <POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_TOTAL_SCALED_DEBT_0(inner) => {
                    <POOL_TOTAL_SCALED_DEBT_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_TOTAL_SCALED_DEBT_1(inner) => {
                    <POOL_TOTAL_SCALED_DEBT_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_UNCLAIMED_FEE_0(inner) => {
                    <POOL_UNCLAIMED_FEE_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::POOL_UNCLAIMED_FEE_1(inner) => {
                    <POOL_UNCLAIMED_FEE_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`PoolStoreUtils`](self) contract instance.

See the [wrapper's documentation](`PoolStoreUtilsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> PoolStoreUtilsInstance<T, P, N> {
        PoolStoreUtilsInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<PoolStoreUtilsInstance<T, P, N>>,
    > {
        PoolStoreUtilsInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        PoolStoreUtilsInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`PoolStoreUtils`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`PoolStoreUtils`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct PoolStoreUtilsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for PoolStoreUtilsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("PoolStoreUtilsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > PoolStoreUtilsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`PoolStoreUtils`](self) contract instance.

See the [wrapper's documentation](`PoolStoreUtilsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<PoolStoreUtilsInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> PoolStoreUtilsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> PoolStoreUtilsInstance<T, P, N> {
            PoolStoreUtilsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > PoolStoreUtilsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`POOL_BANK`] function.
        pub fn POOL_BANK(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_BANKCall, N> {
            self.call_builder(&POOL_BANKCall {})
        }
        ///Creates a new call builder for the [`POOL_BORROW_INDEX_0`] function.
        pub fn POOL_BORROW_INDEX_0(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_BORROW_INDEX_0Call, N> {
            self.call_builder(&POOL_BORROW_INDEX_0Call {})
        }
        ///Creates a new call builder for the [`POOL_BORROW_INDEX_1`] function.
        pub fn POOL_BORROW_INDEX_1(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_BORROW_INDEX_1Call, N> {
            self.call_builder(&POOL_BORROW_INDEX_1Call {})
        }
        ///Creates a new call builder for the [`POOL_BORROW_RATE_0`] function.
        pub fn POOL_BORROW_RATE_0(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_BORROW_RATE_0Call, N> {
            self.call_builder(&POOL_BORROW_RATE_0Call {})
        }
        ///Creates a new call builder for the [`POOL_BORROW_RATE_1`] function.
        pub fn POOL_BORROW_RATE_1(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_BORROW_RATE_1Call, N> {
            self.call_builder(&POOL_BORROW_RATE_1Call {})
        }
        ///Creates a new call builder for the [`POOL_CONFIGURATION`] function.
        pub fn POOL_CONFIGURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_CONFIGURATIONCall, N> {
            self.call_builder(&POOL_CONFIGURATIONCall {})
        }
        ///Creates a new call builder for the [`POOL_CREATED_TIME_STAMP`] function.
        pub fn POOL_CREATED_TIME_STAMP(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_CREATED_TIME_STAMPCall, N> {
            self.call_builder(&POOL_CREATED_TIME_STAMPCall {})
        }
        ///Creates a new call builder for the [`POOL_INTEREST_RATE_STRATEGY`] function.
        pub fn POOL_INTEREST_RATE_STRATEGY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_INTEREST_RATE_STRATEGYCall, N> {
            self.call_builder(&POOL_INTEREST_RATE_STRATEGYCall {})
        }
        ///Creates a new call builder for the [`POOL_LAST_UPDATE_TIME_STAMP`] function.
        pub fn POOL_LAST_UPDATE_TIME_STAMP(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_LAST_UPDATE_TIME_STAMPCall, N> {
            self.call_builder(&POOL_LAST_UPDATE_TIME_STAMPCall {})
        }
        ///Creates a new call builder for the [`POOL_SOURCE`] function.
        pub fn POOL_SOURCE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_SOURCECall, N> {
            self.call_builder(&POOL_SOURCECall {})
        }
        ///Creates a new call builder for the [`POOL_TOKEN_0`] function.
        pub fn POOL_TOKEN_0(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_TOKEN_0Call, N> {
            self.call_builder(&POOL_TOKEN_0Call {})
        }
        ///Creates a new call builder for the [`POOL_TOKEN_1`] function.
        pub fn POOL_TOKEN_1(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_TOKEN_1Call, N> {
            self.call_builder(&POOL_TOKEN_1Call {})
        }
        ///Creates a new call builder for the [`POOL_TOTAL_COLLATERAL_0`] function.
        pub fn POOL_TOTAL_COLLATERAL_0(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_TOTAL_COLLATERAL_0Call, N> {
            self.call_builder(&POOL_TOTAL_COLLATERAL_0Call {})
        }
        ///Creates a new call builder for the [`POOL_TOTAL_COLLATERAL_1`] function.
        pub fn POOL_TOTAL_COLLATERAL_1(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_TOTAL_COLLATERAL_1Call, N> {
            self.call_builder(&POOL_TOTAL_COLLATERAL_1Call {})
        }
        ///Creates a new call builder for the [`POOL_TOTAL_COLLATERAL_WITH_DEBT_0`] function.
        pub fn POOL_TOTAL_COLLATERAL_WITH_DEBT_0(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call,
            N,
        > {
            self.call_builder(
                &POOL_TOTAL_COLLATERAL_WITH_DEBT_0Call {
                },
            )
        }
        ///Creates a new call builder for the [`POOL_TOTAL_COLLATERAL_WITH_DEBT_1`] function.
        pub fn POOL_TOTAL_COLLATERAL_WITH_DEBT_1(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call,
            N,
        > {
            self.call_builder(
                &POOL_TOTAL_COLLATERAL_WITH_DEBT_1Call {
                },
            )
        }
        ///Creates a new call builder for the [`POOL_TOTAL_SCALED_DEBT_0`] function.
        pub fn POOL_TOTAL_SCALED_DEBT_0(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_TOTAL_SCALED_DEBT_0Call, N> {
            self.call_builder(&POOL_TOTAL_SCALED_DEBT_0Call {})
        }
        ///Creates a new call builder for the [`POOL_TOTAL_SCALED_DEBT_1`] function.
        pub fn POOL_TOTAL_SCALED_DEBT_1(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_TOTAL_SCALED_DEBT_1Call, N> {
            self.call_builder(&POOL_TOTAL_SCALED_DEBT_1Call {})
        }
        ///Creates a new call builder for the [`POOL_UNCLAIMED_FEE_0`] function.
        pub fn POOL_UNCLAIMED_FEE_0(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_UNCLAIMED_FEE_0Call, N> {
            self.call_builder(&POOL_UNCLAIMED_FEE_0Call {})
        }
        ///Creates a new call builder for the [`POOL_UNCLAIMED_FEE_1`] function.
        pub fn POOL_UNCLAIMED_FEE_1(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, POOL_UNCLAIMED_FEE_1Call, N> {
            self.call_builder(&POOL_UNCLAIMED_FEE_1Call {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > PoolStoreUtilsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
